language:='Pascal';
myDict:=unique(['UNIT','PROGRAM','PROCEDURE','FUNCTION','CONSTRUCTOR','DESTRUCTOR','VAR','CONST','OUT','INTERFACE',
         'IMPLEMENTATION','INITIALIZATION','FINALIZATION','if','then','else','case','begin','end','repeat','until',
         'while','do','to','in','ansistring','of','try','except','finally','true','false','value','word','longint',
         'result','assign','reset','rewrite','close','object','record','create','destroy','toString','inherited',
         'setLength','USES','TYPE','array','with','class','C_ID_QUALIFY_CHARACTER','inc','dec',
         "add","append","ARect","Attr","background","beginThread","boolean","bufferSize",
         "callDepth","char","Classes","clear","color","correlation","count","data","dotPos",
         "drive","dword","enterCriticalSection","eof","executable","execute","exit","exitStatus",
         "expandFileName","expression","extended","extractFileExt","extractFileName",
         "extractFilePath","extractRelativePath","factor","file","fileAge","fileExists",
         "fileList","fileName","filePath","fLine","for","foreground","format","formatFloat",
         "free","fTokenId","getEnumName","getRange","hashMask","height","high","hour",
         "index","int64","integer","intToStr","isNan","isUnique","key","leaveCriticalSection",
         "left","line","lines","lowercase","math","maxLongint","message","mnh_litVar","mnh_tokLoc",
         "mrOk","myGenerics","name","Nan","newValue","next","now","oldLen","options","ord","outFile",
         "output","override","paramCount","parameters","paramStr","PByte","point","pointer","poWaitOnExit",
         "PROPERTY","pSize","P_literal","P_token","rereference","round","running","saveToFile","screen",
         "section","self","setRange","shortString","showing","size","sleep","sourceValue","split","start",
         "startTime","stdErr","string","strToFloatDef","strToIntDef","style","subRule","sysutils","text",
         "textFile","time","title","tmp","top","trim","trimLeft","trimRight","trunc","tt_EOL","T_file","T_token",
         "uppercase","virtual","width","windows","write","writeln","xor",'read',
         'doneCriticalSection','FeatureFlags','highlighter','HWTickSupportAvailable','initCriticalSection','inputString',
         'isInfinite','length','low','min','myStringUtil','pop','push','read','readMode','readonly','rect','run','sec',
         'shortint','sizeOf','SystemTimeBase','TickType','TimeBase','TimeBaseCorrelationData','TimeBaseData',
         'TimeBaseSelector','TimeBaseUsed','tokType']);
upperDict:=upper(myDict);
fixToken(s:string)->upper(s) in upperDict and not(s in myDict) ? head(myDict%(upper(myDict)=upper(s))) : s;
fixLine(s:string)->trim(s)="" ? "" : trimRight(each(token,tokenSplit(s,language),&,fixToken(token)));
fixFileLines(S:stringList)->pEach(s,S,fixLine(s));

isIdentifier(x:string)->length(x)>1 and regex.matches(x,'^[a-zA-Z_]+');
isLiteral(x:string)->copy(x,0,1) in ["'",'0'..'9'];

checkConsistency(fileList)->begin
  local allIds:=[];
  local allLiterals:=[];
  
  each(token,flatten(pEach(file,fileList,fileContents(file).tokenSplit('pascal'))),
  begin
    isLiteral(token) 
    ? allLiterals|=token
    : isIdentifier(token) AND not(token in upperDict) 
      ? allIds|=token 
      : void;
    void;
  end);
  allIds:=unique(allIds);
  
  local anyComplaints:=false;
  each(x,unique(upper(allIds)),
  trueCount(upper(allIds)=x)>1
  ? begin
      anyComplaints:=true;
      print('Inconsistent spelling: ',allIds%(upper(allIds)=x));
    end
  : void);
  not(anyComplaints) ? print('Spelling is consistent.') : void;  

  allLiterals:=allLiterals .elementFrequency .sort.trailing(50);
  print('Most frequent literals: ');
  printf("%X%\t%X%",allLiterals%%0,allLiterals%%1);
  void;
end; 

allFiles:=files((allFolders('.')&'/*.pas')|(allFolders('.')&'/*.inc'));
pattern:='checkstyle: %X'&max(length(allFiles))&'% (%I5% lines) ';

fix(filename,readOnly)->begin
  local oldLines:=fileLines(filename);
  local newLines:=fixFileLines(oldLines);
  local diffOut:=format(pattern,filename,size(oldLines));
  oldLines==newLines ? diffOut&=' ok' : begin
    readOnly ? diffOut&=' NOT OKAY:' : diffOut&=' FIXED:';
    diffOut|=each(i,[0..size(newLines)-1],oldLines%i<>newLines%i ? '   <'&(oldLines%i)&">\n   >"&(newLines%i)&'<' : void);
    readOnly ? void : writeFileLines(filename,newLines);
  end;
  printf('%X%',diffOut);
end;

//*Check all files, writing out potential fixes
main("check")->begin
  pEach(s,allFiles,fix(s,true));
  print('Checking spelling consistency in MNH sources');
  checkConsistency(allFiles);
end;


//*Fix all files, writing out fixes
main("fix")->pEach(s,allFiles,fix(s,false));