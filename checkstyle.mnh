USE fileUtil;
language:='Pascal';
myDict:=unique(['UNIT','PROGRAM','PROCEDURE','FUNCTION','CONSTRUCTOR','DESTRUCTOR','VAR','CONST','OUT','INTERFACE',
         'IMPLEMENTATION','INITIALIZATION','FINALIZATION','if','then','else','case','begin','end','repeat','until',
         'while','do','to','in','ansistring','of','try','except','finally','true','false','value','word','longint',
         'result','assign','reset','rewrite','close','object','record','create','destroy','toString','inherited',
         'setLength','USES','TYPE','array']);
fixToken(s:string)->upper(s) in upper(myDict) and not(s in myDict) ? head(myDict%(upper(myDict)=upper(s))) : s;
fixLine(s:string)->trim(s)="" ? "" : trimRight(each(token,tokenSplit(s,language),&,fixToken(token)));
fixFileLines(S:stringList)->pEach(s,S,fixLine(s));

mutable readOnly:=true;
memoized printOnce(text)->print(text);
voidOf(x)->void;

fix(filename         )->fix(filename,fileLines(filename));
fix(filename,oldLines)->fix(filename,oldLines,fixFileLines(oldLines));
fix(filename,oldLines,newLines==oldLines)->false;
fix(filename,oldLines,newLines          )->voidOf(each(i,[0..size(oldLines)-1],
                                                       oldLines%i<>newLines%i ? printOnce(filename) and print('   <',oldLines%i,'>\n   >',newLines%i,'<')
                                                                              : void) |
                                                  (readOnly ? void
                                                            : writeFileLines(filename,newLines)));

//*Check all files, writing out potential fixes
main("check")->                each(s,recFiles(".","*.pas,*.inc"),fix(s));
//*Fix all files, writing out potential fixes
main("fix")->(readOnly:=false)|each(s,recFiles(".","*.pas,*.inc"),fix(s));
