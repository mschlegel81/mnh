private language:='Pascal';
persistent fileCheckedAtTime:=[];

private synchronized fileMustBeChecked(filename:string)->begin
  local checkTime:=fileCheckedAtTime%filename;
  checkTime==[] OR //One second tolerance:
  checkTime+1/(24*60*60)<fileInfo(filename)%'time';
end;

private synchronized fileWasChecked(filename:string)->
  begin
    local updatedEntry:=[filename,fileInfo(filename)%'time'];
    fileCheckedAtTime%filename==[]
    ? fileCheckedAtTime:=fileCheckedAtTime.add([filename,fileInfo(filename)%'time'])
    : fileCheckedAtTime:=each(entry,fileCheckedAtTime,entry%0=filename ? updatedEntry : entry);
  end;

fixToken(s:string)->autoDict.get(upper(s),s);
fixLine(s:string)->trim(s)="" ? "" : each(token,tokenSplit(s,language),fixToken(token)).join.trimRight;
fixFileLines(S:stringList)->pEach(s,S,fixLine(s));

private significance(count:int,literal:string)->max(0,count-1)*max(0,length(literal)-10);

allFiles:=files((allFolders('.')&'/*.pas')|(allFolders('.')&'/*.inc'));

autoDict:=begin
  local result:=flatten(pEach(file,allFiles,fileContents(file).tokenSplit('pascal')));
  result:=elementFrequency(result%(regex.matches(result,'^[a-zA-Z][a-zA-Z_]+')));
  result:=pEach(idsGroup,group(result,upper(result%%1)),
      idsGroup.size>1
      ? [upper(idsGroup%0%1),idsGroup%argMax(idsGroup%%0)%1]
      : void);
end;

checkConsistency(fileList)->begin
  local allTokens:=flatten(pEach(file,fileList,fileContents(file).tokenSplit('pascal')));
  print('Collected ',size(allTokens),' tokens');
  local allIds     :=allTokens%(regex.matches(allTokens,'^[a-zA-Z][a-zA-Z_]+'));
  print('Filtered ',size(allIds),' identifiers and keywords');
  local allLiterals:=allTokens%(regex.matches(allTokens,"^['0-9]"));
  print('Filtered ',size(allLiterals),' literals');
  allIds:=elementFrequency(allIds);
  
  local anyComplaints:=false;
  each(idsGroup,group(allIds,upper(allIds%%1)),
    idsGroup.size>1
    ? begin
        anyComplaints:=true;
        print('Inconsistent spelling: ',idsGroup.sort);
      end
    : void);

  not(anyComplaints) ? print('Spelling is consistent.') : void;
  allLiterals:=pEach(fp,allLiterals.elementFrequency,begin
                       local s:=significance@fp;
                       s>0 ? (-s)|fp
                           : void;
                     end).sort.head(20);
  print('Most significant literals: ');
  printf("%s\t%s\t%s",-(allLiterals%%0),allLiterals%%1,allLiterals%%2);
  void;
end; 

private pattern:='checkstyle: %-'&max(length(allFiles))&'s (%4d lines) ';

fix(filename,readOnly)->readOnly OR fileMustBeChecked(filename) ? begin
  local oldLines:=fileLines(filename);
  local newLines:=fixFileLines(oldLines);
  local diffOut:=format(pattern,filename,size(oldLines));
  oldLines==newLines ? diffOut&=' ok' : begin
    readOnly ? diffOut&=' NOT OKAY:' : diffOut&=' FIXED:';
    diffOut|=each(i,[0..size(newLines)-1],oldLines%i<>newLines%i ? '   <'&(oldLines%i)&">\n   >"&(newLines%i)&'<' : void);
    readOnly ? void : writeFileLines(filename,newLines);
  end;
  readOnly ? void : fileWasChecked(filename);
  printf('%s',diffOut);
end : void;

//*Check all files, writing out potential fixes
main("check")->begin
  pEach(s,allFiles,fix(s,true));
  print('Checking spelling consistency in MNH sources');
  checkConsistency(allFiles);
end;

//*Fix all files, writing out fixes
main("fix")->pEach(s,allFiles,fix(s,false));
