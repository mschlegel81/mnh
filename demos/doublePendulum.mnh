USE rungeKutta,GUI;
private mutable l1:=1;
private mutable l2:=1;
private mutable m1:=1;
private mutable m2:=1;
private g:=9.81;
private mutable F1fak:=-m2/(m1+m2)*l2/l1;
private mutable F2fak:=-l1/l2;

private initialize(l1_,l2_,m1_,m2_)->begin
  l1:=l1_.toReal;
  l2:=l2_.toReal;
  m1:=m1_.toReal;
  m2:=m2_.toReal;
  F1fak:=-m2/(m1+m2)*l2/l1;
  F2fak:=-l1/l2;
  void;
end;


//*phi1'', dependent on phi2''
F1(phi1,phi2,phi1dt,phi2dt,        phi2dtt)->F1fak*(phi2dtt*cos(phi1-phi2)+phi2dt.sqr*sin(phi1-phi2))-g/l1*sin(phi1);
//*phi2'', dependent on phi1''
F2(phi1,phi2,phi1dt,phi2dt,phi1dtt        )->F2fak*(phi1dtt*cos(phi1-phi2)-phi1dt.sqr*sin(phi1-phi2))-g/l2*sin(phi2);
//*Returns an expression F1(F2($x))-$x (for Regula Falsi)
F12(phi1,phi2,phi1dt,phi2dt)->F1(phi1,phi2,phi1dt,phi2dt,F2(phi1,phi2,phi1dt,phi2dt,{$x}))-{$x};

//*Overloaded for use in RK4
accel(state:numericList(4))->accel@state;

quickRoot(F:expression)->begin -1-(local f1:=F(-1))*2/(F(1)-f1); end;

//*Returns first derivative in time for given state
accel(phi1,phi2,phi1dt,phi2dt)->
  begin
    [phi1dt,
     phi2dt,
     local phi1dtt:=quickRoot(F12(phi1,phi2,phi1dt,phi2dt)),
     F2(phi1,phi2,phi1dt,phi2dt,phi1dtt)];
  end;

//*Transforms the state (by angles) to a list of points (Cartesian, 2D)
plottable(state:numericList(4))->begin
  [[0,0],local d1:=[sin(state[0]),-cos(state[0])]*l1,
               d1+ [sin(state[1]),-cos(state[1])]*l2];
end;

private secondsPreFrame:=1/40;
//*Animates a double pendulum with standard parameters (l1=l2=m1=m2=1)
//*The animation will consist of two double pendulums with a tiny variation in the starting conditions
main->begin
  setOptions([['autoscaleX',false],['autoscaleY',false],['x0',0],['x1',0],['y0',0],['y1',0]]);
  local state1:=[pi/2,pi/4,0,0];
  local state2:=state1+(random(4)-0.5)*1E-6;
  local trace1:=[state1.plottable.trailing];
  local trace2:=[state2.plottable.trailing];
  local p1:=state1.plottable;
  local p2:=state2.plottable;
  local replot:={begin
                   trace1:=trace1.trailing(100)|[p1.trailing];
                   trace2:=trace2.trailing(100)|[p2.trailing];
                   setOptions([['x0',min(getOptions['x0'],min(p1.getInner(0)),min(p2.getInner(0)))],
                               ['x1',max(getOptions['x1'],max(p1.getInner(0)),max(p2.getInner(0)))],
                               ['y0',min(getOptions['y0'],min(p1.getInner(1)),min(p2.getInner(1)))],
                               ['y1',max(getOptions['y1'],max(p1.getInner(1)),max(p2.getInner(1)))]]);
                   plot   (trace2,'red');
                   addPlot(trace1,'black');
                   addPlot(p2,'3 . red l');
                   addPlot(p1,'3 . black l');
                   display;
                 end};
  replot();
  local step:=integrator(CASH_KARP,::accel,0.02,1E-4);
  local frameTime:=time;
  state1:=async(step,[state1]);
  state2:=async(step,[state2]);
  while(not(plotClosed),begin
    sleepUntil(frameTime+=secondsPreFrame);
    frameTime:=time;
    p1:=(state1:=state1()).plottable; state1:=async(step,[state1]);
    p2:=(state2:=state2()).plottable; state2:=async(step,[state2]);
    replot();
  end);
end;

//*Animates a double pendulum with custom parameters
//*Note that smaller lengths lead to faster pendulums
//*but only the ratio of the lenghts changes the behavior qualitatively
main(L1,L2,M1,M2)->initialize@$params orElse main;
