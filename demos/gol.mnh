type WorldSize(i:IntList(2))->i[0]>0<i[1];
//*Returns a random initial world
private initWorld(s:WorldSize)->intRandom(2,s.agg(*));

//*Prints out the given world (including a clearprint)
private curry printWorld(s:WorldSize,w:IntList)->printf("%s","\f"|copy(join([' ','#'][w]),s[0]*[0..s[1]-1],s[0]));

private plotWorld(worldWidth:Int,world:IntList)->
begin
  indexOf(world=1).pEach(i,begin
    local o:=i.divMod(worldWidth);
    [o,o+1];
  end,|).plot('box');
  display;
end;

//*Shifts - this returns a list of intLists, indicating adjacent cells
private memoized shifts(s:WorldSize)->
  [-1..1].cross([-1..1]).each(sh,0=sh[0]=sh[1] ? void :
  (([0..s[1]-1]+sh[0]+s[1]) mod s[1]*s[0]).cross
  (([0..s[0]-1]+sh[1]+s[0]) mod s[0]     ).map({$x[0]+$x[1]}));


//*Returns a list of integers with the number of living neighbors per cell
private neighbors(w:IntList,s:WorldSize)->shifts(s).pEach(sh,w[sh],+);

//*The Transision table
private TRANSITION:=[0,0,0,1,0,0,0,0,0,
                     0,0,1,1,0,0,0,0,0];

//*Computes the following generation based on current generation w
private step(w:IntList,s:WorldSize)->TRANSITION[w.neighbors(s)+9*w];

private playTheGame(S:WorldSize,delaySeconds:Numeric,stepLimit:Int,exitByKey=false,outputMethod:Expression(1))->
  begin
    local W:=initWorld(S);
    local stepCounter:=0;
    while(stepCounter<=stepLimit,begin
      stepCounter+=1;
      outputMethod(W);
      W:=W.step(S);
      sleep(delaySeconds);
    end);
  end;

private playTheGame(S:WorldSize,delaySeconds:Numeric,stepLimit:Int,exitByKey=true,outputMethod:Expression(1))->
  begin
    async({playTheGame(S,delaySeconds,stepLimit,false,outputMethod)});
    ask('Press enter to quit');
  end;

//*Conway's Game Of Life
//*Play the game in the given resolution until a key is pressed
@demo_for=animation
main(width,height)->begin
  local worldSize:=[width.toInt,height.toInt].toWorldSize;
  playTheGame(worldSize,0.05,2^62,true,printWorld(worldSize));
end;

main(width,height,'graphic')->begin
  local worldSize:=[width.toInt,height.toInt].toWorldSize;
  [['autoscaleX',false],
   ['autoscaleY',false],
   ['axisStyleX',0],
   ['axisStyleY',0],
   ['logscaleX',false],
   ['logscaleY',false],
   ['preserveAspect',true],
   ['x0',0],
   ['x1',worldSize[0]+1],
   ['y0',0],
   ['y1',worldSize[1]+1]].toMap.setOptions;
  playTheGame(worldSize,0.05,2^62,true,plotWorld(worldSize[0]));
end;

//*Play the game for the given number of steps
main(width,height,stepCount)->begin
  local worldSize:=[width.toInt,height.toInt].toWorldSize;
  playTheGame(worldSize,0.05,stepCount.toInt,false,printWorld(worldSize));
end;

//*Play the game for the given number of steps without delay between generations
main(width,height,stepCount,"fast")->begin
  local worldSize:=[width.toInt,height.toInt].toWorldSize;
  playTheGame(worldSize,0,stepCount.toInt,false,printWorld(worldSize));
end;
