//for A000002:------------------------------------------------
private listOf(value,count=0)->[];
private listOf(value,count>=1)->[1..count].each(i,value);
private Kolakoski_1_2(len)->begin
  local K:=[1,2];
  while(K.size<len,
    K:=K.pEach(runLength,
               listOf((index and 1)+1,runLength),|));
  K.head(len);
end;

//for A000010:------------------------------------------------
private EulerPhi(n>1)->factorize(n).elementFrequency.each(p,p[0]^(p[1]-1)*(p[0]-1),*);
private EulerPhi(1)->1;

//for A000108:-------------------------------------------------
private Catalan(n<=1)->1;
private Catalan(n> 1)->(n+[2..n]).agg(*) div [2..n].agg(*);

//for A025426:-------------------------------------------------
private by2Squares(n>0)->begin
  local S:=[1..n.sqrt.floor]^2;
  (n-S).intersect(S).filter({n-$s<=$s}).map({round(sqrt(n-$s))&'^2+'&round(sqrt($s))&'^2'});
end;
private by2Squares(n=0):=[];

//for A061358:-------------------------------------------------
private by2Primes(n:Int)->begin
  local S:=primes(n);
  (n-S).intersect(S).filter({n-$s<=$s}).map({(n-$s)&'+'&$s});
end;

//for A000124:-------------------------------------------------
private LazyCaterer(n)->(n+n^2+2) div 2;

//for A000203:-------------------------------------------------
private DivisorFunction(1)->1;
private DivisorFunction(n:Int)->factorize(n).subSets.map({$0.agg(*) orElse 1}).agg(+);

//for A003459:-------------------------------------------------
private isPermutablePrime(p:Int)->(p.digits).permutations.each(d,d.composeDigits.factorize.size=1,AND);

private naturalNumbers(lowerBound:Int)->rangeGenerator(lowerBound,2^63-1);
//-------------------------------------------------------------
@SuppressUnusedWarning
A000002->listIterator(Kolakoski_1_2(10000));
@SuppressUnusedWarning
A000005->naturalNumbers(1).lazyMap({$n<=1 ? 1 : factorize($n).subSets.map({$x.agg(*)}).size+1});
@SuppressUnusedWarning
A000006->primeGenerator.sqrt.floor;
@SuppressUnusedWarning
A000007->ord(naturalNumbers(0)=0);
@SuppressUnusedWarning
A000010->naturalNumbers(1).lazyMap(::EulerPhi);
@SuppressUnusedWarning
A000027->naturalNumbers(1);
USE sequenceOfNonSquares;
@SuppressUnusedWarning
A000037->naturalNumbers(1).lazyMap(::nonSquares);
@SuppressUnusedWarning
A000040->primeGenerator;
@SuppressUnusedWarning
A000108->rangeGenerator(0,13).lazyMap(::Catalan);
@SuppressUnusedWarning
A000124->naturalNumbers(0).lazyMap(::LazyCaterer);
@SuppressUnusedWarning
A000203->naturalNumbers(1).lazyMap(::DivisorFunction);
USE semiprime;
@SuppressUnusedWarning
A001358->naturalNumbers(1).filter(::isSemiprime);
@SuppressUnusedWarning
A003459->listIterator(primes(991)).filter(::isPermutablePrime);
@SuppressUnusedWarning
A025426->naturalNumbers(0).lazyMap({size(by2Squares($i))});
@SuppressUnusedWarning
A061358->naturalNumbers(0).lazyMap({size(by2Primes($i))});
USE generators,ludic;
@SuppressUnusedWarning
A003309->listIterator(LudicSieve);
USE pernicousNumbers;
@SuppressUnusedWarning
A052294->naturalNumbers(1).filter(::isPernicious);
USE smithNumbers;
@SuppressUnusedWarning
A006753->naturalNumbers(1).filter(::isSmithNumber);
USE thueMorseSequence;
@SuppressUnusedWarning
A010060->listIterator(thueMorseSequence(10000).ord);
USE truncatablePrimes;
@SuppressUnusedWarning
A024785->listIterator(leftTruncatablePrimes (1000000));
@SuppressUnusedWarning
A024770->listIterator(rightTruncatablePrimes(1000000));
@SuppressUnusedWarning
A020994->listIterator(leftTruncatablePrimes (1000000).intersect(rightTruncatablePrimes(1000000)).sort);
USE hofstadter_sequences;
@SuppressUnusedWarning
@class=Hofstaedter
A005228->naturalNumbers(1).lazyMap(::hofstadter_sequences.R);
@SuppressUnusedWarning
@class=Hofstaedter
A030124->naturalNumbers(1).lazyMap(::hofstadter_sequences.S);
@SuppressUnusedWarning
@class=Hofstaedter
A005206->naturalNumbers(0).lazyMap(::hofstadter_sequences.G);
@SuppressUnusedWarning
@class=Hofstaedter
A005374->naturalNumbers(0).lazyMap(::hofstadter_sequences.H);
@SuppressUnusedWarning
@class=Hofstaedter
A005378->naturalNumbers(0).lazyMap(::hofstadter_sequences.F);
@SuppressUnusedWarning
@class=Hofstaedter
A005379->naturalNumbers(0).lazyMap(::hofstadter_sequences.M);
@SuppressUnusedWarning
@class=Hofstaedter
A005185->naturalNumbers(1).lazyMap(::hofstadter_sequences.Q);
@SuppressUnusedWarning
@class=Hofstaedter
A007947->naturalNumbers(1).lazyMap({$n.factorize.unique.agg(*)});

USE countTheCoins;
@SuppressUnusedWarning
@class=Partition number
A000041->naturalNumbers(0).lazyMap({countPartitions($i,[1..$i])});
@SuppressUnusedWarning
@class=Partition number
A001156->naturalNumbers(0).lazyMap({countPartitions($i,[1..ceil($i^(1/2))]^2)});
@SuppressUnusedWarning
@class=Partition number
A003108->naturalNumbers(0).lazyMap({countPartitions($i,[1..ceil($i^(1/3))]^3)});
@SuppressUnusedWarning
@class=Partition number
A018819->naturalNumbers(0).lazyMap({countPartitions($i,2^[0..20])});
@SuppressUnusedWarning
@class=Partition number
A062051->naturalNumbers(0).lazyMap({countPartitions($i,3^[0..20])});
@SuppressUnusedWarning
@class=Partition number
A001996->naturalNumbers(0).lazyMap({countPartitions($i,[2, 3, 4, 5, 6, 7])});
@SuppressUnusedWarning
@class=Partition number
A000607->naturalNumbers(0).lazyMap({$i=0?1:countPartitions($i,primes($i))});
@SuppressUnusedWarning
@class=Partition number
A002095->naturalNumbers(0).lazyMap({countPartitions($i,[1..$i].minus(primes($i)))});
@SuppressUnusedWarning
@class=Partition number
A000008->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 5, 10])});
@SuppressUnusedWarning
@class=Partition number
A001299->naturalNumbers(0).lazyMap({countPartitions($i,[1, 5, 10, 25])});
@SuppressUnusedWarning
@class=Partition number
A001300->naturalNumbers(0).lazyMap({countPartitions($i,[1, 5, 10, 25, 50])});
@SuppressUnusedWarning
@class=Partition number
A001301->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 5, 10, 25])});
@SuppressUnusedWarning
@class=Partition number
A001302->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 5, 10, 25, 50])});
@SuppressUnusedWarning
@class=Partition number
A001306->naturalNumbers(0).lazyMap({countPartitions($i,[1, 5, 10, 20, 50, 100])});
@SuppressUnusedWarning
@class=Partition number
A001310->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 4, 10, 20, 40, 100])});
@SuppressUnusedWarning
@class=Partition number
A001312->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 5, 10, 50, 100])});
@SuppressUnusedWarning
@class=Partition number
A001313->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 5, 10, 20, 50])});
@SuppressUnusedWarning
@class=Partition number
A001362->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 4, 10])});
@SuppressUnusedWarning
@class=Partition number
A001364->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 4, 12, 24, 48, 96, 120])});
@SuppressUnusedWarning
@class=Partition number
A067996->naturalNumbers(0).lazyMap({countPartitions($i,[1, 2, 3, 5, 10, 20, 25, 50, 100])});
@SuppressUnusedWarning
@class=Partition number
A169718->naturalNumbers(0).lazyMap({countPartitions($i,[1, 5, 10, 25, 50, 100])});
@SuppressUnusedWarning
@class=Partition number
A187243->naturalNumbers(0).lazyMap({countPartitions($i,[1, 5, 10])});

USE vampire;
@SuppressUnusedWarning
A014575->naturalNumbers(1260).filter(::isVampire);

@SuppressUnusedWarning
@class=by Hamming weight
A018900->naturalNumbers(0).filter({$x.hammingWeight=2});
@SuppressUnusedWarning
@class=by Hamming weight
A014311->naturalNumbers(0).filter({$x.hammingWeight=3});
@SuppressUnusedWarning
@class=by Hamming weight
A014312->naturalNumbers(0).filter({$x.hammingWeight=4});
@SuppressUnusedWarning
@class=by Hamming weight
A014313->naturalNumbers(0).filter({$x.hammingWeight=5});
@SuppressUnusedWarning
@class=by Hamming weight
A023688->naturalNumbers(0).filter({$x.hammingWeight=6});
@SuppressUnusedWarning
@class=by Hamming weight
A023689->naturalNumbers(0).filter({$x.hammingWeight=7});
@SuppressUnusedWarning
@class=by Hamming weight
A023690->naturalNumbers(0).filter({$x.hammingWeight=8});
@SuppressUnusedWarning
@class=by Hamming weight
A023691->naturalNumbers(0).filter({$x.hammingWeight=9});

USE multifactorial;
@SuppressUnusedWarning
@class=Multifactorial
A000142->multifactorialGenerator(1);
@SuppressUnusedWarning
@class=Multifactorial
A006882->multifactorialGenerator(2);
@SuppressUnusedWarning
@class=Multifactorial
A007661->multifactorialGenerator(3);
@SuppressUnusedWarning
@class=Multifactorial
A007662->multifactorialGenerator(4);
@SuppressUnusedWarning
@class=Multifactorial
A085157->multifactorialGenerator(5);
@SuppressUnusedWarning
@class=Multifactorial
A085158->multifactorialGenerator(6);
@SuppressUnusedWarning
@class=Multifactorial
A114799->multifactorialGenerator(7);
@SuppressUnusedWarning
@class=Multifactorial
A114800->multifactorialGenerator(8);
@SuppressUnusedWarning
@class=Multifactorial
A114806->multifactorialGenerator(9);
@SuppressUnusedWarning
@class=Multifactorial
A288327->multifactorialGenerator(10);

USE pascal;
@SuppressUnusedWarning
@class=Pascal triangle row
A010926->pascalTriangleRow(10).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010927->pascalTriangleRow(11).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010928->pascalTriangleRow(12).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010929->pascalTriangleRow(13).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010930->pascalTriangleRow(14).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010931->pascalTriangleRow(15).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010932->pascalTriangleRow(16).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010933->pascalTriangleRow(17).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010934->pascalTriangleRow(18).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010935->pascalTriangleRow(19).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010936->pascalTriangleRow(20).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010937->pascalTriangleRow(21).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010938->pascalTriangleRow(22).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010939->pascalTriangleRow(23).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010940->pascalTriangleRow(24).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010941->pascalTriangleRow(25).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010942->pascalTriangleRow(26).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010943->pascalTriangleRow(27).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010944->pascalTriangleRow(28).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010945->pascalTriangleRow(29).listIterator;
@SuppressUnusedWarning
@class=Pascal triangle row
A010946->pascalTriangleRow(30).listIterator;

USE perfectPowers;
@SuppressUnusedWarning
A001597->perfectPowers(10^6).listIterator;

USE sternBrocot;
@SuppressUnusedWarning
A002487->sternBrocotGenerator;

USE hofstadterConway;
@SuppressUnusedWarning
A004001->hofstaderConwayGen;

USE hamming;
@SuppressUnusedWarning
A051037->hammingGenerator;

USE harshad;
@SuppressUnusedWarning
A005349->naturalNumbers(1).filter(::isHarshadNumber);

USE kaprekar;
@SuppressUnusedWarning
A006886->naturalNumbers(1).filter(::isKaprekar);

scanFiboMod(stepsBack in [2..5],modulus>=1)->begin
  local fiboMod:={$state.tail|($state.agg(+) mod modulus)};
  local openStates:=cross([0..modulus-1],[0..modulus-1],
                          stepsBack>=3 ? [0..modulus-1] : void,
                          stepsBack>=4 ? [0..modulus-1] : void,
                          stepsBack>=5 ? [0..modulus-1] : void).toSet;
  local groupCount:=0;
  while(openStates.size>0,begin
    openStates>>(local s:=openStates.min);
    while((s:=fiboMod(s)) in openStates,openStates>>s);
    groupCount+=1;
  end);
  groupCount;
end;

@SuppressUnusedWarning
@class=Fibonacci sequence modulo
A015134->naturalNumbers(1).lazyMap({scanFiboMod(2,$n)});
@SuppressUnusedWarning
@class=Fibonacci sequence modulo
A106285->naturalNumbers(1).lazyMap({scanFiboMod(3,$n)});
@SuppressUnusedWarning
@class=Fibonacci sequence modulo
A106286->naturalNumbers(1).lazyMap({scanFiboMod(4,$n)});
@SuppressUnusedWarning
@class=Fibonacci sequence modulo
A106287->naturalNumbers(1).lazyMap({scanFiboMod(5,$n)});

private coprimesLesser(n)->begin
  local result:=[2..n-1];
  factorize(n).unique.each(factor,
    result:=result[result mod factor!=0]);
  result;
end;

private curry isKnoedel(n,m)->!isPrime(m) AND coprimesLesser(m).pEach(i,powMod(i,m-n,m)=1,AND);

@SuppressUnusedWarning
@class=Knödel
rangeGenerator( 2,2^60).filter(isKnoedel(1));
@SuppressUnusedWarning
@class=Knödel
A050990->rangeGenerator( 3,2^60).filter(isKnoedel(2));
@SuppressUnusedWarning
@class=Knödel
A033553->rangeGenerator( 4,2^60).filter(isKnoedel(3));
@SuppressUnusedWarning
@class=Knödel
A050992->rangeGenerator( 5,2^60).filter(isKnoedel(4));
@SuppressUnusedWarning
@class=Knödel
A050993->rangeGenerator( 6,2^60).filter(isKnoedel(5));
@SuppressUnusedWarning
@class=Knödel
A208154->rangeGenerator( 7,2^60).filter(isKnoedel(6));
@SuppressUnusedWarning
@class=Knödel
A208155->rangeGenerator( 8,2^60).filter(isKnoedel(7));
@SuppressUnusedWarning
@class=Knödel
A208156->rangeGenerator( 9,2^60).filter(isKnoedel(8));
@SuppressUnusedWarning
@class=Knödel
A208157->rangeGenerator(10,2^60).filter(isKnoedel(9));
@SuppressUnusedWarning
@class=Knödel
A208158->rangeGenerator(11,2^60).filter(isKnoedel(10));
@SuppressUnusedWarning
@class=Knödel
A225506->rangeGenerator(2,2^60).filter(isKnoedel(-2));
@SuppressUnusedWarning
@class=Knödel
A225507->rangeGenerator(2,2^60).filter(isKnoedel(-3));
@SuppressUnusedWarning
@class=Knödel
A225508->rangeGenerator(2,2^60).filter(isKnoedel(-4));
@SuppressUnusedWarning
@class=Knödel
A225509->rangeGenerator(2,2^60).filter(isKnoedel(-5));
@SuppressUnusedWarning
@class=Knödel
A225514->rangeGenerator(2,2^60).filter(isKnoedel(-10));

@SuppressUnusedWarning
memoized implemented->
  inspect['declares']
  .filter({$x[0].matches('^A\d{6}$')})
  .map({[$x[0].copy(1,6).softCast,[$x[1,'function'],$x[1,'subrules',0,'attributes','class'] orElse 'custom implementation']]})
  .toMap;

private findPolyParam(sequence:IntList)->sequence.size<6 ? void : begin
  local c:=sequence[0];
  local a:=(sequence[2]-sequence[0]) div 2-sequence[1]+sequence[0];
  local b:=sequence[1]-c-a;
  local n:=[0..sequence.size-1];
  a*n^2+b*n+c==sequence
  ? begin
      local upperBound:=a=0
            ? b=0
              ? 2^63-1
              : floor((2^63.0-1.0-c)/b)
            : [floor((-b+[-1,1]*sqrt(b^2-4*a*(c-2.0^63+1.0)))/(2*a)),
               floor((-b+[-1,1]*sqrt(b^2-4*a*(c+2.0^63-1.0)))/(2*a))].flatten.max;
      upperBound<0 ? void :
      [format('rangeGenerator(0,%s).lazyMap({%s%s%s})',
            upperBound,
            a=0 ? '' : a&'*$x^2+',
            b=0 ? '' : b&'*$x+',
            c),'polynomial'];
    end
  : void;
end;

generalizedFibonacci(state:IntList)->{begin
  local L:=state;
save;
  local result:=L[0];
  L:=L.tail|L.agg(+);
  result<0 ? void : result;
end};

private findFibonacciParam(sequence:IntList)->sequence.size<4 ? void : begin
  [2..min(16,sequence.size div 2)].each(k,
    generalizedFibonacci(sequence.head(k)).head(sequence.size)==sequence
    ? [format('generalizedFibonacci(%s)',sequence.head(k).toString),'generalized Fibonacci sequence']
    : void,head);
end;

private findPowerParam(sequence:IntList)->sequence.size<10 ? void : begin
  //zero based index
  local base:=(ln(sequence)/ln([0..sequence.size-1])).filter({!isNan($x) AND !isInfinite($x)});
  base:=(base.agg(+)/base.size);
  sequence==          round([0..sequence.size-1]^base)
  ? return [format(sequence==[0..sequence.size-1]^round(base)
           ?       'rangeGenerator(0,%s)^%{round($1)}s'
           : 'round(rangeGenerator(0,%s)^%s)',floor((2.0^63-1.0)^(1/base)),base),'power series']
  : void;

  //one based index
  base:=(ln(sequence)/ln([1..sequence.size])).filter({!isNan($x) AND !isInfinite($x)});
  base:=(base.agg(+)/base.size);
  sequence==          round([1..sequence.size]^base)
  ? return [format(sequence==[1..sequence.size]^round(base)
           ?       'rangeGenerator(1,%s)^%{round($1)}s'
           : 'round(rangeGenerator(1,%s)^%s)',floor((2.0^63-1.0)^(1/base)),base),'power series']
  : void;

  //zero based index
  base:=(ln(sequence)/[0..sequence.size-1]).filter({!isNan($x) AND !isInfinite($x)});
  base:=base.exp.sort[base.size div 2];

  sequence==                round(base^ [0..sequence.size-1])
  ? return [format(sequence==round(base)^[0..sequence.size-1]
           ? '%{round($0)}s^rangeGenerator(0,%s)'
           : 'round(%s^rangeGenerator(0,%s))',base,floor(ln(2.0^63-1.0)/ln(base))),'exponential series']
  : void;

  //one based index
  base:=(ln(sequence)/[1..sequence.size]).filter({!isNan($x) AND !isInfinite($x)});
  base:=base.exp.sort[base.size div 2];

  sequence==                round(base^ [1..sequence.size])
  ? return [format(sequence==round(base)^[1..sequence.size-1]
           ? '%{round($0)}s^rangeGenerator(1,%s)'
           : 'round(%s^rangeGenerator(1,%s))',base,floor(ln(2.0^63-1.0)/ln(base))),'exponential series']
  : void;
end;

findPeriodicParam(L:IntList)->L.size<10 ? void :
  indexOf(L[0]=L).filter({1<$x<=L.size div 2}).each(shift,
    L.tail(shift)==L.leading(shift)
    ? ["rangeGenerator(0,"&(2^63-1)&").lazyMap({"&L.head(shift).toString&'[$i mod '&shift&']})','periodic series']
    : void,orElse);

@SuppressUnusedWarning
guessImplementation([])->void;
guessImplementation(sequence:IntList)->
  findPolyParam(sequence) orElse
  findPowerParam(sequence) orElse
  findPeriodicParam(sequence) orElse
  findFibonacciParam(sequence);
