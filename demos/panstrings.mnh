private memoized next(prev:Int,partMask:Int)->(prev.shiftRight(-1) and partMask)+[0,1];

//*Returns a\[b]
private without(a:Set,b:Int)->a.minus([b]);

private unfailed(L:IntList)->L;
private unfailed(L:Int)->L;
private unfailed(L)->void;

//*Successful terminator - nothing more to visit
private construct(partMask, prev:Int,[].toSet)->void;

//*Recursively constructs the shortest string starting with prev and containg all strings in rest
private construct(partMask, prev:Int,rest:IntSet)->
  prev.next(partMask)
      .intersect(rest) //all possible continuations
      .each(N,
       unfailed( (N and 1) | construct(partMask,N,rest.without(N))),
         orElse) orElse "FAIL"; //take first unfailed result or return fail-marker

//*Constructs one shortest string, containing all binary strings of length partLength
construct(partLength>=1)->begin
  local all:=[0..2^partLength-1];
  ([1..partLength]*0)|construct(2^partLength-1,all.head,all.tail.toSet);
end;

@demo_for=bitwise, recursion
main->[1..7].each(i,print(construct(i).join));
