//Solves the "Queens puzzle"
//Queens are represented as lists of integers where the position in
//the list indicates the row and the value represents the column

//*Always true (one Queen only)
isValid(L:list,n=0)->true;
//*For n+1 Queens, test Queens [n-1..0] if they threaten Queen [n]
isValid(L:list,n>0)->[n-1..0].each(k,abs(L[n]-L[k])-1!=index,AND);

//*No candiates left: return H
queens(H:intList,[])->[H];
//*Try to elongate H by each element in C, testing if it is valid. Recurse.
queens(H:intList,C:intList)->C.pEach(c,isValid(H|c,size(H))
                                       ? queens(H|c,C.minus([c]))
                                       : void,|);
queens(numberOfQueens>1)->queens([],[1..numberOfQueens]) orElse [];

fmtSolution(solution:intList)->solution.each(k,['A'..'Z'][index],k,' ',&);

inform(numberOfQueens:int,allSolutions:boolean)->begin
  local solutions:=queens(numberOfQueens);
  print('The ',numberOfQueens,'-queens puzzle has ',solutions.size,' solutions');
  allSolutions
  ? solutions.each(s,print('  ',fmtSolution(s)))
  : solutions.size>0
    ? print('  e.g. ',fmtSolution(solutions.head))
    : void;
end;

//*Print out the solutions for the queens puzzle
main(numberOfQueens)->inform(numberOfQueens.toInt,true);

//*Print out the numbers of solutions for the 2..8 queens puzzle
main->[2..8].each(q,inform(q,false));
