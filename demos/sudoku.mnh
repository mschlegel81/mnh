//Create a riddle with everything possible, i.e. every cell has possible values [1..9] apart from the diagonal
private allPossible->each(i,[0..8],each(j,[0..8],i=j ? j+1 : [1..9]));

private touching(i0,j0,i1,j1)->i0=i1 ? true :
                               j0=j1 ? true :
                               (i0 div 3) = (i1 div 3) and (j0 div 3) = (j1 div 3);

//drop: remove an entry (=value) from an integer set (=set)
private drop(set:intList,value)->set%(set!=value);
private drop(set:int,value)->set;
private drop([],value)->[];
//Random in [0..8]
private rand8->floor(random*9);
//Random element from given list:
private randomFrom(set:intList)->set%floor(random*(size(set)-1));
//Set a number in the sudoku and solve it
private setNumber(Board,iRow,jCol,value)->(each(i,[0..8],each(j,[0..8],i=iRow and j=jCol ? value : Board%i%j)));
private blacklist(Board)->blacklist(each(i,[0..8],flatten(each(j,[0..8],(Board%i%j):int ? Board%i%j : []))),
                                    each(j,[0..8],flatten(each(i,[0..8],(Board%i%j):int ? Board%i%j : []))),
                                    each(b,[[0,0],[0,3],[0,6],
                                            [3,0],[3,3],[3,6],
                                            [6,0],[6,3],[6,6]],flatten(each(i,b%0+[0..2],each(j,b%1+[0..2],(Board%i%j):int ? Board%i%j : [])))));

private blacklist(FI,FJ,FB)->each(i,[0..8],each(j,[0..8],unique((FI%i)|(FJ%j)|(FB%(3*(i div 3)+(j div 3))))));
private oneElementListToScalar(L:int)->int;
private oneElementListToScalar(L)->size(L)=1 ? L%0 : L;
private solve(Board)->solve(Board,blacklist(Board));
private solve(B,F)->solve_retry(B,each(i,[0..8],each(j,[0..8],(B%i%j):int ? B%i%j : oneElementListToScalar(flatten(each(x,B%i%j,x in F%i%j ? [] : x))))));
private solve_retry(oldBoard,newBoard==oldBoard)->newBoard;
private solve_retry(oldBoard,newBoard)->solve(newBoard);

//Set a random cell in the Board to one of the possible values
private setRandom(Board)->setRandom(Board,rand8,rand8);
private setRandom(Board,iRow,jCol)->(Board%iRow%jCol):intList ? setNumber(Board,iRow,jCol,randomFrom(Board%iRow%jCol)) : setRandom(Board);
//Un-set a random cell in the Board
private unsetRandom(Board)->unsetRandom(Board,rand8,rand8);
private unsetRandom(Board,iRow,jCol)->(Board%iRow%jCol):int ? each(i,[0..8],each(j,[0..8],i=iRow and j=jCol ? [1..9] : Board%i%j)) : unsetRandom(Board);

//Is the Board valid (no conflicts?)
private isValid (Board)->each(row,Board,and,each(cell,row,and,size(cell)>=1));
//Is the Board solved? 
private isSolved(Board)->each(row,Board,and,each(cell,row,and,     cell:int));
//Is the Board solvable? 
private canSolve(Board)->isSolved(solve(each(row,Board,each(cell,row,cell:int ? [cell] : cell))));

//Construct a solution by randomly restricting cells
private restrict(Board)->restrict(Board,isValid(Board),isSolved(Board));
private restrict(Board,true ,false)->restrict(solve(setRandom(Board)));
private restrict(Board,true ,true )->Board;
private restrict(Board,false,o    )->restrict(allPossible);
//Construct a riddle from a solution by randomly un-setting cells and testing for solveability
private riddleFromSolution(Board,retries)->riddleFromSolution(Board,unsetRandom(Board),retries);
private riddleFromSolution(prevBoard,Board,retries         )->riddleFromSolution(prevBoard,Board,retries,canSolve(Board));
private riddleFromSolution(prevBoard,Board,retries   ,true )->riddleFromSolution(Board,unsetRandom(Board),retries);
private riddleFromSolution(prevBoard,Board,retries<=0,false)->prevBoard;
private riddleFromSolution(prevBoard,Board,retries   ,false)->riddleFromSolution(prevBoard,unsetRandom(prevBoard),retries-1);
//Pretty-print a board:
private printSudoku(Board)->print('=========#=========#=========') and
                            print(each(i,[0..8],&"\n"&,
                                  each(j,[0..8],&, replace(" "&string(Board%i%j)&" "," [1,2,3,4,5,6,7,8,9] ","   ") & (j in [2,5] ? "|" : "")) &
                                  (i in [2,5] ? "\n---------+---------+---------":""))) and
                            print('=========#=========#=========\n');

//For creation of lazy sudoku constants:=========================================================
short(Board)->replace(string(Board-1),["[0,1,2,3,4,5,6,7,8]","[","]",",","99","AA","BB"],["9","","","","A","B","C"]);
printShort(Board)->print(short(Board));
difficulty(Board)->trueCount(flatten(each(row,Board,each(cell,row,cell:intList))));
findDifficultRiddle(Board)->findDifficultRiddle(Board,riddleFromSolution(Board,0),0);
findDifficultRiddle(Board,Riddle,maxDifficulty)->findDifficultRiddle(Board,Riddle,maxDifficulty,difficulty(Riddle));
findDifficultRiddle(Board,Riddle,maxDifficulty,thisDifficulty> maxDifficulty)->print('Difficulty: ',thisDifficulty) and printSudoku(Riddle) and printShort(Riddle) ?
                                                                               findDifficultRiddle(Board,riddleFromSolution(Board,3*thisDifficulty),thisDifficulty) : 0;
findDifficultRiddle(Board,Riddle,maxDifficulty,thisDifficulty<=maxDifficulty)->findDifficultRiddle(Board,riddleFromSolution(Board,3*maxDifficulty),maxDifficulty );
//=========================================================:For creation of lazy sudoku constants

//*Writes out a Sodoku (Solution and solveable Riddle)
main->print('Call with parameter "findHardOne" to stubbornly look for harder riddles.') and  main_(restrict(allPossible));
private main_(B)->printSudoku(B) and 
                  printSudoku(riddleFromSolution(B,10));
//*Looks for a hard riddle - WARNING: This is an endless loop!
main("findHardOne")->print('********************************************************\n',
                           '* This is an endless loop. Abort program using Ctrl+C. *\n',
                           '********************************************************\n') and findDifficultRiddle(restrict(allPossible));
main("findMany")->print('********************************************************\n',
                        '* This is an endless loop. Abort program using Ctrl+C. *\n',
                        '********************************************************\n') and
                  main_many;
main_many->main_many(pEach(i,[0..9],riddleFromSolution(restrict(allPossible),200)));
main_many(Riddles)->each(R,Riddles,and,print('Difficulty ',difficulty(R),'; ',short(R))) ? main_many : main_many;
