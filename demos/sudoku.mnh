private drop(list:intList,toDrop:int)->list[list!=toDrop];
private drop(list:intList,toDrop:intList)->list.minus(toDrop);

private
COMPONENTS:=[0..8].each(i,i+[0..8]*9)|
            [0..8].each(i,i*9+[0..8])|
            [0..8].each(i,[0..80].get(i=([0..80] div 27)*3+[0..80] mod 9 div 3));

private memoized connectedIdx(i:int)->COMPONENTS.each(c,i in c ? drop(c,i) : void).flatten.sort;
private memoized components(i)->COMPONENTS.each(c,i in c ? drop(c,i) : void);

//*A board is solved when all components contain numbers [1..9]
private isSolved(Board)->COMPONENTS.each(c,Board[c].sort==[1..9],AND);
//*A board is valid when all components may contain all numbers [1..9]
private isValid(Board)->Board.each(cell,not(cell==[]),AND) AND
                        COMPONENTS.each(c,Board[c].flatten.unique==[1..9],AND);
//*A board's difficulty is given by the number of cells to fill
private difficulty(Board)->Board.each(cell,cell:int ? 0 : 1,+);

private
initialBoard->begin
  local values:=1+random(9).sortPerm;
  local indexes:=[0..8]*9+random(9).sortPerm;
  [0..80].each(i,i in indexes ? values[indexes=i,0] : [1..9]);
end;

private
printBoard(B)->[0..8].each(row,print(row in [3,6] ? "---------+---------+---------\n" : '',
               [0..8].each(col,begin
                 local i:=col+9*row;
                 (col in [3,6] ? '|' : '')&
                 " "&(B[i] :int ? B[i] : " ")&" ";
               end,&)))|B;

private
solve(B)->begin
  local needRun:=isValid(B);
  local Board:=B;
  while(needRun,
  begin
    needRun:=false;
    local intsOnly:=Board.each(c,c:int ? c : []);
    Board:=[0..80].each(i,
      Board[i]:int
      ? Board[i]
      : begin
          local newList:=drop(Board[i],intsOnly[connectedIdx(i)].flatten);
          size(newList)=1
          ? begin
              needRun:=true;
              newList[0];
            end
          : begin
              local tmp:=drop(Board[i],flatten(Board.get(components(i)[0])));
              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : begin
              tmp:=drop(Board[i],Board.get(components(i)[1]).flatten);
              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : begin
              tmp:=drop(Board.get(i),Board.get(components(i)[2]).flatten);
              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : newList; end; end;
            end;
        end);
  end);
  Board;
end;

private
bruteForceSolve(B)->begin
  local Board:=solve(B);
  isSolved(Board) ? Board : begin
    local firstListIdx:=min(81|each(i,[0..80],Board[i]:int ? void : i));
    local candidates:=Board[firstListIdx];
    local numberOfSolutions:=0;
    local finalSolution:=void;
    each(candidate,candidates,numberOfSolutions>1 ? void : begin
      local newSolution:=bruteForceSolve(each(i,[0..80],i=firstListIdx ? candidate : Board[i]));
      isSolved(newSolution)
      ? begin
          finalSolution:=newSolution;
          numberOfSolutions+=1;
        end
      : void;
    end);
    numberOfSolutions=1 ? finalSolution : initialBoard;
  end;
end;

private restrictRandom(B)->begin
  local listIndexes:=[0..80].each(i,B[i]:int ? void : i);
  listIndexes==[] ? B : begin
    local randomListIdx:=listIndexes[intRandom(size(listIndexes))];
    [0..80].each(i,i=randomListIdx ? B[i,intRandom(size(B.get(i)))] : B[i]);
  end;
end;

randomSolution->begin
  local foundSolution:=false;
  local Board:=void;
  while(not(foundSolution),begin
    Board:=initialBoard.restrictRandom.solve;
    while(isValid(Board) AND not(Board.isSolved),Board:=Board.restrictRandom.solve);
    foundSolution:=Board.isSolved;
  end);
  Board;
end;

randomRiddle->begin
  local riddle:=randomSolution;
  random(81).sortPerm.each(undefIdx,begin
    local previousRiddle:=riddle;
    riddle:=[0..80].each(i,i=undefIdx ? [1..9] : riddle[i]);
    riddle.solve.isSolved ? void : riddle:=previousRiddle;
    void;
  end);
  print('Generated a riddle with difficulty: ',riddle.difficulty);
  riddle;
end;

//*For regression test: create a random riddle and print it out
main->randomRiddle.printBoard;

