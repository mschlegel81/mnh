private oneElemListToScalar(L)->size(L)=1 ? L%0 : L;
private dropSet(x:int,L)->x in L ? [] : x;
private dropSet(X    ,L)->oneElemListToScalar(X%not(each(x,X,x in L)));
private Connectivity:=each(i,[0..8],|,each(j,[0..8],
                    unique(dropSet(flatten(i*9+[0..8], //indexes in the same row
                                           [0..8]*9+j, //indexes in the same column
                                           (i div 3)*27+(j div 3)*3+[0..2,9..11,18..20]),
                                   [i*9+j])))); //indexes in the same block

private scrambledRiddle(Board)->begin
  local rowPerm:=each(i,3*sortPerm(random(3)),|,i+sortPerm(random(3)));
  local colPerm:=each(i,3*sortPerm(random(3)),|,i+sortPerm(random(3)));
  local numPerm:=1+sortPerm(random(9));
  local cellPerm:=each(i,rowPerm,|,i*9+colPerm);
  each(b,Board%each(i,rowPerm,|,i*9+colPerm),b:int?(numPerm%(b-1)):b);
end;

private filterInt(B)->each(b,B,b:int ? b : []);
private randomFromList(L)->L%floor(random*(size(L)-1));

private randomNonIntIndex(B)->randomFromList([0..80]%not(each(i,[0..80],(B%i):int)));
private randomIntIndex   (B)->randomFromList([0..80]%   (each(i,[0..80],(B%i):int)));
private difficulty       (B)->trueCount     (        not(each(i,[0..80],(B%i):int)));

private restrictRandom(B)->begin
  local idx:=randomNonIntIndex(B);
  solve(each(j,[0..80],idx=j ? randomFromList(B%j) : B%j));
end;

private loosenRandom(B)->begin
  local idx:=randomIntIndex(B);
  each(j,[0..80],idx=j ? [1..9] : B%j);
end;

private blacklist(B)->each(c,Connectivity,flatten(B%c));
private solve(   Board                             )->solve(Board,blacklist(filterInt(Board)));
private solve(   Board,blacklist                   )->solve(Board,blacklist,each(i,[0..80],dropSet(Board%i,blacklist%i)));
private solve(oldBoard,blacklist,newBoard==oldBoard)->oldBoard;
private solve(oldBoard,blacklist,newBoard          )->solve(newBoard);
private canSolve(Board)->isSolved(solve(Board));

private isSolved (B)->each(b,B,and,b:int);
private isInvalid(B)->each(b,B,or ,b==[]);

private initialBoard:=solve(each(i,[0..80],i mod 10 = 0 ? (i div 10)+1 : [1..9]));
private randomSolution->randomSolution(initialBoard,restrictRandom(initialBoard),10);
private randomSolution(oldBoard,newBoard,retries                           )->randomSolution(oldBoard,newBoard,retries,isSolved(newBoard),isInvalid(newBoard));
private randomSolution(oldBoard,newBoard,retries,solved=true ,invalid=false)->newBoard;
private randomSolution(oldBoard,newBoard,retries,solved=false,invalid=false)->randomSolution(newBoard,restrictRandom(newBoard),retries);
private randomSolution(oldBoard,newBoard,0      ,solved      ,invalid=true )->randomSolution;
private randomSolution(oldBoard,newBoard,retries,solved      ,invalid=true )->randomSolution(oldBoard,restrictRandom(oldBoard),retries-1);



private randomRiddle->randomRiddle(randomSolution);
private randomRiddle(oldBoard                         )->randomRiddle(oldBoard,loosenRandom(oldBoard),    100);
private randomRiddle(oldBoard,newBoard,retries        )->randomRiddle(oldBoard,newBoard              ,retries,canSolve(newBoard));
private randomRiddle(oldBoard,newBoard,retries  ,true )->randomRiddle(newBoard,loosenRandom(newBoard),retries  );
private randomRiddle(oldBoard,newBoard,retries>0,false)->randomRiddle(oldBoard,loosenRandom(oldBoard),retries-1);
private randomRiddle(oldBoard,newBoard,retries=0,false)->             oldBoard;

private format2(Board)->"=========#=========#=========\n"&
                each(i,[0..8],aggregator({$x&"\n"&$y}),((i=3 or i=6)? "---------+---------+---------\n" : "")&
                each(j,[0..8],&     ,((j=3 or j=6)? "|"                               : "")&
                     " "&replace(string(Board%(i*9+j)),"[1,2,3,4,5,6,7,8,9]"," ")&" "))&
                "\n=========#=========#=========\n";

private pack(Board)->replace(each(b,Board,&,string(b)),
                     ["[1,2,3,4,5,6,7,8,9]","000000000","00000000","0000000","000000","00000","0000","000","00"],
                     ["0"                  ,"a"        ,"b"       ,"c"      ,"d"     ,"e"    ,"f"   ,"g"  ,"h"]);
private memoized unpack(s:string)->each(c,copy(replace(s,["a".."h"],["b".."h","0"]&0),[0..80],1),c="0" ? [1..9] : softCast(c));

private printRiddle  (B)->print(format2(B)) and print('Difficulty: ',difficulty(B)," '",pack(B),"'");

//*For regression test
main->begin
  print('----------------------------------');
  main('riddle');
  print('----------------------------------');
  main('4');
  print('----------------------------------');
  main("lazy",'4');
  print('----------------------------------');
end;

//*Create one random riddle
main("riddle")->printRiddle(randomRiddle);
//*Create count random riddles in packed form
main(count:string)->each(l,each(i,[1..softCast(count)],pack(randomRiddle)),print(l));

private
PREPARED:=["1h2e6d3c804h8f56g90307f7d3d5e4182f62h9"     ,"ag3f2e8h709a705g3h1080265043c69h501f269g",
           "04h32h69h7c3g1g9h8f7e4g541h307g52g1f6a0509" ,"ab9g2g5g6h3f7g108e5h74057e3093h72060804g10",
           "17b2g4h3f921c9h5090703h2054f7d17b48f5f9"    ,"h9h3025f1f6b8024075c9017h5a50403e6018h8d9",
           "1h3f502h704e69f5e6g4h52h3g78f208d3h1h5d4g9" ,"1g904c51g43g607g401a83e26f6403g2a037h2h9",
           "1d3f601g45089d947h1h8g3e2h6h7g2g6e45e7e9"   ,"09d7026h4f5h6h98805e1g3b8b543c201h2g70309",
           "0509ag104035h2e40907h302f8e6f1d52h7104f6f39","0785h9g2g78e809g3d6f2ah1h405e3f104h6g43209",
           "e29065h6g70903h58e47e86c7ag9h101h2g37g8g9"  ,"c9062d4g50801d9h2346c1h8h5g206f7g105805c9",
           "149ag607h3d2f18g60859e7g4g8f7d1508g102g9"   ,"09c52g78h8h14h7h70402f3h5h4g9h6e18f5b6e1h9"];
//*Create count random riddles from prepared ones
main("lazy",count:string)->each(i,[1..softCast(count)],print("\n"&format2(scrambledRiddle(unpack(PREPARED%floor(random*(size(PREPARED)-1)))))));
