private drop(list:intList,toDrop:int)->list%(list!=toDrop);
private drop(list:intList,toDrop:intList)->each(el,list,el in toDrop ? void : el);

private
COMPONENTS:=each(i,[0..8],i+[0..8]*9)|
            each(i,[0..8],i*9+[0..8])|
            each(i,[0..8],[0..80]%(i=([0..80] div 27)*3+[0..80] mod 9 div 3));

private memoized connectedIdx(i:int)->sort(flatten(each(c,COMPONENTS,i in c ? drop(c,i) : void)));
private memoized components(i)->each(c,COMPONENTS,i in c ? drop(c,i) : void);

//*A board is solved when all components contain numbers [1..9]
isSolved(Board)->each(c,COMPONENTS,AND,(Board%c).sort==[1..9]);
//*A board is valid when all components may contain all numbers [1..9]
isValid(Board)->each(cell,Board,AND,not(cell==[])) AND
                each(c,COMPONENTS,AND,(Board%c).flatten.unique==[1..9]);
//*A board's difficulty is given by the number of cells to fill
difficulty(Board)->each(cell,Board,+,cell:int ? 0 : 1);

initialBoard->begin
  local values:=1+random(9).sortPerm;
  local indexes:=[0..8]*9+random(9).sortPerm;
  each(i,[0..80],i in indexes ? values%(indexes=i)%0 : [1..9]);
end;
  
testBoard:=
[[1..9],  5   ,[1..9],  9   ,[1..9],[1..9],  6   ,[1..9],  1   ,
   6   ,  3   ,[1..9],  8   ,[1..9],  5   ,[1..9],  4   ,[1..9],
 [1..9],[1..9],  7   ,[1..9],[1..9],[1..9],[1..9],[1..9],  9   ,
   3   ,  6   ,[1..9],[1..9],[1..9],  4   ,[1..9],  1   ,[1..9],
 [1..9],[1..9],[1..9],[1..9],[1..9],[1..9],[1..9],[1..9],[1..9],
 [1..9],  9   ,[1..9],  5   ,[1..9],[1..9],[1..9],  8   ,  4   ,
   1   ,[1..9],[1..9],[1..9],[1..9],[1..9],  4   ,[1..9],[1..9],
 [1..9],  8   ,[1..9],  3   ,[1..9],  9   ,[1..9],  6   ,  7   ,
   9   ,[1..9],  3   ,[1..9],[1..9],  1   ,[1..9],  2   ,[1..9]];

printBoard(B)->each(row,[0..8],print(row in [3,6] ? "---------+---------+---------\n" : '',
               each(col,[0..8],&,begin
                 local i:=col+9*row;
                 (col in [3,6] ? '|' : '')&
                 " "&((B%i) :int ? B%i : " ")&" ";
               end)))|B;

debugPrint(B)->printf@("%X%\t%X%\t%X%\t%X%\t%X%\t%X%\t%X%\t%X%\t%X%"|each(row,[0..8],B%(row+9*[0..8])));

solve(B)->begin
  local needRun:=isValid(B);
  local Board:=B;
  while(needRun,
  begin
    needRun:=false;
    local intsOnly:=each(c,Board,c:int ? c : []);
    Board:=each(i,[0..80],
      (Board%i):int
      ? Board%i
      : begin
          local newList:=drop(Board%i,flatten(intsOnly%connectedIdx(i)));
          size(newList)=1
          ? begin
              needRun:=true;
              newList%0;
            end
          : begin
              local tmp:=drop(Board%i,flatten(Board%(components(i)%0)));
              size(tmp)=1 ? begin needRun:=true; tmp%0; end : begin
              tmp:=drop(Board%i,flatten(Board%(components(i)%1)));
              size(tmp)=1 ? begin needRun:=true; tmp%0; end : begin
              tmp:=drop(Board%i,flatten(Board%(components(i)%2)));
              size(tmp)=1 ? begin needRun:=true; tmp%0; end : newList; end; end;
            end;
        end);
  end);
  Board;
end;

bruteForceSolve(B)->begin
  local Board:=solve(B);
  isSolved(Board) ? Board : begin
    local firstListIdx:=min(81|each(i,[0..80],(Board%i):int ? void : i));
    local candidates:=Board%firstListIdx;
    local numberOfSolutions:=0;
    local finalSolution:=void;
    each(candidate,candidates,numberOfSolutions>1 ? void : begin
      local newSolution:=bruteForceSolve(each(i,[0..80],i=firstListIdx ? candidate : Board%i));
      isSolved(newSolution)
      ? begin
          finalSolution:=newSolution;
          numberOfSolutions+=1;
        end
      : void;
    end);
    numberOfSolutions=1 ? finalSolution : initialBoard;
  end;
end;

private restrictRandom(B)->begin
  local listIndexes:=each(i,[0..80],(B%i):int ? void : i);
  listIndexes==[] ? B : begin
    local randomListIdx:=listIndexes%intRandom(size(listIndexes));
    each(i,[0..80],i=randomListIdx ? (B%i)%intRandom(size(B%i)) : B%i);
  end;
end;

randomSolution->begin
  local foundSolution:=false;
  local Board:=void;
  while(not(foundSolution),begin
    Board:=initialBoard.restrictRandom.solve;
    while(isValid(Board) AND not(Board.isSolved),Board:=Board.restrictRandom.solve);
    foundSolution:=Board.isSolved;
  end);
  Board;
end;

randomRiddle->begin
  local riddle:=randomSolution;
  each(undefIdx,sortPerm(random(81)),begin
    local previousRiddle:=riddle;
    riddle:=each(i,[0..80],i=undefIdx ? [1..9] : riddle%i);
    riddle.solve.isSolved ? void : riddle:=previousRiddle;
    void;
  end);
  print('Generated a riddle with difficulty: ',riddle.difficulty);
  //intIdx:=each(i,[0..80],(riddle%i):int ? i : void);
  riddle;
end;

//*For regression test: create a random riddle and print it out
main->randomRiddle.printBoard;

