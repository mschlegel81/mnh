clock:=//!~
 __________
|          |
|GEDBAABDEG|
|LJHFCCFHJL|
|QOMKIIKMOQ|
 \TRPNNPRT/
  \WUSSUW/
   \XVVX/
    \YY/
     \/ <*>
     /\ >$<
    /  \
   / zz \
  / yvvy \
 / xuooux \
|wtrnjjnrtw|
|sqmiffimqs|
|plheccehlp|
|kgdbaabdgk|~;
//print(clock);

memoized printOnce(s:string)->print("\f\n",s);

clock(i:int,finalTime,restTime)->begin
  local retain:=chars[flatten([ord('a')-1..ord('a')-1+i,
                               ord('A')+i-1..ord('Z')])];
  local drop:=['a'..'z','A'..'Z'].minus(retain);
  local l:=clock.replace(retain,'#').replace(drop,' ').split("\n");
  (l.leading|l.trailing.replace(" ","_"))
  .join("\n")
  .replace('*',formatTime("hh:mm:ss",finalTime))
  .replace('$',formatTime("hh:mm:ss",restTime));
end;

tolerantParseTime(input:string)->
  try({parseTime('hh:nn:ss',input)},
      {try({parseTime('hh:nn',input)},
           false)});

readTimeOrInterval(questionPrefix:string)->begin
  local result:=false;
  while(not(result.isNumeric),
    result:=ask(questionPrefix&' as HH:MM.SS or HH:MM').tolerantParseTime);
  result;
end;

readInterval->readTimeOrInterval('Enter interval') - parseTime('hh:nn:ss','00:00:00') + systime;
readTime    ->readTimeOrInterval('Enter time');
mutable endTime:=void;
mutable keypressed:=false;
mutable beepOnce:=false;

private timerLoop->begin
  async({begin
    ask('Press enter to cancel');
    keypressed:=true;
  end});

  local startTime:=systime;
  while(systime<endTime AND not(keypressed),begin
    clock(round(26*(systime-startTime)/(endTime-startTime)),
          endTime,
          endTime-systime).printOnce;
    sleep(0.1);
  end);
  beepOnce ? beep :
  while(not(keypressed),begin
    beep;
    sleep(1);
  end);
end;

main->begin
  endTime:=[['t',{readTime}],['i',{readInterval}],['a',{false}]][ask('Timer: [t]ime, [i]nterval or [a]bort?',['t','i','a'])]();
  endTime.isNumeric
  ? timerLoop
  : void;
end;
