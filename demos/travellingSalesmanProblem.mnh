private points:=[0..1199].each(i,sqrt(i)*[cos(2.39996323*i),sin(2.39996323*i)]).each(p,-25<p.get(0)<25 and -25<p.get(1)<25 ? p : void);

private norm(x)->sqrt(x.sqr.agg(+));

private pathLength(points)->begin
  local result:=0;
  local lastPoint:=points.trailing;
  points.each(p,result:=result+norm(lastPoint-p),lastPoint:=p);
  result;
end;

private len4(a,b,c,d)->norm(b-a)+norm(c-b)+norm(d-c);

scSort(L)->begin
  local x:=L.getInner(0); local xr:=[min(x),max(x)];
  local y:=L.getInner(1); local yr:=[min(y),max(y)];
  local h:=max(xr.get(1)-xr.get(0),yr.get(1)-yr.get(0))/2;
  xr:=(xr.get(1)+xr.get(0))*0.5;
  yr:=(yr.get(1)+yr.get(0))*0.5;
  local x0:=xr-h;
  local x1:=xr+h;
  local y0:=yr-h;
  local y1:=yr+h;
  local mask:=sqr(x-x0)+sqr(y-y1)<
              sqr(x-x1)+sqr(y-y0);
  local result:=scSort_(x0,y0,x0,y1,x1,y1,x.get(    mask ),y.get(    mask ))|
                scSort_(x1,y1,x1,y0,x0,y0,x.get(not(mask)),y.get(not(mask)));
  print('Path length after construction is ',round(pathLength(result),3));
  result;
end;

polish(L)->begin
  local result:=L;
  local changing:=true;
  while(changing,begin
    changing:=false;
    [0..size(result)-1].each(i,begin
      local beforeSwapping:=len4@(result.get([i,i+1,i+2,i+3] mod size(result)));
      local afterSwapping :=len4@(result.get([i,i+2,i+1,i+3] mod size(result)));
      afterSwapping<beforeSwapping ? begin
        changing:=true;
        local j0:=(i+1) mod size(result);
        local j1:=(i+2) mod size(result);
        result:=result.get([0..size(result)-1].each(j,j=j0 ? j1 :
                                                      j=j1 ? j0 : j));
        void;
      end : void;
    end);
  end);
  print('Path length after polishing is    ',round(pathLength(result),3));
  result;
end;

private scSort_(ax:numeric,ay:numeric,bx:numeric,by:numeric,cx:numeric,cy:numeric,x:numericList,y:numericList)->
  size(x)>1
  ? (sqr(ax-cx)+sqr(ay-cy)>1E-12
    ? begin
        local mask:=sqr(x-ax)+sqr(y-ay) <
                    sqr(x-cx)+sqr(y-cy);
        scSort_(ax,ay,(ax+cx)/2,(ay+cy)/2,bx,by,x.get(    mask ),y.get(    mask )) |
        scSort_(bx,by,(ax+cx)/2,(ay+cy)/2,cx,cy,x.get(not(mask)),y.get(not(mask)));
      end
    : begin
        print('Aboring at ',ax,'  ',ay,' | ',
                            bx,'  ',by,' | ',
                            cx,'  ',cy,' with ',size(x),' points');
        [0..size(x)-1].each(i,[x.get(i),y.get(i)]);
      end)
  : size(x)=1 ? [x|y] : [];

//*Approximately solves the Travelling Salesman Problem using sorting by Sierpinski-Curve
main->begin
  plot.setOptions([['axisStyleX',0],['axisStyleY',0]]);
  local L:=polish(scSort(points));
  plot(L|L.get([0]),'. l');
  plot.renderToFile(replace(myPath,'.mnh','.png'),768,768,4);
end;
