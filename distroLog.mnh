private plain datastore log;
private plain datastore versionInfo;

maxLoggedBuildNumber->try({max(log.getInner(1).getInner(0))},0);

@SuppressUnusedWarning
private ensureVersionInfo:=versionInfo.isVoid ? begin
  versionInfo:=['MajorVersionNr'=>0,
                'MinorVersionNr'=>0,
                'RevisionNr'=>0].toMap;
end : void;


@SuppressUnusedWarning
getVersionInfoTag(fullVersion:Boolean,buildNr)->begin
  format(//!~    <VersionInfo>
      <UseVersionInfo Value="True"/>
      <MajorVersionNr Value="%s"/>
      <MinorVersionNr Value="%s"/>
      <RevisionNr Value="%s"/>
      <BuildNr Value="%s"/>
      <CharSet Value="04B0"/>
      <StringTable CompanyName="Martin Schlegel" FileDescription="%s" InternalName="%s" LegalCopyright="LGPL" OriginalFilename="%s" ProductName="MNH5"/>
    </VersionInfo>~,
    versionInfo['MajorVersionNr'] orElse 0,
    versionInfo['MinorVersionNr'] orElse 0,
    versionInfo['RevisionNr'] orElse 0,
    buildNr,
    fullVersion ? "MNH5 IDE and interpreter" : "MNH5 light interpreter",
    fullVersion ? "mnh5_full" : "mnh5_light",
    fullVersion ? "mnh" : "mnh_light").split("\n");
end;

private versionString->format('%s.%s.%s',versionInfo['MajorVersionNr'] orElse 0,
                                         versionInfo['MinorVersionNr'] orElse 0,
                                         versionInfo['RevisionNr'] orElse 0);
private versionVector->[versionInfo['MajorVersionNr'] orElse 0,
                        versionInfo['MinorVersionNr'] orElse 0,
                        versionInfo['RevisionNr'] orElse 0];

memoized expectedVersionInfoSource(codeHash:String)->
  begin
    local buildAndVersion:=getBuildNumberAndVersion(codeHash);
    ["BUILD_NUMBER=%s;".format(buildAndVersion[0]),
     "CODE_HASH=%s;".format(codeHash.escapePascal),
     "VERSION=%s;".format(escapePascal(versionVector.join('.')))];
  end;

private updateProjectFiles(buildNr)->begin
  fixLpiFile(myPath.extractFileDirectory&'/ide/ide.lpi',true,buildNr);
  fixLpiFile(myPath.extractFileDirectory&'/consoles/mnh_light.lpi',false,buildNr);
end;

memoized getBuildNumberAndVersion(codeHash:String)->
  begin
    isVoid(log)
    ? log:=[].toMap
    : void;
    (log[codeHash] orElse begin
      local nextNo:=maxLoggedBuildNumber+1;
      log[codeHash]:=[nextNo,versionVector];
      updateProjectFiles(nextNo);
      [nextNo,versionVector];
    end);
  end;

//*Show info on logged versions
main->isVoid(log)
      ? print('No build version logged')
      : begin
          log.sort(1).trailing(10).map({$x.join("\t")&($x[0]==mnhInfo['codeVersion'] ? "\t*" : "")}).join("\n").print;
          log.size<=50
          ? void
          : begin
              print('Log has ',log.size,' entries - limiting to last 50');
              log:=log.sort(1).trailing(50).toMap;
            end;
          void;
        end
      orElse print('Current version: ',versionString);


private fixLpiFile(lpiPath:String,fullVersion:Boolean,buildNr)->
  begin
    local versionInfoTag:=getVersionInfoTag(fullVersion,buildNr);
    local nextLine:=lpiPath.fileLineIterator;
    local newLines:=[];
    local currLine:=void;
    while(!isVoid(currLine:=nextLine()),
      currLine.trim=='<VersionInfo>'
      ? begin
          newLines|=versionInfoTag;
          while(!isVoid(currLine:=nextLine()) AND !(currLine.trim=='</VersionInfo>'));
        end
      : newLines|=currLine);
    nextLine:=void; //close iterator
    lpiPath.writeFileLines(newLines).assert;
  end;

main('inc','major'   )->begin
  versionInfo['MajorVersionNr']:=(versionInfo['MajorVersionNr'] orElse 0)+1;
  versionInfo['MinorVersionNr']:=0;
  versionInfo['RevisionNr']:=0;
  print('Current version: ',versionString);
end;

main('inc','minor')->begin
  versionInfo['MinorVersionNr']:=(versionInfo['MinorVersionNr'] orElse 0)+1;
  versionInfo['RevisionNr']:=0;
  print('Current version: ',versionString);
end;

main('inc','revision')->begin
  versionInfo['RevisionNr']:=(versionInfo['RevisionNr'] orElse 0)+1;
  print('Current version: ',versionString);
end;
