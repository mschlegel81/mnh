<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MNH 5 - each and pEach</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - each and pEach</h3>
<div align="right"><hr> </div>
<h4><a href="#syntax">Syntax</a></h4>
<h4><a href="#construction">List construction</a></h4>
<h4><a href="#aggregation">List aggregation</a></h4>
<h4><a href="#consAgg">List construction and aggregation</a></h4>
<h4><a href="#parallelization">Parallelization</a></h4>

<div align="right"><hr> </div>
<h4><a name="syntax">Syntax</a></h4>
The general syntax is: <br>
<code>   each(id,list,aggregator,body)
  pEach(id,list,aggregator,body)</code><br>
Where <code>id</code> is an identifier,<br> 
<code>list</code> is a list or an expression returning a list,<br> 
<code>aggregator</code> (optional) is a full aggregator expression or a binary operator and<br>
<code>body</code> is an expression or list of expressions.

<h4><a name="construction">List construction</a></h4>
To construct a list, ommit the aggregator. The body part is mandatory.<br>
Simple example: return the input list<br>
<code>  each(i,[0..3],i) </code> (returns <code>[0..3]</code>)<br>
Reasonable example: return <code>f(i)</code> for every element <code>i</code> in the input list:<br>
<code>  each(i,[0..3],f(i)) </code> (returns <code>[f(0),f(1),f(2),f(3)]</code>)<br>
More complex: a function returning the intersection of sets A and B<br>
<code>  intersect(A:list,B:list) -> A%each(a,A,a in B)</code>

<h4><a name="aggregation">List aggregation</a></h4>
To aggregate a list, use an aggregator but no body.<br>
Restriction: the list must not be empty!<br>
Simple example: a function returing the sum of the argument:<br>
<code>  sum([]):=0;
  sum(L<>[])->each(e,L,+);
</code><br>
For later use: factorial<code>
  fak(n<1)->1;
  fak(n)->each(i,[1..n],*);
</code><br>

A full aggregator is written as <code>aggregator(<i>expression</i>)</code>, where <i>expression</i> is a binary expression.<br>

Full aggregator: join a list of strings using a line break as separator:<br>
Here the aggregator expression takes the left hand side argument and the right hand side argument and concatenates them with an additional line break in between.
<code>
  join([])->"";
  join(L:stringList)->each(e,L,aggregator({$x&"\n"&$y}));</code><br>

  
<h4><a name="consAgg">List construction and aggregation</a></h4>
You can also use aggregator and body in the same each-/pEach clause.<br><br>
Nested each: construct a cross product:<br>
<code>  each(i,[0..9],each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[[0,0],...,[0,9]],[[1,0],...,[1,9]],...]</code>,<br> which is probably one level deeper than intended.<br>
<code>
  each(i,[0..9],|,each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[0,0],...,[0,9],[1,0],...,[1,9],...]</code>.<br><br>
Compute Euler's number based on inverse factorials<code>
  each(n,[0..20],+,1/fak(n))</code>

<h4><a name="parallelization">Parallelization</a></h4>
This is simple.<br>In order to parallelize your existing <code>each</code>-expression just replace <code>each</code> by <code>pEach</code>.<br>

<div align="right"><hr> </div>
</body>
</html>
