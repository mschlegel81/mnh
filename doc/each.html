<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MNH 5 - each and pEach</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - each and pEach</h3>
<div align="right"><hr> </font></div>
<h4><a href="#syntax">Syntax</a></h4>
<h4><a href="#construction">List construction</a></h4>
<h4><a href="#aggregation">List aggregation</a></h4>
<h4><a href="#consAgg">List construction and aggregation</a></h4>
<h4><a href="#parallelization">Parallelization</a></h4>

<div align="right"><hr> </font></div>
<h4><a name="syntax">Syntax</a></h4>
The general syntax is: <br>
<code>   each(id,list,aggregator,body)
  pEach(id,list,aggregator,body)</code><br>
Where <code>id</code> is an identifier,<br> 
<code>list</code> is a list or an expression returning a list,<br> 
<code>aggregator</code> (optional) is a partial expression both starting and ending with an operator and<br>
<code>body</code> is an expression or list of expressions.

<h4><a name="construction">List construction</a></h4>
To construct a list, ommit the aggregator. The body part is mandatory.<br>
Simple example: return the input list<br>
<code>  each(i,[0..3],i) </code> (returns <code>[0..3]</code>)<br>
Reasonable example: return <code>f(i)</code> for every element <code>i</code> in the input list:<br>
<code>  each(i,[0..3],f(i)) </code> (returns <code>[f(0),f(1),f(2),f(3)]</code>)<br>
More complex: a function returning the intersection of sets A and B
<code>  intersect(A:list,B:list) -> A%each(a,A,a in B)</code>

<h4><a name="aggregation">List aggregation</a></h4>
To aggregate a list, use an aggregator but no body.<br>
Restriction: the list must not be empty!<br>
Simple example: a function returing the sum of the argument:<br>
<code>  sum([]):=0;
  sum(L<>[])->each(e,L,+);</code><br>
More complex aggregator: join a list of strings using a line break as separator:<code>
  join([])->"";
  join(L:stringList)->each(e,L,&"\n"&);</code><br>
For later use: factorial<code>
  fak(n<1)->1;
  fak(n)->each(i,[1..n],*);
</code>

<h4><a name="consAgg">List construction and aggregation</a></h4>
You can also use aggregator and body in the same each-/pEach clause:
Nested each: construct a cross product:<br>
<code>  each(i,[0..9],each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[[0,0],...,[0,9]],[[1,0],...,[1,9]],...]</code>, which is probably one level deeper than intended.<br>
<code>  each(i,[0..9],|,each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[0,0],...,[0,9],[1,0],...,[1,9],...]</code>.<br>
Compute Euler's number based on inverse factorials<code>
  each(n,[0..20],1/fak(n))</code>

<h4><a name="parallelization">Parallelization</a></h4>
This is simple.<br>In order to parallelize your existing <code>each</code>-expression just replace <code>each</code> by <code>pEach</code>.<br>
Note that pure functions do not work well with parallelized evaluations. This issue will be adressed in later versions.

<div align="right"><hr> </font></div>
</body>
</html>
