arity({3});

arity({sin($x)/$x});

arity({sin($x)/$y});

//For variadic functions only the non-optional parameters are counted:
arity({printf('%s%s',$a,...)});

expression("$x-$x^2+$x^3");

expression("");

not(true);

not([true, false, true]);

not({$x});

not(7);

parameterNames({3});

parameterNames({sin($x)/$x});

parameterNames({sin($x)/$y});

//For variadic functions only the non-optional parameters are counted:
parameterNames({printf("%s%s", $a, ...)});

ord(3);

ord(true);

ord(false);

ord("A");

ord("abc");

ord(2.1);

softCast("A");

softCast('"B"');

softCast(3);

softCast([1, "2", "true", "'TEXT'", "1.5", "2,6"]);

splitFileName("../test.txt");

string('a');

string(234);

string([1, 2.6, "a", true, {$x}]);

abs(-0.92);

abs(3);

abs({1+$x});

arccos(-0.92);

//Out of function domain
arccos(3);

arccos({1+$x});

arcsin(-0.92);

//Out of function domain
arcsin(3);

arcsin({1+$x});

tan(-0.92);

tan(3);

tan({1+$x});

tan(2*arctan(1));

arctan(-0.92);

pi:=4*arctan(1);
pi;

arctan({$x});

argMax(sin([0..10]));

argMax([1, 3, 3, 0, 2]);

argMin(sin([0..10]));

argMin([1, 3, 3, 0, 2]);

ceil(20/3);

ceil([0..3]/3);

ceil([0..3]/3, 2);

ceil(20/3, [-1..3]);

floor(20/3);

floor([0..3]/3);

floor([0..3]/3, 2);

floor(20/3, [-1..3]);

round(20/3);

//Numbers with ambiguous rounding result are rounded towards even numbers
round([0.5, 1.5, 2.5, 3.5]);

round([0..3]/3, 2);

round(20/3, [-1..3]);

isInRange(7, 0, 10);

//You can use infinite ranges
isInRange(7, 0.3,  Inf);

//The first argument can be a list
isInRange([0..9]/10, 0.3, 0.57);

isInfinite(Nan);

isInfinite(+Inf);

isInfinite(-Inf);

isInfinite([-3.4344, Nan, +Inf]);

isNan(Nan);

isNan(+Inf);

isNan(-Inf);

isNan([-3.4344, Nan, +Inf]);

cos(-0.92);

cos(3);

cos({1+$x});

exp(-0.92);

exp(3);

exp({1+$x});

ln(-0.92);

ln(3);

ln({1+$x});

ln(-0.92);

sin(3);

sin({1+$x});

sqr(-0.92);

sqr(3);

sqr({1+$x});

sqrt(-0.92);

sqrt(3);

sqrt({1+$x});

sign(-0.92);

sign(3);

sign({1+$x});

max(["a".."z"]);

max([0..9]/2);

max(true, false);

min(["a".."z"]);

min([0..9]/2);

min(true, false);

copy("abcde", 1, 3);

escape("a");

escape("\t");

//Group a list of numbers by divisibility by 3
group([1..10],[1..10] mod 3=0);

fail;

fail("Told you this wouldn't work!");

hash(1);

hash([1..3]);

hash("a");

listBuiltin.each(func,copy(func,0,4)=='mnh.' ? func : void);

//Group to join element frequencies
group([[1,'a'],[2,'a'],[1,'b'],[4,'c'],[2,'a'],[2,'b']],1,aggregator({[$x.get(0)+$y.get(0),$x.get(1)]}));

abs(3);

abs(-3);

abs([-2..2]/2); 

chars('This is a test.');

chars.get(100);

clean('+21/232/2116-11',['0'..'9'],' ');

join(['a','b','c']);

join([1..5],' ');

length('Test');

length(['Text','AbC']);

lower('Test');

lower(['Text','AbC']);

upper('Test');

upper(['Text','AbC']);

t:=[0..1000]*0.006283;
plot(t,sin(t));
plot.renderToFile('plotDemo1.png',600,300,4);

printf("%s",
       sandBoxExecute('f(x<1)->random; f(x)->f(x-1)+random; f(3)')
       .each(message,join(message,"\t")));
     
abs({$x});

abs(3);

abs(-5/7);

abs([-2..2]);

chars('Test');

pos('o','Hello World');

pos(',',['Hello','Test','1,2,3']);

pos(['a','b'],'cdb');

repeat('-',10);

//Simple test for correct bracketing:
replace('[[][]][]][][','[]','');

//Iteration will not take place if it is infinite:
replace('aba','b','bb');

replaceOne('[[][]][]][][','[]','');

replaceOne('1:.-.; 2:.-.; 3:.-.','.',['a'..'e']);

split('1,2,3;4,5,6',',');

split('1,2,3;4,5,6',';');

split('1,2,3;4,5,6',[';',',']);

tokenSplit('f(x)->x+1; //Stupid, but just an example...','mnh');

trim(" \tA B C\t ");

trimLeft(" \tA B C\t ");

trimRight(" \tA B C\t ");

unbrace('3');

unbrace('(3)');

unbrace('(3]');

unbrace('"3"');

//Note that ([[1],[2]]|[3]) returns a different result
add([[1],[2]],[3]);

chars('Testtext').elementFrequency;

flatten([1,[2,[3,4],[5]],6]);

head(['A'..'Z']);

head(['A'..'Z'],3);

tail(['A'..'Z']);

tail(['A'..'Z'],3);

leading(['A'..'Z']);

leading(['A'..'Z'],3);

trailing(['A'..'Z']);

trailing(['A'..'Z'],3);

//Odd squares
minus([1..10]^2,2*[0..50])

sort(intRandom(10,5));

sort(['01','10','100','1','010'],{softCast($x)<=softCast($y)});

//A random permutation:
sortPerm(random(10));

sortPerm(['a'..'c'..'a']);

intersect([0..1000]^2,[0..1000]^3);

union(1/[1..5],2/[2..6]);

deleteFile('plotDemo1.png');

driveInfo.C;

drop([['A',1],['B',2],['C',0]],'B');

//See <a href="types.html#lists">List types</a> for further information
get(['a'..'f'],3);
get(['a'..'f'],[3,1,2]);
get([0..4],[2..6] mod 3 =0);
get([['A',1],['B',2],['C',0]],'B');

//See <a href="types.html#lists">List types</a> for further information
getInner([[1,2,3],[4,5,6],[7,8,9]],1);
getInner([[1,2,3],[4,5,6],[7,8,9]],[1,0]);
getInner([[1,2,3],[4,5,6],[7,8,9]],[true,false,true]);

indexOf([1..6]^2 mod 3=0);

mapGet([['A',1],['B',2],['C',0]],'B');
mapGet([['A',1],['B',2],['C',0]],'D');
mapGet([['A',1],['B',2],['C',0]],'B',-1);
mapGet([['A',1],['B',2],['C',0]],'D',-1);

mapPut([['A',1],['B',2],['C',0]],'A',0);
mapPut([['A',1],['B',2],['C',0]],'D',3);         

reverseList([1..5]);

size([0.5,0.1,0.2]);

toMap([['A',1],['B',2],['C',0],['B',4]]);

trueCount(10<[0..10]^2<50);

unique([3,1,2,1,4,1,5]);

//compress/decompress uses a hybridization of different compression algorithms
//It is possible that the compressed string equals the original string.
compress('Test');
compress('Test').decompress;
compress('Testtext');
compress('Testtext').decompress;