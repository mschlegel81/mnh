arity({3});

//#mnh.arity
arity({sin($x)/$x});

//#mnh.arity
arity({sin($x)/$y});

//#mnh.arity
//For variadic functions only the non-optional parameters are counted:
arity({printf('%s%s',$a,...)});

toExpression("$x-$x^2+$x^3");

toExpression("");

not(true);

not([true, false, true]);

not({$x});

not(7);

parameterNames({3});

//#mnh.parameterNames
parameterNames({sin($x)/$x});

//#mnh.parameterNames
//For variadic functions only the non-optional parameters are counted:
parameterNames({printf("%s%s", $a, ...)});

ord(3);

ord(true);

ord(false);

ord("A");

ord("abc");

ord(2.1);

softCast("A");

softCast('"B"');

softCast(3);

softCast([1, "2", "true", "'TEXT'", "1.5", "2,6"]);

splitFileName("../test.txt");

toString('a');

toString(234);

toString([1, 2.6, "a", true, {$x}]);

abs(-0.92);

abs(3);

abs({1+$x});

arccos(-0.92);

//Out of function domain
arccos(3);

arccos({1+$x});

arcsin(-0.92);

//Out of function domain
arcsin(3);

arcsin({1+$x});

tan(-0.92);

tan(3);

tan({1+$x});

//#math.tan
tan(pi/2);

arctan(-0.92);

arctan({$x});

//#argMax
argMax(sin([0..10]));

argMax([1, 3, 3, 0, 2]);

//#argMin
argMin(sin([0..10]));

argMin([1, 3, 3, 0, 2]);

ceil(20/3);

ceil([0..3]/3);

ceil([0..3]/3, 2);

ceil(20/3, [-1..3]);

floor(20/3);

floor([0..3]/3);

floor([0..3]/3, 2);

floor(20/3, [-1..3]);

round(20/3);

//Numbers with ambiguous rounding result are rounded towards even numbers
round([0.5, 1.5, 2.5, 3.5]);

round([0..3]/3, 2);

round(20/3, [-1..3]);

isInfinite(Nan);

isInfinite(+Inf);

isInfinite(-Inf);

isInfinite([-3.4344, Nan, +Inf]);

isNan(Nan);

isNan(+Inf);

isNan(-Inf);

isNan([-3.4344, Nan, +Inf]);

cos(-0.92);

cos(3);

cos({1+$x});

exp(-0.92);

exp(3);

exp({1+$x});

ln(-0.92);

ln(3);

ln({1+$x});

ln(-0.92);

sin(3);

sin({1+$x});

sqr(-0.92);

sqr(3);

sqr({1+$x});

sqrt(-0.92);

sqrt(3);

sqrt({1+$x});

sign(-0.92);

sign(3);

sign({1+$x});

max(["a".."z"]);

max([0..9]/2);

max(true, false);

min(["a".."z"]);

min([0..9]/2);

min(true, false);

copy("abcde", 1, 3);

escape("a");

escape("\t");

//Group a list of numbers by divisibility by 3
group([1..10],[1..10] mod 3=0);

fail;

fail("Told you this wouldn't work!");

hash(1);

hash([1..3]);

hash("a");

//#listBuiltin
listBuiltin.each(func,copy(func,0,4)=='mnh.' ? func : void);

//Group to join element frequencies
group([[1,'a'],[2,'a'],[1,'b'],[4,'c'],[2,'a'],[2,'b']],1,aggregator({[$x[0]+$y[0],$x[1]]}));

abs(3);

abs(-3);

abs([-2..2]/2); 

chars('This is a test.');

//#chars
chars.get(100);

clean('+21/232/2116-11',['0'..'9'],' ');

join(['a','b','c']);

join([1..5],' ');

length('Test');

length(['Text','AbC']);

lower('Test');

lower(['Text','AbC']);

upper('Test');

upper(['Text','AbC']);

t:=[0..1000]*2*pi/1000;
plot(t,sin(t));
plot.renderToFile('plotDemo1.png',600,300,4);
    
abs({$x});

abs(3);

abs(-5/7);

abs([-2..2]);

chars('Test');

pos('o','Hello World');

pos(',',['Hello','Test','1,2,3']);

pos(['a','b'],'cdb');

repeat('-',10);

//Simple test for correct bracketing:
replace('[[][]][]][][','[]','');

//Iteration will not take place if it is infinite:
replace('aba','b','bb');

replaceOne('[[][]][]][][','[]','');

replaceOne('1:.-.; 2:.-.; 3:.-.','.',['a'..'e']);

split('1,2,3;4,5,6',',');

split('1,2,3;4,5,6',';');

split('1,2,3;4,5,6',[';',',']);

tokenSplit('f(x)->x+1; //Stupid, but just an example...','mnh');

trim(" \tA B C\t ");

trimLeft(" \tA B C\t ");

trimRight(" \tA B C\t ");

unbrace('3');

unbrace('(3)');

unbrace('(3]');

unbrace('"3"');

//Note that ([[1],[2]]|[3]) returns a different result
add([[1],[2]],[3]);

//#elementFrequency
chars('Testtext').elementFrequency;

flatten([1,[2,[3,4],[5]],6]);

head(['A'..'Z']);

head(['A'..'Z'],3);

tail(['A'..'Z']);

tail(['A'..'Z'],3);

leading(['A'..'Z']);

leading(['A'..'Z'],3);

trailing(['A'..'Z']);

trailing(['A'..'Z'],3);

//Odd squares
minus([1..10]^2,2*[0..50])

//#sort
sort(intRandom(10,5));

//#sort
sort(['01','10','100','1','010'],{softCast($x)<=softCast($y)});

//#sortPerm
//A random permutation:
sortPerm(random(10));

sortPerm(['a'..'c'..'a']);

intersect([0..1000]^2,[0..1000]^3);

union(1/[1..5],2/[2..6]);

deleteFile('plotDemo1.png');

drop([['A',1],['B',2],['C',0]],'B');

//See <a href="types.html#lists">List types</a> for further information
get(['a'..'f'],3);

get(['a'..'f'],[3,1,2]);

get([0..4],[2..6] mod 3 =0);

get([['A',1],['B',2],['C',0]],'B');

//See <a href="types.html#lists">List types</a> for further information
getInner([[1,2,3],[4,5,6],[7,8,9]],1);

getInner([[1,2,3],[4,5,6],[7,8,9]],[1,0]);

getInner([[1,2,3],[4,5,6],[7,8,9]],[true,false,true]);

indexOf([1..6]^2 mod 3=0);

mapGet([['A',1],['B',2],['C',0]],'B');

mapGet([['A',1],['B',2],['C',0]],'D');

mapGet([['A',1],['B',2],['C',0]],'B',-1);

mapGet([['A',1],['B',2],['C',0]],'D',-1);

mapPut([['A',1],['B',2],['C',0]],'A',0);

mapPut([['A',1],['B',2],['C',0]],'D',3);         

reverseList([1..5]);

size([0.5,0.1,0.2]);

toMap([['A',1],['B',2],['C',0],['B',4]]);

trueCount(10<[0..10]^2<50);

unique([3,1,2,1,4,1,5]);

//compress/decompress uses a hybridization of different compression algorithms
//It is possible that the compressed string equals the original string.
compress('Test');
compress('Test').decompress;

compress('Testtext');
compress('Testtext').decompress;

//#mnh.listKeywords
listKeywords.each(category,print(category[0],': ',category[1].head(3).join(', '),', ...'));

relativeFilename('~/folder/','~/other/example.txt');

primes(20);

subSets([1,2,1]);

diff('encode','decode');

diffStats('encode','decode');

format('%s is a string, %3.3d is a number','X',7);

formatTime('mm.dd.yyyy',43210);

isAscii('xyz');

//#isAscii
isAscii('xyz'&chars[180]);

isAscii('Läuft');

isUtf8('xyz');

//#isUtf8
isUtf8('xyz'&chars[180]);

isUtf8('Schräg');

parseTime('yyyy-mm-dd hh:nn','2000-01-01 03:43');

reverseString('Test');

//#regex.matches
regex.matches('This is a test','[T|t]est');

//#regex.matchComposite
regex.matchComposite('This is a test','[T|t]est');

//#regex.replace
regex.replace('A Test is a test','[T|t]est','rose');

//#regex.split
regex.split('A Test is a test','[e| ]');

toBoolean(0);

toBoolean(1.0);

toBoolean('true');

toBoolean(3);

toInt('32');

toInt(3.0);

toInt(3.1);

toInt(false);

toReal('3.212');

toReal(true);

toReal(3);

getOptions;

executor;

//#inspect
inspect('sudoku').{
  print('Package ID is: ',$L['id']) |
  print('Path         : ',$L['path']) |
  print('Uses         : ',$L['uses']) |
  $L['declares']
  .each(rule,rule[1,'type']&" rule:\t"&rule[0]&"\t"&rule[1,'location'])
  .join("\n")
  .print};

//Print with line breaks but without pretty printing
print("1\n2.0\n03.45");

//Tab triggers pretty printing - numbers are aligned at decimal dot or comma
print("1\n2.0\n03,45\t");

//Non-numbers are left aligned
print("1\tone\t|\n2.0\ttwo\t|\n03.45\tthree\t|");

//Use \v instead of \t for a tab of zero width
print("1\tone\v|\n2.0\ttwo\v|\n03.45\tthree\v|");

//Simple format: the number of placeholders must match the number of arguments
printf("%x is %d in hexadecimal form",123,123);

//You can adress placeholders by their zero based index
printf("%{$0}x is %{$0}d in hexadecimal form",123);

//Placeholders can be complex expressions
printf("sin(%{$0}s)=%{sin($0)}4.4g",1);

