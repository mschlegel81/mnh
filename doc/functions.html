<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MNH 5 - Functions</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Functions</h3>
<div align="right"><hr> </font></div>
<h3><a     href="#declarations">Declarations</a></h3>
<h3><a     href="#assignments">Assignments</a></h3>
<h3><a     href="#restrictions">Parameter restrictions</a></h3>
<h3><a     href="#variadic">Variadic functions</a></h3>
<h3><a     href="#beginEnd">Begin-End-Blocks</a></h3>
<h3><a     href="#modifiers">Modifiers</a></h3><ul>
<li><h4><a href="#privateMod">private</a></h4></li>
<li><h4><a href="#memoizedMod">memoized</a></h4></li>
<li><h4><a href="#synchronizedMod">synchronized</a></h4></li>
<li><h4><a href="#mutableMod">mutable</a></h4></li></ul>
<li><h4><a href="#localMod">local</a></h4></li></ul>
<div align="right"><hr> </font></div>
<h3><a name="declarations">Declarations</a></h3>
A function declaration follows the prototype <i>ruleId(pattern)</i><code>-></code><i>ruleBody</i>.<br>
The declaration may be preceded by <a href="#modifiers">modifiers</a>, the pattern may be empty (producing a nullary function).<br>
<i>Patterns</i> form a means for case distinction. They may also serve to make the function "somewhat typesafe". The most primitive pattern element is just an identifier, without any restrictions:<code>
  f(x)->sin(1/x);</code><br>
Patterns may consist of any number of elements:<code>
  g(a,b,c,d,e,f,g)->a+b*c/d^e-f*g;</code><br>
Please have a look at <a href="#restrictions">Parameter restrictions</a> for more sophisticated patterns.

<h3><a name="assignments">Assignments</a></h3>
An assignment follows the prototype <i>ruleId(pattern)</i><code>:=</code><i>ruleBody</i>.<br>
As you can see it is identical to the declaration prototype apart from the assignment operator. Behaviour is only almost identical: An assignment is evaluated "<i>on declaration</i>", while a declaration is evaluated only when it 
is called. This is important when you take side effects into account. A reasonable example would be:<code>
  pi:=4*arctan(1);</code><br>
This defines pi and is evaluated only once. 

<h3><a name="restrictions">Parameter restrictions</a></h3>
Parameter restrictions fall in three categories:<ul>
  <li> Type checks (see <a href="operators.html#typecheckOps"> operators</a>)
  <li> Comparison with a literal (see <a href="operators.html#compOps"> Comparators</a>)
  <li> Comparison with another parameter
</ul>
Apart from the type checks defined as unary operator there are two type checks which look like comparisons:<ul>
  <li> <code>x=[]</code> matches, if x is an empty list
  <li> <code>x<>[]</code> matches, if x is a list but not empty
</ul>
If a rule has several subrules (i.e. there are several declarations with the same ID), the subrules are tested in order of their declaration and the first matching subrule will be applied.<br>
Example: <code>
  fib(i<=1)->1;                      //recursion terminates
  fib(i:int)->fib(i-1)+fib(i-2);     //recursion step
  fib(I:intList)->each(i,I,fib(i));  //vectorization
</code> 
There is a shorthand for tests on equality: the first comparand can be omitted:<br>
<code>  f(x=1)...;  </code> is eqivalent to <code>f(x)...;</code><br>
<code>  f(x=y,y)...;</code> is eqivalent to <code>f(y,y)...;</code><br>
<code>  f(x=[])...; </code> is eqivalent to <code>f([])...;</code><br>

<h3><a name="variadic">Variadic functions</a></h3>
Variadic functions can be defined using three dots (<code>...</code>) as last parameter in the function head.
This allows the function to accept any number of additional parameters.<br>
The trailing anonymous parameters can be referenced inside the function body by the pseudo-identifier <code>...</code>. An example for a variadic recursive function, printing out all parameters in a separate line wold be:<code>
  multiPrint->void;
  multiPrint(x,...)->print(x) | multiPrint@...;</code>

<h3><a name="beginEnd">Begin-End-Blocks</a></h3>
  
<i>Begin-End-Blocks</i> are a means to program in a prodedural manner. It looks as follows <code>
  begin
    <i>statement</i>
    <i>...</i>
    <i>statement</i>
    <i>result statement</i>
  end;  
</code> The last statement provides a result which is returned from the block. The other statements are executed before and only have an effect if they
have side effects. <br> Identifiers occuring as the left hand side of an assignment will be created in the current scope if (and only if) they
are declared with a <a href="#localMod">local</a>-modifier <b>or</b> cannot be found in any surrounding scope.
<br>A neat example demonstrating the usefulnes of this feature is calculation of a running sum of a numeric list:<code>
  runningSum(L:numericList)->begin
    local sum:=0;
    each(element,L,sum:=sum+element);
  end;
</code>This function makes use of the fact that the assignment-operator returns the value its right hand side.<br>
Note, that parallel processing via <code>pEach</code> is disabled within Begin-End-Blocks. Occuring <code>pEach</code>-statements will silently be converted
to <code>each</code>-statements.
    
<h3><a name="modifiers">Modifiers</a></h3>
<h4><a name="privateMod">private</a></h4>
The <i>private modifier</i> can be used to hide a subrule from importing packages.
Inside of the package containing the modified subrule it is usable as any other rule.

<h4><a name="memoizedMod">memoized</a></h4>
The <i>memoized modifier</i> enables caching for the complete rule; if one subrule of a rule is marked as memoized, then the complete rule is memoized.
<br>Caching means, that internally a hash map with key value pairs (<i>parameters</i>,<i>function result</i>) is created. For performance reasons this
map has a size limit - if this limit is exceeded, key-value-pairs are "forgotten" based on a mixed strategy combining least-recently-used and least-frequently-used approaches.<br>
Used appropriately, caching results in enormous speedup. <br>
Note that memoized functions do not work well with parallelized evaluations. This issue might be adressed in later versions.

<h4><a name="synchronizedMod">synchronized</a></h4>
The <i>synchronized modifier</i> protects a rule against parallel execution.<br>
This is desirable for functions with side effects, such as printing or modifying a <a href="#mutableMod">mutable</a> value.

<h4><a name="mutableMod">mutable</a></h4>
The <i>mutable modifier</i> allows for a rule to be mutable. The following restrictions apply:<ul>
  <li> A mutable rule also is private per definition </li>
  <li> A mutable rule also is not memoized per definition </li>
  <li> A mutable rule must have exactly one subrule </li>
  <li> A mutable rule must be nullary </li>
</ul>
Functions modifying the value of a mutable value should be <a href="#synchronizedMod">synchronized</a>.

<h4><a name="localMod">local</a></h4>
The <i>local modifier</i> ensures, that a variable is declared in the scope of the current <a href="#beginEnd">begin-end-blocks</a>. 
It is only allowed in this context. Local variables always are mutable.

<div align="right"><hr> </font></div>
</body>
</html>
