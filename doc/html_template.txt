<!--file style.css-->
body {
  padding-left: 1em;
  font-family: Georgia, "Times New Roman",
        Times, serif;
  color: black;
  background-color: #EEEEEE}
h1 {
  font-family: Helvetica, Geneva, Arial,
        SunSans-Regular, sans-serif }
code { font-family: Courier-New, Courier; white-space: pre }
a:link {
  color: #0000FF }
a:visited {
  color: #000066 }
address {
  margin-top: 1em;
  padding-top: 1em;
  border-top: thin dotted }
table { display: inline-table}
.oben    { vertical-align:top}
.red {color:#FF0000}
.ruleHead  { vertical-align:top; background-color: #DDDDDD}
.identifier{color:#0000FF}
.builtin{color:#0000FF;font-weight:bold}
.modifier{color:#FF8800;font-weight:bold}
.stringLiteral{color:#008800}
.literal{color:#FF0000}
.operator{color:#000088;font-weight:bold}
.comment{color:#666666;font-style:italic}
<!--file index.html-->
<!--begin commonHead-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html><head><link rel="stylesheet" href="style.css" type="text/css"><META http-equiv="Content-Type" content="text/html; charset=ASCII">
<!--end-->
<!--commonHead-->
<title>MNH 5</title>
</head>
<body>
<h2 align="center">MNH 5</h2>
<div align="right"> <hr> </div>
<h4><a href="quickstart.html">Quick start</a></h4>
<h4><a href="types.html">Types</a></h4>
<h4><a href="operators.html">Operators</a></h4>
<h4><a href="functions.html">Functions</a></h4>
<h4><a href="each.html"><code>each</code> and <code>pEach</code></a></h4>
<h4><a href="builtin.html">Built-in Functions</a></h4>
<h4><a href="packages.html">User packages</a></h4>
<tr bgcolor="#FFFACD">
<!--begin commonFoot-->
<div align="right"> <hr> </div> </body> </html>
<!--end-->
<!--commonFoot-->
<!--file packages.html-->
<!--commonHead-->
<title>MNH 5 - Packages</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Packages</h3>
<div align="center"; class="red">Open the documentation from the GUI via Help -> "Open Documentation" to make sure it is up to date.</div>
<div align="right"><hr> </div>
<h3><a href="#usage">Usage</a></h3>
<ul>
  <li><h4><a href="#defining">Defining a package</a></h4></li>
  <li><h4><a href="#importing">Importing a package</a></h4></li>
  <li><h4><a href="#executables">Executable packages</a></h4></li>
  <li><h4><a href="#comments">Comments</a></h4></li>
  <li><h4><a href="#batchmode">Batch mode</a></h4></li>
</ul>
<h3><a href="#defined">Currently defined packages</a></h3>

<div align="right"><hr> </div>

<h3><a name="usage">Usage</a></h3>
Packages form the major means to structure your implementation so that parts of it can be reused.<br>
Each package is a collection of functions and expressions; each input to MNH is a package.<br>
Expressions in a package will only be executed in interactive mode.<br>
For details on how to define functions, see <a href="functions.html">MNH5 - Functions</a>
<h4><a name="defining">Defining a package</a></h4>
To define a package, just create a file with the extension <code>.mnh</code> (or even simpler: start typing in interactive mode). The following restrictions apply:
<ul>
  <li>The filenmae (without extension) should be a valid identifier, i.e. it should start with a letter.<br>This is because the filename wihtout extension will be interpreted as the package-identifier.
  <br>Packages violating this convention cannot be imported by other packages.</li>
  <li>The package must be in the search paths of importing packages (see <a href="#importing">Importing a package</a>).
  <li>The filename must not be any of the built-in pseudo packages' identifiers.</li>
</ul>

<h4><a name="importing">Importing a package</a></h4>
To import a package, start your package with a <i>use clause</i>, e.g.:<code>
<!--mnh-->
  USE basic;
<!--end-->
</code>
This will import the first package with a filename <code>basic.mnh</code> in the following folders:<ul>
  <li> The same folder as the importing package, or its subfolders </li>
  <li> The current executable's folders, or its subfolders </li>
  <li> The current working directory, or its subfolders </li>
</ul>
Having imported a package, you might run into naming conflicts. All rules can be accessed using either their name or qualified access via package.name, e.g.<code>
<!--mnh-->
   basic.sum([1,2,6]);
<!--end-->
</code>
<h4><a name="executables">Executable packages</a></h4>
A package is <i>executable</i> if it contains a rule called <code>main</code>.
Executable packages can be executed from the command line. If called as<code>
  mnh_console </code><i>packageName</i><code>.mnh
</code>the nullary main function will be executed. If additional parameters are given, the respective n-ary main rule will be executed, e.g.<code>
  mnh_console </code><i>packageName</i><code>.mnh </code><i>parameter_1<code> </code> parameter_2</i><br>
All input parameters will be passed as strings; consequently they must be converted to other types (e.g. using <code>softCast</code>) as needed.

<h4><a name="comments">Comments</a></h4>
A comment is any string starting with <code>//</code> and ending with the following line break.<br>
A <i>doc-</i>comment is a comment starting with <code>//*</code>. Doc-comments are always associated with the (sub-)rule following the comment.
They will be shown here (if the page is regenerated).<br>
Additionally, comments of the main rule are shown as help on the package on the command line, e.g.<br>
<code>  mnh_console -h </code><i>packageName</i><code>.mnh</code>

<h4><a name="batchmode">Batch mode</a></h4>
By default only the main rule is actually evaluated when a script is interpreted; in interactive mode on the other hand every statement is interpreted.<br>
To enable <i>batch mode</i>, use the special (pseuco-)comment <code>//!BATCH ON</code>. Batch mode can be disabled again using <code>//!BATCH OFF</code>.

<h3><a name="defined">Currently defined packages</a></h3>
<!--USERPKG-->
<!--commonFoot-->
<!--file builtin.html-->
<!--commonHead-->
<title>MNH 5 - Built-in functions</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Built-in functions</h3>
<div align="center"; class="red">Open the documentation from the GUI via Help -> "Open Documentation" to make sure it is up to date.</div>

<table border="0" align="center">
<!--example mnh.arity-->
 in> arity({3});
out> 0
 in> arity({sin($x)/$x});
out> 1
 in> arity({sin($x)/$y});
out> 2
     //For variadic functions only the non-optional parameters are counted:
 in> arity({printf('%X%%X%',$a,...)});
out> 1
<!--end-->
<!--example mnh.expression-->
 in> expression("$x-$x^2+$x^3")
out> {($x-$x^2+$x^3)}
 in> expression("")
!! >Ev.Error:  :1,1 The parsed expression appears to be empty
<!--end-->
<!--example mnh.not-->
 in> not(true)
out> false
 in> not([true, false, true])
out> [false,true,false]
 in> not({$x})
out> {not($x)}
 in> not(7)
out> -8
<!--end-->
<!--example mnh.parameterNames-->
 in> parameterNames({3})
out> []
 in> parameterNames({sin($x)/$x})
out> ["$x"]
 in> parameterNames({sin($x)/$y})
out> ["$x","$y"]
     //For variadic functions only the non-optional parameters are counted:
 in> parameterNames({printf("%X%%X%", $a, ...)})
out> ["$a"]
<!--end-->
<!--example mnh.ord-->
 in> ord(3)
out> 3
 in> ord(true)
out> 1
 in> ord(false)
out> 0
 in> ord("A")
out> 65
 in> ord("abc")
out> -1
 in> ord(2.1)
!! >Ev.Error:  :6,1 ord can only be applied to booleans, ints and strings
<!--end-->
<!--example mnh.softCast-->
 in> softCast("A")
out> "A"
 in> softCast('"B"')
out> "B"
 in> softCast(3)
out> 3
 in> softCast([1, "2", "true", "'TEXT'", "1.5", "2,6"])
out> [1,2,true,"TEXT",1.5,"2,6"]
<!--end-->
<!--example mnh.splitFileName-->
 in> splitFileName("../test.txt")
out> [["input","../test.txt"],["expanded","D:\\dev\\test.txt"],["relative","../test.txt"],["directory",".."],["filename","test.txt"],["extension",".txt"]]
<!--end-->
<!--example mnh.string-->
 in> string('a')
out> "a"
 in> string(234)
out> "234"
 in> string([1, 2.6, "a", true, {$x}])
out> '[1,2.6,"a",true,{$x}]'
<!--end-->
<!--example math.abs-->
 in> abs(-0.92)
out> 0.92
 in> abs(3)
out> 3
 in> abs({1+$x})
out> {abs(1+$x)}
<!--end-->
<!--example math.arccos-->
 in> arccos(-0.92)
out> 2.73887681200913
     //Out of function domain
 in> arccos(3)
out> Nan
 in> arccos({1+$x})
out> {arccos(1+$x)}
<!--end-->
<!--example math.arcsin-->
 in> arcsin(-0.92)
out> -1.16808048521424
     //Out of function domain
 in> arcsin(3)
out> Nan
 in> arcsin({1+$x})
out> {arcsin(1+$x)}
<!--end-->
<!--example math.tan-->
 in> tan(-0.92)
out> -1.31326369932025
 in> tan(3)
out> -0.142546543074278
 in> tan({1+$x})
out> {tan(1+$x)}
 in> tan(2*arctan(1))
out> 1.63317787283838E16
<!--end-->
<!--example math.arctan-->
 in> arctan(-0.92)
out> -0.74375558429886
 in> pi:=4*arctan(1)
 in> pi
out> 3.14159265358979
 in> arctan({$x})
out> {arctan($x)}
<!--end-->
<!--example math.argMax-->
 in> argMax(sin([0..10]))
out> 8
 in> argMax([1, 3, 3, 0, 2])
out> 1
<!--end-->
<!--example math.argMin-->
 in> argMin(sin([0..10]))
out> 5
 in> argMin([1, 3, 3, 0, 2])
out> 3
<!--end-->
<!--example math.ceil-->
 in> ceil(20/3)
out> 7
 in> ceil([0..3]/3)
out> [0,1,1,1]
 in> ceil([0..3]/3, 2)
out> [0.0,0.34,0.67,1.0]
 in> ceil(20/3, [-1..3])
out> [10.0,7.0,6.7,6.67,6.667]
<!--end-->
<!--example math.floor-->
 in> floor(20/3)
out> 6
 in> floor([0..3]/3)
out> [0,0,0,1]
 in> floor([0..3]/3, 2)
out> [0.0,0.33,0.66,1.0]
 in> floor(20/3, [-1..3])
out> [0.0,6.0,6.6,6.66,6.666]
<!--end-->
<!--example math.round-->
 in> round(20/3)
out> 7
     //Numbers with ambiguous rounding result are rounded towards even numbers
 in> round([0.5, 1.5, 2.5, 3.5])
out> [0,2,2,4]
 in> round([0..3]/3, 2)
out> [0.0,0.33,0.67,1.0]
 in> round(20/3, [-1..3])
out> [10.0,7.0,6.7,6.67,6.667]
<!--end-->
<!--example math.isInRange-->
 in> isInRange(7, 0, 10)
out> true
     //You can use infinite ranges
 in> isInRange(7, 0.3,  Inf)
out> true
     //The first argument can be a list
 in> isInRange([0..9]/10, 0.3, 0.57)
out> [false,false,false,true,true,true,false,false,false,false]
<!--end-->
<!--example math.isInfinite-->
 in> isInfinite(Nan)
out> false
 in> isInfinite(+Inf)
out> true
 in> isInfinite(-Inf)
out> true
 in> isInfinite([-3.4344, Nan, +Inf])
out> [false,false,true]
<!--end-->
<!--example math.isNan-->
 in> isNan(Nan)
out> true
 in> isNan(+Inf)
out> false
 in> isNan(-Inf)
out> false
 in> isNan([-3.4344, Nan, +Inf])
out> [false,true,false]
<!--end-->
<!--example math.cos-->
 in> cos(-0.92)
out> 0.605820156643463
 in> cos(3)
out> -0.989992496600446
 in> cos({1+$x})
out> {cos(1+$x)}
<!--end-->
<!--example math.exp-->
 in> exp(-0.92)
out> 0.398519041084514
 in> exp(3)
out> 20.0855369231877
 in> exp({1+$x})
out> {exp(1+$x)}
<!--end-->
<!--example math.ln-->
 in> ln(-0.92)
out> Nan
 in> ln(3)
out> 1.09861228866811
 in> ln({1+$x})
out> {ln(1+$x)}
<!--end-->
<!--example math.sin-->
in> sin(-0.92)
out> -0.795601620036366
 in> sin(3)
out> 0.141120008059867
 in> sin({1+$x})
out> {sin(1+$x)}
<!--end-->
<!--example math.sqr-->
 in> sqr(-0.92)
out> 0.8464
 in> sqr(3)
out> 9
 in> sqr({1+$x})
out> {sqr(1+$x)}
<!--end-->
<!--example math.sqrt-->
 in> sqrt(-0.92)
out> Nan
 in> sqrt(3)
out> 1.73205080756888
 in> sqrt({1+$x})
out> {sqrt(1+$x)}
<!--end-->
<!--example math.sign-->
 in> sign(-0.92)
out> -1
 in> sign(3)
out> 1
 in> sign({1+$x})
out> {sign(1+$x)}
<!--end-->
<!--example math.max-->
 in> max(["a".."z"])
out> "z"
 in> max([0..9]/2)
out> 4.5
 in> max(true, false)
out> true
<!--end-->
<!--example math.min-->
 in> min(["a".."z"])
out> "a"
 in> min([0..9]/2)
out> 0.0
 in> min(true, false)
out> false
<!--end-->
<!--example strings.copy-->
 in> copy("abcd", 1, 3)
out> "bcd"
<!--end-->
<!--example strings.escape-->
 in> escape("a")
out> '"a"'
 in> escape("\t")
out> '"\\t"'
<!--end-->
<!--example strings.format-->
     //Use %X% for a left aligned output.
     //A number after the X will be interpreted as text width
 in> format("%X5% is a string or something left aligned", true)
out> "true  is a string or something left aligned"
     //Use %I% for right aligned output.
     //A number after the I will be interpreted as text width
 in> format("%I5% is a string or something right aligned", true)
out> " true is a string or something right aligned"
 in> format("%I%", 3)
out> "3"
     //You can use special placeholders to format dates and times.
     //Note that "mm" corresponds to month and "nn" corresponds to minutes.
 in> format("%dd.mm.yyyy%", 3.21)
out> "02.01.1900"
 in> format("%hh:nn:ss%", 3.21)
out> "05:02:24"
     //Use a "picture clause" to format floating point numbers
 in> format("%00.000%", 3.21)
out> "03.210"
     //Use # to specify optionally visible digits.
     //If the second (or further) arguments are lists, the result will be a list.
 in> format("%#0.00##%", [3.21567, 5])
out> [" 3.2157"," 5.00  "]
<!--end-->
<!--BUILTIN-->
</table>
<!--commonFoot-->
<!--file operators.html-->
<!--commonHead-->
<title>MNH 5 - Operators</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Operators</h3>
<div align="right"><hr> </div>
<h3><a href="#scalarOps"> Scalar operators</a></h3>
<ul>
  <li><h4><a href="#arithOps"> Arithmetic operators</a></h4></li>
  <li><h4><a href="#compOps"> Comparators </a></h4></li>
  <li><h4><a href="#logOps"> Logical operators </a></h4></li>
  <li><h4><a href="#stringOps"> String concatenation</a></h4></li>
</ul>
<h3><a href="#listOps"> List operators </a></h3>
<h3><a href="#iifOps"> The ternary inline-if operator</a></h3>
<h3><a href="#typecheckOps"> Type check operators</a></h3>
<h3><a href="#assignmentOps"> Assignment operators</a></h3>
<h3><a href="#cStyleOps"> C-Style operators</a></h3>
<div align="right"><hr> </div>

<h3><a name="scalarOps"> Scalar operators<a></h3>
Scalar operators are those operators which take the form: <code>scalar o scalar -> scalar</code><br>
All of those operators apart from <code>==</code>, <code>AND</code> and <code>OR</code> are overloaded for lists according to the following prototype (all occuring variables are scalars and none is an expression-literal):<code>
[<span class="identifier">x0</span>,<span class="identifier">x1</span>,<span class="operator">...</span>] <span class="operator">o</span>  <span class="identifier">y</span>          <span class="operator">-></span> [<span class="identifier">x0</span> <span class="operator">o</span> <span class="identifier">y</span> , <span class="identifier">x1</span> <span class="operator">o</span> <span class="identifier">y</span> , <span class="operator">...</span>]
 <span class="identifier">x</span>          <span class="operator">o</span> [<span class="identifier">y0</span>,<span class="identifier">y1</span>,<span class="operator">...</span>] <span class="operator">-></span> [<span class="identifier">x</span>  <span class="operator">o</span> <span class="identifier">y0</span>, <span class="identifier">x</span>  <span class="operator">o</span> <span class="identifier">y1</span>, <span class="operator">...</span>]
[<span class="identifier">x0</span>,<span class="identifier">x1</span>,<span class="operator">...</span>] <span class="operator">o</span> [<span class="identifier">y0</span>,<span class="identifier">y1</span>,<span class="operator">...</span>] <span class="operator">-></span> [<span class="identifier">x0</span> <span class="operator">o</span> <span class="identifier">y0</span>, <span class="identifier">x0</span> <span class="operator">o</span> <span class="identifier">y1</span>, <span class="operator">...</span>]
</code>The last one will work if (and only if) both operators have the same number of list elements.<br>
While this is handy in most situations, there are some counter intutive consequences:<ul>
  <li> Lazy boolean operators behave differently from non-lazy operators (see <a href="#logOps"> Logical operators </a>)</li>
  <li> Equals behaves strangely<br>Comparisons of lists with the <code>=</code>-comparator will return lists of booleans, e.g. <code>
<!--mnh-->
  [1,2]=[1,2] -> [true,true]
<!--end-->
</code>
As a fallback solution, the <code>==</code>-comparator can be used, which will return a scalar <code>true</code> if the operands have the same size and all list elements are equal, e.g. <code>
<!--mnh-->
  [1,2]==[1,2] -> true
<!--end-->
</code>
  </li>
  </ul>
For expression-literals, all operators will be used to expand the expression to a new expression-literal:<code>
{<span class="identifier">expr</span>} <span class="operator">o</span> <span class="identifier">X</span> <span class="operator">-></span> {(<span class="identifier">expr</span> <span class="operator">o</span> <span class="identifier">X</span>)}
</code>

<h4><a name="#arithOps"> Arithmetic operators</a></h4>
<table border="0">
<tr><td><code>+</code></td><td><h5>Addition</h5></td></tr><tr><td></td><td>
This is the common addition operator, which also doubles as an unary "neutral" operator.<br> As in many modern languages, the operator is overloaded for string concatenation.
In contrast to languages as C or Java, it does not allow for concatenation of non-strings and strings.<br>
If both operands are integers, the result will be an integer. <br>
If both operands are numeric and at least one of them is real, the result will be a real number.<br>
Examples:<code>
<!--mnh-->
 in> 1+5
out> 6

 in> [1, 2.4, 3]+5
out> [6, 7.4, 8]

 in> 1+[5,6.2,7]
out> [6, 7.2, 8]

 in> [1.5, 2, 3]+[5, 6, 7.106]
out> [6.5, 8, 10.106]

 in> "a"+"b"
out> "ab"

 in> [1,2,3]+[5,6]
<!--end-->
<span class="red">!! >Ev.Error:  :?,? Invalid list lengths 3 and 2 given for operator +</span>
</code>
</td></tr>
<tr><td><code>-</code></td><td><h5>Subtraction</h5></td></tr><tr><td></td><td>
This is the common subtraction operator, which also doubles as unary negation.<br>
If both operands are integers, the result will be an integer. <br>
If both operands are numeric and at least one of them is real, the result will be a real number.
</td></tr>
<tr><td><code>*</code></td><td><h5>Multiplication</h5></td></tr><tr><td></td><td>
This is the common multiplication operator.<br>
If both operands are integers, the result will be an integer. <br>
If both operands are numeric and at least one of them is real, the result will be a real number.
</td></tr>
<tr><td><code>/</code></td><td><h5>Real division</h5></td></tr><tr><td></td><td>
This is the common division operator.<br>
If both operands are numeric the result is a real number.
</td></tr>
<tr><td><code>**</code>, <code>^</code></td><td><h5>Potentiation</h5></td></tr><tr><td></td><td>
This is the potentiation operator.<br>
The result type will be the simplest possible type possible for representing the analytic result.<br>
Examples: <code>
<!--mnh-->
 in> 2^2
out> 4 //The result is an integer
 in> 2^-2
out> 0.25 //The result is a real number
<!--end-->
</code>
</td></tr>
<tr><td><code>div</code></td><td><h5>Integer division</h5></td></tr><tr><td></td><td>
Inspired by Pascal.
</td></tr>
<tr><td><code>mod</code></td><td><h5>Integer modulo</h5></td></tr><tr><td></td><td>
Inspired by Pascal.
</td></tr>
</table>

<h4><a name="compOps"> Comparators</a></h4>
Comparators are implemented, so that they return a boolean or a list of booleans for most cases, the only exception being comparison of lists of incompatible sizes.<br>
Consequently all comparators <code>o</code> must be read as<code>
x o y -> [x and y are naively comparable] and (x o y)</code><br>
As a further consequence, the following expressions will return the same result only if x and y are comparable:<code>
<!--mnh-->
x > y
not(x<=y)
<!--end-->
</code><br>
Comparators can be used as in mathematical notation, e.g. <code>
<!--mnh-->
x < y < z
<!--end-->
</code> is identical to <code>
<!--mnh-->
x < y and y < z
<!--end-->
</code>
For comparators in function definitions see <a href="functions.html">MNH5 - Function definitions</a>.
<br>
<table border="0">
<tr><td><code>= </code></td><td><h5>Scalar equals</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and equal. <br> Examples: <code>
<!--mnh-->
 in> 1=1
out> true
 in> 2=2.0
out> true
 in> 3=[3]
out> [true]
 in> 4=[4,5,6]
out> [true,false,false]
 in> [7,8,9]=[7,8,9]
out> [true,true,true]
 in> "a"=3
out> false
<!--end-->
</code></td></tr>
<tr><td><code>==</code></td><td><h5>List equals</h5></td></tr><tr><td></td><td>
Returns a scalar boolean.<br>Returns true if the comparands are comparable, have the same number of list elements and all list elements are equal.<br>
<code>
<!--mnh-->
[x0,x1,...] == [y0,y1,...]  ->  x0 == y0 AND x1 == y1 AND ...
<!--end-->
</code>
For scalars the behavior is the same as the scalar equals'.<br>Examples: <code>
<!--mnh-->
 in> 1==1
out> true
 in> 2==2.0
out> true
 in> 3==[3]
out> false
 in> 4==[4,5,6]
out> false
 in> [7,8,9]==[7,8,9]
out> true
 in> "a"==3
out> false
<!--end-->
</code></td></tr>
<tr><td><code><></code>, <code>!=</code></td><td><h5>Not equals</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and not equal.<br>
In conjuction with equals, one might define a function to find out if two variables are comparable:<br><code>
<!--mnh-->
 in> allTrue(x)->x==true OR trueCount(x)=size(x)
 in> areComparable(x,y)->allTrue(x=y or x<>y)

 in> areComparable(3,4.0)
out> true
 in> areComparable(3,[1,2,"a"])
out> false
<!--end-->
</code></td></tr>
<tr><td><code>> </code></td><td><h5>Greater than</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and the left hand comparand is lesser than the right hand operand.</td></tr>
<tr><td><code>< </code></td><td><h5>Lesser than</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and the left hand comparand is greater than the right hand operand.</td></tr>
<tr><td><code>>=</code></td><td><h5>Greater-or-equal</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and the left hand comparand is greater than the right hand operand or both comparands are equal.</td></tr>
<tr><td><code><=</code></td><td><h5>Lesser-or-equal</h5></td></tr><tr><td></td><td>
Returns a boolean or a list of booleans.<br>Returns true if the comparands are comparable and the left hand comparand is lesser than the right hand operand or both comparands are equal.</td></tr>
</table>

<h4><a name="logOps">Logical operators</a></h4>
<table border="0">
<tr><td><code>and</code></td><td><h5>Logical or bitwise and</h5></td></tr><tr><td></td><td>
Examples: <code>
<!--mnh-->
 in> true and false
out> false
 in> 3 and 6
out> 2
 in> 1 and [1..5]
out> [1,0,1,0,1]
 in> false and 3
<!--end-->
<span class="red">!! >Ev.Error:  :?,? Operator and is not supported for types boolean and int</span>
</code></td></tr>
<tr><td><code>or</code></td><td><h5>Logical or bitwise or</h5></td></tr><tr><td></td><td>
Examples: <code>
<!--mnh-->
 in> true or false
out> true
 in> 3 or 6
out> 7
 in> 1 or [1..5]
out> [1,3,3,5,5]
 in> false or 3
<!--end-->
<span class="red">!! >Ev.Error:  :?,? Operator or is not supported for types boolean and int</span>
</code></td></tr>
<tr><td><code>xor</code></td><td><h5>Logical or bitwise exclusive-or</h5></td></tr><tr><td></td><td>
Examples: <code>
<!--mnh-->
 in> true xor false
out> true
 in> 3 xor 6
out> 5
 in> 1 xor [1..5]
out> [0,3,2,5,4]
 in> false xor 3
<!--end-->
<span class="red">!! >Ev.Error:  :?,? Operator xor is not supported for types boolean and int</span>
</code></td></tr>
<tr><td><code>AND</code></td><td><h5>Logical lazy and</h5></td></tr><tr><td></td><td>
Lazy operators are executed <i>extremely</i> lazy. The left-hand-side operand must be a scalar boolean.
For any right-hand-side expression <code>RHS</code> the behavior is as follows:<code>
<!--mnh-->
  true  AND RHS -> RHS
  false AND RHS -> false
<!--end-->
</code>
Or generally:<code>
<!--mnh-->
  x AND y -> x ? y : x;
<!--end-->
</code>
Used as aggregator in an <code>each</code> or <code>pEach</code> construct, the loop over all elements is cancelled as soon as the first <code>false</code> is encountered.
</td></tr>
<tr><td><code>OR</code></td><td><h5>Logical lazy or</h5></td></tr><tr><td></td><td>
Lazy operators are executed <i>extremely</i> lazy. The left-hand-side operand must be a scalar boolean.
For any right-hand-side expression <code>RHS</code> the behavior is as follows:<code>
<!--mnh-->
  true  OR RHS -> true
  false OR RHS -> RHS
<!--end-->
</code>
Or generally:<code>
<!--mnh-->
  x OR y -> x ? x : y;
<!--end-->
</code>
Used as aggregator in an <code>each</code> or <code>pEach</code> construct, the loop over all elements is cancelled as soon as the first <code>true</code> is encountered.
</td></tr>
</table>

<h4><a name="stringOps">String concatenation</a></h4>
The <code>&</code>-operator for string concatenation (inspired from Excel) was introduced as the preferred method to concatenate strings.<br>
<table border="0">
<tr><td><code>&</code></td><td><h5>String concatenation</h5></td></tr><tr><td></td><td> </td></tr>
</table>
<h3><a name="listOps">List operators</a></h3>
<table border="0">
<tr><td><code>|</code></td><td><h5>List concatenation</h5></td></tr><tr><td></td><td>
The list concatenation operator can be used to construct lists. The general behavior is as follows<code>
<!--mnh-->
   x | y -> [x,y];
   x |[y]-> [x,y];
  [x]| y -> [x,y];
  [x]|[y]-> [x,y];
<!--end-->
</code>
However the result does not have to be a flat list; e.g.<code>
<!--mnh-->
  x |[[y]] -> [x,[y]];
<!--end-->
</code>
</td></tr>

<tr><td><code>in</code></td><td><h5>in-operator</h5></td></tr><tr><td></td><td>
The in-operator (inspired by SQL) tests, if the left hand side operand is contained in the right hand side operand.<br>
For obvious reasons the right hand side operands must be a list.<br>
<code>
<!--mnh-->
x in [y0,y1,...] -> x==y0 or x==y1 or ...;
<!--end-->
</code> or, if you are already famliar with the <a href="each.html">each-construct</a>:<code>
<!--mnh-->
x in Y -> each(y,Y,or,x==y);
<!--end-->
</code>
</td></tr>
<tr><td><code>%</code></td><td><h5>Level 1 extraction operator</h5></td></tr><tr><td></td><td>
The extraction operator can be used to access list items by their index (starting with 0) or by a boolean mask. The right hand operand must be an integer, a list of integers or a list of booleans with the same
number of elements as the left hand side operand:<code>
<!--mnh-->
  ["a","b","c"]%0                 -> "a";
  ["a","b","c"]%[true,false,true] -> ["a","c"];
  ["a","b","c"]%[2,1,0]           -> ["c","b","a"];
<!--end-->
</code>
Another possible use of the extraction-operator is access to Key-Value lists, i.e. nested lists of the form <code>[["key1",value1],["key2",value2],...]</code>. You can use the key as right hand side operand to obtain the
corresponding value (or the first of such if there are more than one):<code>
<!--mnh-->
  [["a",1],["b",2]]%"a" -> 1;
<!--end-->
</code>
</td></tr>
<tr><td><code>%%</code></td><td><h5>Level 2 extraction operator</h5></td></tr><tr><td></td><td>
The level 2 extraction operator behaves similar to the level 1 extraction operator but instead creates a list of sublists:<code>
<!--mnh-->
  [X0,X1,X2,...]%%Y -> [X0%Y,X1%Y,X2%Y,...]
<!--end-->
</code>
</td></tr>

<tr><td><code>%%%</code></td><td><h5>Level 3 extraction operator</h5></td></tr><tr><td></td><td>
The level 3 extraction operator behaves similar to the level 1 extraction operator but instead creates a list of sublists:<code>
<!--mnh-->
  [X0,X1,X2,...]%%%Y -> [X0%%Y,X1%%Y,X2%%Y,...]
<!--end-->
</code>
</td></tr>

<tr><td><code>%%%%</code></td><td><h5>Level 4 extraction operator</h5></td></tr><tr><td></td><td>
The level 4 extraction operator behaves similar to the level 1 extraction operator but instead creates a list of sublists:<code>
<!--mnh-->
  [X0,X1,X2,...]%%%%Y -> [X0%%%Y,X1%%%Y,X2%%%Y,...]
<!--end-->
</code>
</td></tr>

<tr><td><code>@<code></td><td><h5>List-to-parameter operator</h5></td></tr><tr><td></td><td>
The list-to-parameter operator can be used for alternative parameter passing. It converts the list (expression or literal) following the operator to a parameter list for the function preceding the operator.<br>
The following calls are equivalent:<code>
<!--mnh-->
  f(1,2,3,4,5);
  f@[1,2,3,4,5];
  f@[1..5];
<!--end-->
</code>
This can also be applied to implement recursive variadic functions. The following functions <code>sum1</code> and <code>sum2</code> will show the same behaviour, returning the sum of all given parameters:<code>
<!--mnh-->
  sum1->0;
  sum1(x,...)->x+sum1@...;

  sum2->0;
  sum2(...)->each(x,...,+);
<!--end-->
</code>
</td></tr>
</table>

<h3><a name="iifOps"> The ternary inline-if operator</a></h3>
The ternary inline-if operator is inspired by C and it's successors.<br>Syntax is <code>B ? X : Y</code>, where <code>B</code> is a boolean scalar, <code>X</code> is the result if <code>B</code> evaluates to true and <code>Y</code> is
the result if <code>B</code> evaluates to false.<br>
Note that <code>B</code> must be a boolean scalar; boolean lists are not allowed.<br>
Lazy evaluation is employed, i.e. <code>X</code> is evaluated only if <code>B</code> is true and <code>Y</code> is evaluated only if <code>B</code> is false.

<h3><a name="typecheckOps"> Type check operators</a></h3>
Type check operators can be employed to test a value or an expression for it's type; they return boolean scalars, true if the types match. <br>Syntactically type checks are unary operators in postfix notation.
<br>The following type checks are defined:<code>
<!--mnh-->
  :scalar
  :list
  :boolean
  :booleanList
  :int
  :intList
  :real
  :realList
  :string
  :stringList
  :numeric
  :numericList
  :expression
<!--end-->
</code><br>
Examples: <code>
<!--mnh-->
   in> checkedType(x)->
         (x:scalar      ? 'scalar'      : void)|
         (x:list        ? 'list'        : void)|
         (x:boolean     ? 'boolean'     : void)|
         (x:booleanList ? 'booleanList' : void)|
         (x:int         ? 'int'         : void)|
         (x:intList     ? 'intList'     : void)|
         (x:real        ? 'real'        : void)|
         (x:realList    ? 'realList'    : void)|
         (x:string      ? 'string'      : void)|
         (x:stringList  ? 'stringList'  : void)|
         (x:numeric     ? 'numeric'     : void)|
         (x:numericList ? 'numericList' : void)|
         (x:expression  ? 'expression'  : void);

   in> checkedType(3)
  out> ["scalar","int","numeric"]
   in> checkedType([1, 2.4, 5])
  out> ["list","numericList"]
   in> checkedType(["A", true, 5])
  out> ["list"]
<!--end-->
</code>

<h3><a name="assignmentOps"> Assignment operators</a></h3>
For sake of completeness we also list the assignment operator and declaration operator here, even though they are not implemented as operators but as special constructs with side effects.
<br>For details on user defined functions see <a href="functions.html">MNH5 - Function definitions</a>.<br>
<table border="0">
<tr><td><code>-></code></td><td><h5>Declaration operator</h5></td></tr><tr><td></td><td>
Declares a function, returning nothing.</td></tr>
<tr><td><code>:=</code></td><td><h5>Assignment operator</h5></td></tr><tr><td></td><td>
Declares a function and resolves the right-hand-side immediately, returning nothing.<br>
It can also be used to assign a value to a mutable rule or a block-local variable, returning the value after assigning:<code>
<!--mnh-->
  mutable last_x_in_f:=void;
  f(x)->print('Last x was: ',last_x_in_f) and
        print('This x is : ',last_x_in_f:=x);
<!--end-->
</code> </td></tr>
</table>

<h3><a name="cStyleOps"> C-Style operators</a></h3>
The following C-Style operators are supported: <ul>
  <li> <code>+=</code> Adds the right-hand-side to the left-hand-side and returns the new value. </li>
  <li> <code>-=</code> Subtracts the right-hand-side from the left-hand-side and returns the new value. </li>
  <li> <code>*=</code> Multiplies the right-hand-side with the left-hand-side and returns the new value. </li>
  <li> <code>/=</code> Divides the right-hand-side by the left-hand-side and returns the new value. </li>
  <li> <code>&=</code> String-Concatenates the right-hand-side with the left-hand-side and returns the new value. </li>
  <li> <code>|=</code> Append the left-hand-side to the right-hand-side and returns the new value. </li>
</ul>
While the first 4 of the above are just "syntactic sugar" and can be equivalently expressed with the operators given in the previous sections,
the latter 2 additionally allow for specific optimizations, making e.g. the operation <code>L|=x;</code> faster than <code>L:=L|x;</code> (though they still are semantically equivalent).

<!--commonFoot-->
<!--file functions.html-->
<!--commonHead-->
<title>MNH 5 - Functions</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Functions</h3>
<div align="right"><hr> </div>
<h3><a     href="#calls">Calls</a></h3>
<h3><a     href="#declarations">Declarations</a></h3>
<h3><a     href="#assignments">Assignments</a></h3>
<h3><a     href="#restrictions">Parameter restrictions</a></h3>
<h3><a     href="#variadic">Variadic functions</a></h3>
<h3><a     href="#beginEnd">Begin-End-Blocks</a></h3>
<h3><a     href="#modifiers">Modifiers</a></h3><ul>
<li><h4><a href="#privateMod">private</a></h4></li>
<li><h4><a href="#memoizedMod">memoized</a></h4></li>
<li><h4><a href="#synchronizedMod">synchronized</a></h4></li>
<li><h4><a href="#mutableMod">mutable</a></h4></li>
<li><h4><a href="#localMod">local</a></h4></li></ul>
<div align="right"><hr> </div>
<h3><a name="calls">Calls</a></h3>
To keep it short:<ul>
<li><b>Calling convention</b><br>
All variables are immutable or when they are not, they behave as immutable variables. Consequently all parameters are passed as references. Trying to assign values passed parameters will cause an error.
<br>
Every function <code>f</code> can be called with any number of parameters; matching parameters will lead to evaluation of some kind, mismatching parameters
will lead to an error output.</li>
<li><b>Omitting parameters</b><br>A nullary function can be calles with or without parameters, so the following statements will behave the same:<code>
<!--mnh-->
  someFunction;
  someFunction();
<!--end-->
</code>
If <code>someFunction</code> returns a nullary expression, consider the following:<code>
<!--mnh-->
   in> someFunction :={1+2*3};
   in> someFunction;
  out> {(1+2*3)}
   in> someFunction();
  out> {(1+2*3)}
       //First evaluate someFunction then evaluate the returned expression
   in> someFunction()();
  out> 7           
<!--end-->
</code>
If however <code>someOtherFunction</code> returns an unary expression the behaviour is slightly different:<code>
<!--mnh-->
   in> someOtherFunction:={$x/2};
       //As above
   in> someOtherFunction();
  out> {($x/2)}
       //As above, passing (1) as parameter list to the returned expression
   in> someOtherFunction()(1);
  out> 0.5
       //Fallback behaviour: someOtherFunction cannot be applied to parameter list (1)
       //  but the returned expression can, so it is interpreted as the previous call
   in> someOtherFunction(1);
  out> 0.5
<!--end-->
</code>
</li><li><b>Visibility</b><br>
Visibility is handled as in Pascal, i.e. a local function definition hides all imported functions with the same name. <br>
If a function of the same name is defined in more than one used package, the definition in the last imported package hides previous definitions.<br>
To access a "hidden" function, you can access it by fully qualifying it via <code><i>packageName</i>.<i>functionName</i></code>.<br>
Example: Define a function returning the "square of a string", using the builtin function as a fallback:<code>
<!--mnh-->
  sqr(s:string):=string(math.sqr(softCast(s)));
  sqr(x)->math.sqr(x);
<!--end-->
</code>
</li>
<li><b>Pseudo-Object-Notation</b><br>Even though MNH is not object oriented it supports <i>(Pseudo-)Object-Notation</i>. This means that for some function <code>f</code> the
following statements are equivalent: <code>
<!--mnh-->
  f(x);
  x.f;
<!--end-->
</code>
This can improve readability a lot. For example consider the following equivalent statements:<code>
<!--mnh-->
  sort(trim(replace(fileLines('input.txt'),'x',' ')),{length($x)<=length($y)});
  fileLines('input.txt').replace('x',' ').trim.sort({length($x)<=length($y)});
<!--end-->
</code>
While the first one is virtually unreadable without bracket highlighting, the secon one quite clearly reads: "Read all lines from file 'input.txt', 
then replace every ocurring 'x' by a space, then trim each line, then sort the lines by ascending length.".<br>
This notation can be ambiguous however, since in <code>a.b</code> identifier <code>a</code> can either denote a package (so <code>a.b</code> is a fully qualified function) or
a local function or variable (so <code>a.b</code> is interpreted as <code>b(a)</code>). This is resolved by favouring the first interpretation: if there is an imported package "a", it will be used.
</li>
</ul>

<h3><a name="declarations">Declarations</a></h3>
A function declaration follows the prototype <i>ruleId(pattern)</i><code>-></code><i>ruleBody</i>.<br>
The declaration may be preceded by <a href="#modifiers">modifiers</a>, the pattern may be empty (producing a nullary function).<br>
<i>Patterns</i> form a means for case distinction. They may also serve to make the function "somewhat typesafe". The most primitive pattern element is just an identifier, without any restrictions:<code>
<!--mnh-->
  f(x)->sin(1/x);
<!--end-->
</code>
Patterns may consist of any number of elements:<code>
<!--mnh-->
  g(a,b,c,d,e,f,g)->a+b*c/d^e-f*g;
  randomDigit->floor(random*10);
<!--end-->
</code>
Please have a look at <a href="#restrictions">Parameter restrictions</a> for more sophisticated patterns.

<h3><a name="assignments">Assignments</a></h3>
An assignment follows the prototype <i>ruleId(pattern)</i><code>:=</code><i>ruleBody</i>.<br>
As you can see it is identical to the declaration prototype apart from the assignment operator. Behaviour is only almost identical: An assignment is evaluated "<i>on declaration</i>", while a declaration is evaluated only when it
is called. This is important when you take side effects into account. A reasonable example would be:<code>
<!--mnh-->
  pi:=4*arctan(1);
<!--end-->
</code>
This defines pi and is evaluated only once.<br>
A less reasonable example would be the following declaration - a "random" number which stays the same during evaluation:<code>
<!--mnh-->
  constantRandom:=random;
<!--end-->
</code>
<h3><a name="restrictions">Parameter restrictions</a></h3>
Parameter restrictions fall in three categories:<ul>
  <li> Type checks (see <a href="operators.html#typecheckOps"> operators</a>)
  <li> Comparison with a literal (see <a href="operators.html#compOps"> Comparators</a>)
  <li> Comparison with another parameter
</ul>
Apart from the type checks defined as unary operator there are two type checks which look like comparisons:<ul>
  <li> <code>x=[]</code> matches, if x is an empty list
  <li> <code>x<>[]</code> matches, if x is a list but not empty
</ul>
If a rule has several subrules (i.e. there are several declarations with the same ID), the subrules are tested in order of their declaration and the first matching subrule will be applied.<br>
Example: <code>
<!--mnh-->
  fib(i<=1)->1;                      //recursion terminates
  fib(i:int)->fib(i-1)+fib(i-2);     //recursion step
  fib(I:intList)->each(i,I,fib(i));  //vectorization
<!--end-->
</code>
There is a shorthand for tests on equality: the first comparand can be omitted. The following pairs of function heads are equivalent:<code>
<!--mnh-->
  f(x==1)...;
  f(x)...;

  f(x==y,y)...;
  f(y,y)...;

  f(x==[])...;
  f([])...;
<!--end-->
</code>

<h3><a name="variadic">Variadic functions</a></h3>
Variadic functions can be defined using three dots (<code>...</code>) as last parameter in the function head.
This allows the function to accept any number of additional parameters.<br>
The trailing anonymous parameters can be referenced inside the function body by the pseudo-identifier <code>...</code>, which gives the remaining (anonymous) parameters as a list. 
An example for a variadic recursive function, printing out all parameters in a separate line wold be:<code>
<!--mnh-->
  multiPrint->void;
  multiPrint(x,...)->print(x) | multiPrint@...;
<!--end-->
</code>
<h3><a name="beginEnd">Begin-End-Blocks</a></h3>

<i>Begin-End-Blocks</i> are a means to program in a prodedural manner. It looks as follows <code>
  begin
    <i>statement</i>
    <i>...</i>
    <i>statement</i>
    <i>result statement</i>
  end;
</code> The last statement provides a result which is returned from the block. The other statements are executed before and only have an effect if they
have side effects. <br> Identifiers occuring as the left hand side of an assignment will be created in the current scope if (and only if) they
are declared with a <a href="#localMod">local</a>-modifier <b>or</b> cannot be found in any surrounding scope.
<br>A neat example demonstrating the usefulnes of this feature is calculation of a running sum of a numeric list:<code>
<!--mnh-->
  runningSum(L:numericList)->begin
    local sum:=0;
    each(element,L,sum+=element);
  end;
<!--end-->
</code>This function makes use of the fact that the assignment-operator and C-style operators return the value of the variable after the assignment.<br>
Note, that parallel processing via <code>pEach</code> is disabled within Begin-End-Blocks. Occuring <code>pEach</code>-statements will silently be converted
to <code>each</code>-statements.

<h3><a name="modifiers">Modifiers</a></h3>
<h4><a name="privateMod">private</a></h4>
The <i>private modifier</i> can be used to hide a subrule from importing packages.
Inside of the package containing the modified subrule it is usable as any other rule.

<h4><a name="memoizedMod">memoized</a></h4>
The <i>memoized modifier</i> enables caching for the complete rule; if one subrule of a rule is marked as memoized, then the complete rule is memoized.
<br>Caching means, that internally a hash map with key value pairs (<i>parameters</i>,<i>function result</i>) is created. For performance reasons this
map has a size limit - if this limit is exceeded, key-value-pairs are "forgotten" based on a mixed strategy combining least-recently-used and least-frequently-used approaches.<br>
Used appropriately, caching results in enormous speedup. <br>
Note that memoized functions do not work well with parallelized evaluations.

<h4><a name="synchronizedMod">synchronized</a></h4>
The <i>synchronized modifier</i> protects a rule against parallel execution.<br>
This is desirable for functions with side effects, such as printing or modifying a <a href="#mutableMod">mutable</a> value.

<h4><a name="mutableMod">mutable</a></h4>
The <i>mutable modifier</i> allows for a rule to be mutable. The following restrictions apply:<ul>
  <li> A mutable rule also is private per definition </li>
  <li> A mutable rule also is not memoized per definition </li>
  <li> A mutable rule must have exactly one subrule </li>
  <li> A mutable rule's subrule must be nullary </li>
</ul>
Functions modifying the value of a mutable value should be <a href="#synchronizedMod">synchronized</a>.

<h4><a name="localMod">local</a></h4>
The <i>local modifier</i> ensures, that a variable is declared in the scope of the current <a href="#beginEnd">begin-end-blocks</a>.
It is only allowed in this context. Local variables always are mutable.
<!--commonFoot-->
<!--file types.html-->
<!--commonHead-->
<title>MNH 5 - Types</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Types</h3>
<div align="right"><hr> </div>
<h3>      <a href="#intro">Introduction</a></h3>
<h3>      <a href="#scalars">Scalar types</a></h3><ul>
  <li><h4><a href="#booleans">Booleans</a></h4></li>
  <li><h4><a href="#integers">Integers</a></h4></li>
  <li><h4><a href="#reals">Reals</a></h4></li>
  <li><h4><a href="#strings">Strings</a></h4></li>
  <li><h4><a href="#expressions">Expressions</a></h4></li>
  <li><h4><a href="#void">void</a></h4></li>
  <li><h4><a href="#errors">Errors</a></h4></li>
</ul>
<h3>      <a href="#lists">List types</a></h3>
<div align="right"><hr> </div>
<h3><a name="intro">Introduction</a></h3>
MNH is <i>dynamically typed</i>, i.e. all types are only known at runtime. All types are either <i>scalars</i> (i.e. atomic values) or <i>lists</i>. <br>
This page is about the representation and basic behaviour of the types. For details on the operators defined on these types see <a href="operators.html">MNH5 - Operators</a>.

<h3><a name="scalars">Scalar types</a></h3>
<h4><a name="booleans">Booleans</a></h4>
Booleans are the simplest type. There are only two possible values:<code><span class="literal">true</span></code> and <code><span class="literal">false</span></code>.<br>
To directly input a boolean, use the reserved words <code><span class="literal">true</span></code> and <code><span class="literal">false</span></code>.

<h4><a name="integers">Integers</a></h4>
Integers are internally represented as 64bit two-complement integer numbers. Consequently the smallest possible integer is -9223372036854775808 and the largest possible integer is 9223372036854775807.<br>
Note that no overflow-checking is employed.<br>
Together with reals, integers form the class of <i>numeric</i> values.<br>
To directly input an integer, write a number only containing of digits, without a decimal point.

<h4><a name="reals">Reals</a></h4>
Reals are internally represented as 80bit <i>extended precision</i> floating point numbers in 32bit flavours of mnh and as ordinary 64bit double precision floating point numbers in 64bit flavours.<br>
Together with integers, reals form the class of <i>numeric</i> values.<br>
To directly input a real, write a number containing of digits and a decimal point and/or an exponent, e.g. <code>1.2E-2</code>.

<h4><a name="strings">Strings</a></h4>
Strings are internally represented as ANSI-Strings, without length limitation.<br>
You can use one of the following representations:<br>
<ul>
  <li><b>Pascal Strings</b>: Delimited by <code>'</code>. To insert a quote in the string, use <code>''</code>, e.g.:<code>
<!--mnh-->
  quote:='''';
  doubleQuote:='"';
  backslash:='\';
<!--end-->  
</code></li>
  <li><b>Java Strings</b> (rather: Strings inspired by Java): Delimited by <code>"</code>.
  Within strings the following escape-sequences are defined:<ul>
  <li><code>\n  </code> Line break</li>
  <li><code>\r  </code> Carriage return</li>
  <li><code>\t  </code> Tabulator</li>
  <li><code>\\  </code> Backslash</li>
  <li><code>\"  </code> The delimiter, a double quote</li>
  </ul>
  e.g.:<code>
<!--mnh-->
  quote:="'";
  doubleQuote:="\"";
  backslash:="\\";
<!--end-->  
</code></li>
  <li><b>Blobs</b>:
Alternatively strings can be written as "blobs", i.e. as a text block preserving line breaks and indentations. Blobs are delimited by the special comments
<code>//!BLOB START</code> and <code>//!BLOB END</code>. An example:<code>
<!--mnh-->
  print(
  //!BLOB START
  This is a simple text...
       with a \ which would have to be escaped otherwise.
    And indentations of course.
  //!BLOB END
  );
<!--end-->
</code>
</li>
</ul>

<h4><a name="expressions">Expressions</a></h4>
Expression literals are a MNH5's version of anonymous functions. They are escaped using curly brackets. To define a parameter to an expression literal, use $-Variables.<br>
Example 1: <code>{sin(x)}  </code> This is a nullary (!) function, returning sin(x) if x is defined, or failing otherwise.<br>
Example 2: <code>{sin($x)} </code>  This is an unary function equivalent to the built-in function <code>sin(x)</code>.<br>
If an expression literal accepts more than one parameter, the parameters have to be given <i>in order of appearance</i>, i.e.<code>{$i*arctan($x/$i)}</code> would be called with parameters (i,x).<br>
Expression literals returned by a function are constructed on the fly. Consequently you can pass arguments to them, e.g. <code>
<!--mnh-->
  f(a,b)->{a+b*$x}
<!--end-->
</code> will return a linear scalar function.<br>
Expressions allow for anonymous recursion via the <code>$self</code> pseudo-literal, e.g. (Fibonacci numbers again):<code>
<!--mnh-->
  fib:={$i<=1 ? 1 : $self($i-1)+$self($i-2)};
<!--end-->
</code>

<h4><a name="void">void</a></h4>
The <code>void</code>-Literal is a special literal intended mainly for the use in <a href="each.html">each-Clauses</a>. It represents an element <i>which is not there</i>, e.g. to construct a list of primes from 2 through 47 consider<code>
<!--mnh-->
 in> each(i,[2..7*7],(i>2 and i mod 2=0) or
                     (i>3 and i mod 3=0) or
                     (i>5 and i mod 5=0) or
                     (i>7 and i mod 7=0) ? void : i);
out> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
<!--end-->
</code>
For usual operators, <code>void</code> behaves as neutral element. <br>
It cannot be passed as a function argument.

<h4><a name="errors">Errors</a></h4>
Errors are no functional literals. They form a fallback for cases, where a literal result was expected but none could be provided (e.g. when invoking an operator with incompatible operands).<br>
You should see them rarely and when you see them they should have a corresponding error message.<br>
There is no way to directly write an error-literal.

<h3><a name="lists">List types</a></h3>
Lists contain zero or more elements of any type. They are represented as an enumeration of their elements, surrounded by square brackets, e.g.<code>
<!--mnh-->
  ["a",true,4.6]
<!--end-->
</code>
This example also shows, that types within a list can be mixed. You can use the same notation to construct lists.<br>In addition there is the <code>..</code>-separator, which is only allowed in list constructors.
It enumerates values, e.g. <code>[1..5]</code> gives <code>[1,2,3,4,5]</code>. Enumeration is possible independent from the ordering and is supported for integers and one-character-strings.

<!--commonFoot-->
<!--file quickstart.html-->
<!--commonHead-->
<title>MNH 5 - Quick start</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - Quickstart</h3>
<div align="right"><hr> </div>
MNH5 comes in 2 flavours (for each compilation target):<ul>
  <li> <b>mnh</b>: a GUI version with plotting support
  <li> <b>mnh_light</b>: a slimmed down console version without plotting support (for the cases where size matters)
</ul>

You can just start an executable of any flavour and start typing. Most of the inputs will result in understandable outputs (the exception being infinite loops,
fork bombs and other "pathologic" examples).<br>
<br>
The input can consist of several statements, separated by <code>;</code>. An input can be an expression, like:<code>
1+2;
</code> Or an assignment<code>
x:=1;
</code> Or a declaration<code>
f(x)->sin(x);

<!--commonFoot-->
<!--file each.html-->
<!--commonHead-->
<title>MNH 5 - each and pEach</title>
</head>
<body>
<h2 align="center"><a href="index.html">MNH 5</a> - each and pEach</h3>
<div align="right"><hr> </div>
<h4><a href="#syntax">Syntax</a></h4>
<h4><a href="#construction">List construction</a></h4>
<h4><a href="#aggregation">List aggregation</a></h4>
<h4><a href="#consAgg">List construction and aggregation</a></h4>
<h4><a href="#parallelization">Parallelization</a></h4>

<div align="right"><hr> </div>
<h4><a name="syntax">Syntax</a></h4>
The general syntax is: <br>
<code>   each(id,list,aggregator,body)
  pEach(id,list,aggregator,body)</code><br>
Where <code>id</code> is an identifier,<br>
<code>list</code> is a list or an expression returning a list,<br>
<code>aggregator</code> (optional) is a full aggregator expression or a binary operator and<br>
<code>body</code> is an expression or list of expressions.

<h4><a name="construction">List construction</a></h4>
To construct a list, ommit the aggregator. The body part is mandatory.<br>
Simple example: return the input list<br>
<code>  each(i,[0..3],i) </code> (returns <code>[0..3]</code>)<br>
Reasonable example: return <code>f(i)</code> for every element <code>i</code> in the input list:<br>
<code>  each(i,[0..3],f(i)) </code> (returns <code>[f(0),f(1),f(2),f(3)]</code>)<br>
More complex: a function returning the intersection of sets A and B<br>
<code>  intersect(A:list,B:list) -> A%each(a,A,a in B)</code>

<h4><a name="aggregation">List aggregation</a></h4>
To aggregate a list, use an aggregator but no body.<br>
Restriction: the list must not be empty!<br>
Simple example: a function returing the sum of the argument:<br>
<code>  sum([]):=0;
  sum(L<>[])->each(e,L,+);
</code><br>
For later use: factorial<code>
  fak(n<1)->1;
  fak(n)->each(i,[1..n],*);
</code><br>

A full aggregator is written as <code>aggregator(<i>expression</i>)</code>, where <i>expression</i> is a binary expression.<br>

Full aggregator: join a list of strings using a line break as separator:<br>
Here the aggregator expression takes the left hand side argument and the right hand side argument and concatenates them with an additional line break in between.
<code>
  join([])->"";
  join(L:stringList)->each(e,L,aggregator({$x&"\n"&$y}));</code><br>


<h4><a name="consAgg">List construction and aggregation</a></h4>
You can also use aggregator and body in the same each-/pEach clause.<br><br>
Nested each: construct a cross product:<br>
<code>  each(i,[0..9],each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[[0,0],...,[0,9]],[[1,0],...,[1,9]],...]</code>,<br> which is probably one level deeper than intended.<br>
<code>
  each(i,[0..9],|,each(j,[0..9],[i,j]))</code><br>
This returns a nested list <code>[[0,0],...,[0,9],[1,0],...,[1,9],...]</code>.<br><br>
Compute Euler's number based on inverse factorials<code>
  each(n,[0..20],+,1/fak(n))</code>

<h4><a name="parallelization">Parallelization</a></h4>
This is simple.<br>In order to parallelize your existing <code>each</code>-expression just replace <code>each</code> by <code>pEach</code>.<br>

<!--commonFoot-->
