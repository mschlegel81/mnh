{
[['demos/100doors.mnh',"//See http://rosettacode.org/wiki/100_doors\r\nmain->[1..100].get([1..100].pEach(pass,[1..100] mod pass=0,xor)).toString.unbrace.print;\r\n"]
,['demos/12_statements.mnh',"private txt:=split(\r\n//!~\r\n 1. \"This is a numbered list of twelve statements.\"\r\n 2. \"Exactly 3 of the last 6 statements are true.\"\r\n 3. \"Exactly 2 of the even-numbered statements are true.\"\r\n 4. \"If statement 5 is true, then statements 6 and 7 are both true.\"\r\n 5. \"The 3 preceding statements are all false.\"\r\n 6. \"Exactly 4 of the odd-numbered statements are true.\"\r\n 7. \"Either statement 2 or 3 is true, but not both.\"\r\n 8. \"If statement 7 is true, then 5 and 6 are both true.\"\r\n 9. \"Exactly 3 of the first 6 statements are true.\"\r\n10. \"The next two statements are both true.\"\r\n11. \"Exactly 1 of statements 7, 8 and 9 are true.\"\r\n12. \"Exactly 4 of the preceding statements are true.\"~,\"\\n\");\r\n\r\nprivate\r\ncheck(T:booleanList)->T==[false,\r\n                          true,\r\n                          trueCount(T[[7..12]])=3,\r\n                          trueCount(T[[2,4,6,8,10,12]])=2,\r\n                          not(T[5]) OR T[6] AND T[7],\r\n                          not(T[[2,3,4]].agg(OR)),\r\n                          T[[1,3,5,7,9,11]].trueCount=4,\r\n                          T[2] xor T[3],\r\n                          not(T[7]) OR T[5] AND T[6],\r\n                          T[[1..6]].trueCount=3,\r\n                          T[[11,12]].agg(AND),\r\n                          T[[7,8,9]].trueCount=1,\r\n                          T[[1..11]].trueCount=4];\r\nprivate printBits(i)->begin printf(\"%S\",[0..11].each(j,txt[j]&\"\\tis \"&((i and (2^j))>0))); true; end;\r\n\r\nprivate bits(i)->false|(2^[0..11]).each(j,(i and j)>0);\r\n//*See <a href=\"http://rosettacode.org/wiki/Twelve_statements\">http://rosettacode.org/wiki/Twelve_statements</a>\r\nmain->[0..2^12-1].pEach(i,check(bits(i)) ? printBits(i) : false,OR);\r\n\r\n"]
,['demos/24.mnh',"randomSet->1+intRandom(9,4);\r\nOPLIST:=['+','-','*','/'];\r\n\r\nprivate drop(L<>[],i:int)->L[[0..size(L)-1]<>i];\r\npermutations(L:list)->permutations([],L).unique;\r\nprivate permutations(Head:list,[])->[Head];\r\nprivate permutations(Head:list,L)->[0..size(L)-1].each(i,permutations(Head|L[i],drop(L,i)),|);\r\n\r\nprivate\r\ncanSolve(set)->permutations(set).each(x,\r\n               [x[0]+x[1],x[0]-x[1],x[0]*x[1],x[0]/x[1]].each(y,\r\n               [y   +x[2],y   -x[2],y   *x[2],y   /x[2]].each(z,\r\n              ([z   +x[3],z   -x[3],z   *x[3],z   /x[3]]=24).agg(OR),OR),OR),OR);\r\nprivate\r\ntestSolution(s:string)->toExpression(s)()=24 ? s : void;\r\nprivate\r\nfindSolution(set)->head(flatten(permutations(set).each(x,\r\n                   OPLIST.each(op1,OPLIST.each(op2,OPLIST.each(op3,\r\n                   testSolution('(('&x[0]&op1&x[1]&')'&op2&x[2]&')'&op3&x[3])))))));\r\n\r\nprivate getRiddle->getRiddle(randomSet);\r\nprivate getRiddle(set)->getRiddle(set,canSolve(set));\r\nprivate getRiddle(set,false)->getRiddle(randomSet);\r\nprivate getRiddle(set,true )->set;\r\n\r\nprivate isCorrectSolution(set,text)->\r\n    not(each(c,text.chars,AND,c in (set&\"\") | OPLIST | [' ','(',')']))\r\n  ? print('The input contains an invalid character.') and false\r\n  : '++' in copy(replace(text,OPLIST,'+'),[0..length(text)-2],2) or\r\n    '00' in copy(replace(text,set&\"\",'0'),[0..length(text)-2],2)\r\n  ? print('The input contains an invalid character sequence.') and false\r\n  : not(sort(each(c,copy(text,[0..length(text)-1],1),c in ['0'..'9'] ? softCast(c) : void)) == sort(set))\r\n  ? print('The input uses other numbers than the given input set: ',each(c,copy(text,[0..length(text)-1],1),c in ['0'..'9'] ? softCast(c) : void)) and false\r\n  : not(expression(text)()=24)\r\n  ? print('The input does not evaluate to 24 but to ',expression(text)(),'.') and false\r\n  : print('The solution is valid.') and true;\r\n\r\nprivate playARound->print('-------------------------------------------------------------------')|playARound(getRiddle);\r\nprivate playARound(set)->playARound(set,ask('Find an expression to calculate 24 from the numbers '&string(set)&'.'));\r\nprivate playARound(set,answer)->isCorrectSolution(set,answer) ? (ask('Another round?',['yes','no'])='yes' ? playARound : void)\r\n                                                              : (ask('Retry?',['yes','no'])='yes' ? playARound(set) :\r\n                                                                 print('A possible solution would have been: ',findSolution(set)) |\r\n                                                                (ask('Another round?',['yes','no'])='yes' ? playARound : void));\r\nprivate demo(set)->print(' ?> Find an expression to calculate 24 from the numbers '&toString(set)&'.') |\r\n                   print(' !> ',findSolution(set))|\r\n                   print('The solution is valid.')|\r\n                   print(\" ?> Another round?\\n !> no\");\r\n\r\n//*Demo - mainly for reg-testing\r\nmain->print('This is a demo - start with any argument to play.')|demo(getRiddle);\r\n\r\nmain(arg)->playARound;\r\n"]
,['demos/3body.mnh',"USE rk4;\r\n\r\nprivate circlePoint(phi)->[cos(phi/180*4*arctan(1)),\r\n                           sin(phi/180*4*arctan(1))];\r\n\r\nprivate initialState:=\r\n  [circlePoint(  0),circlePoint( 90)  ,\r\n   circlePoint(120),[0,0],\r\n   circlePoint(240),-3*circlePoint(90)];\r\n\r\n\r\nprivate force(delta:numericList(2))->delta*sqr(delta).agg(+)^(3/2);\r\n\r\nprivate F:={[$x[1],\r\n             force($x[2]-$x[0])+force($x[4]-$x[0]),\r\n             $x[3],\r\n             force($x[0]-$x[2])*3+force($x[4]-$x[2]),\r\n             $x[5],\r\n             force($x[0]-$x[4])*3+force($x[2]-$x[4])]};\r\n\r\nprivate mutable trace0:=[];\r\nprivate mutable trace1:=[];\r\nprivate mutable trace2:=[];\r\nprivate synchronized plotState(F)->begin\r\n  local p0:=F[0]; trace0:=trace0.add(p0).trailing(50);\r\n  local p1:=F[2]; trace1:=trace1.add(p1).trailing(50);\r\n  local p2:=F[4]; trace2:=trace2.add(p2).trailing(50);\r\n  plot(trace0,'red l');\r\n  addPlot([p0],'red .');\r\n  addPlot(trace1,'green l');\r\n  addPlot([p1],'green .');\r\n  addPlot(trace2,'blue l');\r\n  addPlot([p2],'blue .');\r\n  plot.display;\r\n  sleep(0.01);\r\nend;\r\n\r\nprivate timeStepSize:=1E-2;\r\n\r\nmain->begin\r\n  plot.setAxisStyle([3,3]);\r\n  plot.setRange([[-2,2],[-2,2]]);\r\n  local state:=initialState;\r\n  state.plotState;\r\n  while(true,\r\n    plotState(state:=RK4(F,RK4(F,state,timeStepSize),timeStepSize))\r\n  );\r\nend;\r\n\r\n"]
,['demos/99bottles.mnh',"private B(1)->\"1 bottle\";\r\nprivate B(n)->n&\" bottles\";\r\n//*Prints out the song \"99 bottles of beer\", see <a href=\"http://rosettacode.org/wiki/99_Bottles_of_Beer\">RosettaCode</a> or <a href=\"http://www.99-bottles-of-beer.net/\">99-bottles-of-beer.net</a>\r\nmain->printf(\"%{B($n)}s of beer on the wall\\n\"&\r\n             \"%{B($n)}s of beer\\n\"&\r\n             \"Take one down, pass it around\\n\"&\r\n             \"%{B($n-1)}s of beer on the wall.\\n\",[99..1]);\r\n"]
,['demos/ackermann.mnh',"memoized\r\nprivate ackermann(m=0,n>0)->n+1;\r\nprivate ackermann(m>0,n=0)->ackermann(m-1,1);\r\nprivate ackermann(m>0,n>0)->ackermann(m-1,ackermann(m,n-1));\r\n\r\n//*Solves the \"Ackermann\" task from <a href=\"http://rosettacode.org/wiki/Ackermann_function\">RosettaCode</a>\r\nmain->print('See http://rosettacode.org/wiki/Ackermann_function') and\r\n      [0..14].each(n,print('ackermann(3,',n,')=',ackermann(3,n)));\r\n"]
,['demos/aks.mnh',"memoized\r\nprivate pascal(n<1)->1;\r\nprivate pascal(n)->pascal(n-1)|0+0|pascal(n-1);\r\nprivate AKSPoly(n)->pascal(n)*(-1^[0..n]);\r\nprivate powerOfX(0)->\"1\";\r\nprivate powerOfX(1)->\"x\";\r\nprivate powerOfX(n)->\"x^\"&n;\r\nprivate AKSPolyToString(coeff)->[0..size(coeff)-1].each(i,\r\n  coeff[i]>0 and i>0 ? \"+\" : \"\",\r\n  coeff[i] = 1 ? \"\" : coeff[i] = -1 ? \"-\" : coeff[i],\r\n  powerOfX(size(coeff)-i-1)).join;\r\n\r\nprivate AKS_isPrime(n)->trueCount(AKSPoly(n)[[1..n-1]] mod n<>0)=0;\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/AKS_test_for_primes\">http://rosettacode.org/wiki/AKS_test_for_primes</a>\r\nmain->print('Polynomial expansions:') |\r\n      printf(\"(x-1)^%{$0}d = %{AKSPolyToString(AKSPoly($0))}s\",[0..7])|\r\n      print(\"\\nPrimes <= 66 are : \",[2..66].each(i,AKS_isPrime(i) ? i : void));\r\n"]
,['demos/aliquotSequence.mnh',"memoized private dividerSum(n:int)->\r\n  n<=1 ? 0 : begin\r\n    local C:=[2..floor(sqrt(n))];\r\n    C:=C.get(n mod C = 0);\r\n    unique(1|C|(n div C)).agg(+);\r\n  end;\r\n\r\nprivate classify(n:int)->\r\n  begin\r\n    local seq:=[n];\r\n    local k:=dividerSum(n);\r\n    while(size(seq)<=16 and not(k in seq),begin\r\n      seq|=k;\r\n      k:=dividerSum(k);\r\n    end);\r\n    [k=head(seq)\r\n     ? (size(seq)=1 ? \"perfect\" :\r\n        size(seq)=2 ? \"amicable\" :\r\n        \"social\")\r\n     : (k=trailing(seq)\r\n        ? (k=0 ? \"terminating\" : \"aspiring\")\r\n        : (k in seq ? \"cyclic\" : \"non-terminating\"))\r\n    ,seq];\r\n  end;\r\n\r\n//*See http://rosettacode.org/wiki/Aliquot_sequence_classifications\r\nmain->begin\r\n  local input:=[11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488];\r\n  local class:=input.each(n,classify(n));\r\n    printf(\"%d\\t|\\t%s\\t|\\t%s\",\r\n     \"start @\"| input,\r\n     \"classification\"|( class.getInner(0)),\r\n     \"sequence\"|(class.getInner(1)));\r\nend;\r\n"]
,['demos/anagram.mnh',"USE inputs;\r\n\r\nreadDict(filename)->fileLines(filename).pEach(word,[join(word.chars.sort),word]);\r\n\r\nanagramsInDict(list)->fileLines(inputs.dict)\r\n                     .pEach(word,[word.chars.sort.agg(&),word])\r\n                     .group(0)\r\n                     .pEach(gr,size(gr)<=1 ? void : gr.getInner(1));\r\n\r\n//*Finds anagrams in unixdict.txt\r\nmain->main(inputs.dict);\r\n\r\n//*Finds anagrams in a custom dictionary, sort by anagrams per group and print them out (one line per group)\r\nmain(filename:string)->printf(\"%{join($0,', ')}s\",readDict(filename).anagramsInDict.sort({size($x)<=size($y)}));\r\n"]
,['demos/asciiCalendar.mnh',"private bigDigit:=\r\n[[' ### ','#   #','#   #','#   #',' ### '],\r\n ['  # ',' ## ','# # ','  # ',' ###'],\r\n [' ### ','#   #','  ## ',' #   ','#####'],\r\n [' ### ','#   #','   # ','#   #',' ### '],\r\n ['  #  ',' #  #','#####','    #','    #'],\r\n ['#####','#    ','#### ','    #','#### '],\r\n [' ### ','#    ','#### ','#   #',' ### '],\r\n ['#####','   # ','  #  ','  #  ','  #  '],\r\n [' ### ','#   #',' ### ','#   #',' ### '],\r\n [' ### ','#   #',' ####','    #',' ### ']];\r\n\r\nprivate getWeeks(year,month)->begin\r\n  local firstDayOfMonth:=parseTime('dd.mm.yyyy',format('01.%2.2d.%4.4d',month,year)).round;\r\n  local lastDayOfMonth :=parseTime('dd.mm.yyyy',month=12 ? format('01.%2.2d.%4.4d',      1,year+1)\r\n                                                         : format('01.%2.2d.%4.4d',month+1,year  )).round-1;\r\n  local startingMonday :=firstDayOfMonth;\r\n  while(formatTime('ddd',startingMonday)!='Mo',startingMonday-=1);\r\n  local daysOnTab:=[startingMonday..lastDayOfMonth]-firstDayOfMonth+1;\r\n  daysOnTab\r\n  .group([0..size(daysOnTab)-1] div 7)\r\n  .sort({$x[0]<$y[0]})\r\n  .each(week,week.each(day,day<=0 ? '  ' : format('%2s',day)).join(' '));\r\nend;\r\n\r\nprivate printCalendar(year)->begin\r\n  local digitIndexes:=toString(year).chars.softCast;\r\n  local bigYear:=[0..4].each(i,bigDigit[digitIndexes].getInner(i).join(' '));\r\n  bigYear:=repeat(' ',(91-bigYear[0].length) div 2)&bigYear;\r\n  print('+',repeat('-',91),'+');\r\n  printf('|%-91s|',bigYear);\r\n\r\n  local weeks:=[1..12].each(month,getWeeks(year,month));\r\n  local lineFormat:='| %-20s | %-20s | %-20s | %-20s |';\r\n  local splitLine:='+'&repeat(repeat('-',22)&'+',4);\r\n  local nameOfMonth:=['Januar','Februar','Maerz','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'];\r\n  local weekDays:='Mo Di Mi Do Fr Sa So';\r\n  ([0..2]*4).each(leftMonth,\r\n    print(splitLine),\r\n    printf@(lineFormat | nameOfMonth[[leftMonth..leftMonth+3]]),\r\n    printf(lineFormat,weekDays,weekDays,weekDays,weekDays),\r\n    [0..5].each(i,printf(lineFormat,weeks[leftMonth  ,i] orElse \"\",\r\n                                    weeks[leftMonth+1,i] orElse \"\",\r\n                                    weeks[leftMonth+2,i] orElse \"\",\r\n                                    weeks[leftMonth+3,i] orElse \"\")));\r\n  print(splitLine);\r\nend;\r\n\r\n//*Prints a calendar of 1966\r\nmain->printCalendar(1966);\r\n\r\n//*Prints a calendar of the given year\r\nmain(year)->printCalendar(year.softCast);\r\n"]
,['demos/balancedBrackets.mnh',"//Note: Using memoization here is a hack to ensure that successive callls return the same string\r\nprivate memoized randomBrackets(n:int)->n<1 ? \"\" : [1..n].each(i,'[',']').get(sortPerm(random(2*n))).agg(&);\r\nprivate isOk(s:string)->replace(s,\"[]\",\"\")=\"\";\r\n//*See <a href=\"http://rosettacode.org/wiki/Balanced_brackets\">http://rosettacode.org/wiki/Balanced_brackets</a>\r\nmain->[1..8].each(i,printf('%-16s %s',randomBrackets(i),isOk(randomBrackets(i)) ? \"o.k.\" : \"NOT o.k.\"));\r\n"]
,['demos/barnsleyFern.mnh',"private interlace(X,Y)->[0..size(X)-1].each(i,[X.get(i),Y.get(i)]);\r\n\r\nprivate barnsleyFern(sampleCount)->begin\r\n  local x:=random(1);\r\n  local y:=random(1);\r\n  while (size(x)<=sampleCount, begin\r\n    local p1:=random(size(x))<0.01;\r\n    local p2:=random(size(x))<0.11;\r\n    local xNew:=flatten(   0*x.get(p1), 0.85*x+0.04*y    ,0.20*x.get(p2)-0.26*y.get(p2)    ,-0.15*x.get(p2)+0.28*y.get(p2)     );\r\n    y:=         flatten(0.16*y.get(p1),-0.04*x+0.85*y+1.6,0.23*x.get(p2)+0.22*y.get(p2)+1.6, 0.26*x.get(p2)+0.24*y.get(p2)+0.44);\r\n    x:=xNew;\r\n  end);\r\n  interlace(x,y);\r\nend;\r\n\r\nprivate main_impl(filename:string,xRes:int,yRes:int)->begin\r\n  plot.setAutoscale([true,true]);\r\n  plot.setLogscale([false,false]);\r\n  plot.setPreserveAspect(true);\r\n  plot.setAxisStyle([0,0]);\r\n  plot.plot(barnsleyFern(100000),\"0.2 . green\");\r\n  plot.renderToFile(filename,xRes,yRes,10);\r\nend;\r\n\r\n//*Plots a Barnsley Fern to file <code>filename</code> using a custom resolution (given as <i>xRes</i><code>x</code><i>yRes</i>)\r\nmain(filename,resolution)->main_impl(filename,softCast(split(resolution,\"x\").get(0)),softCast(split(resolution,\"x\").get(1)));\r\n//*Plots a Barnsley Fern to file <code>filename</code> using a custom resolution\r\nmain(filename,xRes,yRes )->main_impl(filename,softCast(xRes)                   ,softCast(yRes));\r\n//*Plots a Barnsley Fern to file <code>filename</code> using a resolution of 768x768\r\nmain(filename           )->main_impl(filename                        ,768,768);\r\n//*Plots a Barnsley Fern using the package path and a resolution of 768x768\r\nmain                     ->main_impl(replace(myPath&\"#\",\"mnh#\",\"png\"),768,768);\r\n"]
,['demos/benford.mnh',"USE stringFib;\r\n//*See <a href=\"http://rosettacode.org/wiki/Benford%27s_law\">Benford's law on Rosetta Code</a>\r\nmain->printf('%6d %8.2f',\r\n             'actual'|[1..1000].each(i,softCast(copy(stringFib(i),0,1))).elementFrequency.sort({$x.get(1)<=$y.get(1)}).getInner(0),\r\n             'expected'|(ln(1+1/[1..9])/ln(10)*1000));\r\n"]
,['demos/bestShuffle.mnh',"private shuffle(s:string)->s|shuffle(chars(s));\r\nprivate shuffle(s:stringList)->{$x.get(argMin($x.getInner(1)))}([0..size(s)^2].each(i,sortPerm(random(size(s)))).each(perm,[s.get(perm).join,trueCount(s.get(perm) = s)]));\r\nprivate inputs:=['abracadabra', 'seesaw', 'elk', 'grrrrrr', 'up', 'a'];\r\n//*See <a href=\"http://rosettacode.org/wiki/Best_shuffle\">http://rosettacode.org/wiki/Best_shuffle</a>\r\nmain->inputs.each(i,printf@('%-11s, %-11s, (%d)'|shuffle(i)));\r\n"]
,['demos/clock.mnh',"private glyphs:=[['0',['  _/_/_/    ','_/      _/  ','_/      _/  ','_/      _/  ','_/      _/  ','_/      _/  ','  _/_/_/    ']],['1',['      _/    ','    _/_/    ','  _/  _/    ','      _/    ','      _/    ','      _/    ','      _/    ']],['2',['  _/_/_/    ','_/      _/  ','      _/    ','    _/      ','  _/        ','_/          ','_/_/_/_/_/  ']],['3',['  _/_/_/    ','_/      _/  ','        _/  ','  _/_/_/    ','        _/  ','_/      _/  ','  _/_/_/    ']],['4',['    _/      ','  _/        ','_/    _/    ','_/_/_/_/_/  ','      _/    ','      _/    ','      _/    ']],['5',['_/_/_/_/_/  ','_/          ','_/          ','_/_/_/_/    ','        _/  ','        _/  ','_/_/_/_/    ']],['6',['  _/_/_/    ','_/      _/  ','_/          ','_/_/_/_/    ','_/      _/  ','_/      _/  ','  _/_/_/    ']],['7',['_/_/_/_/_/  ','        _/  ','        _/  ','      _/    ','    _/      ','  _/        ','_/          ']],['8',['  _/_/_/    ','_/      _/  ','_/      _/  ','  _/_/_/    ','_/      _/  ','_/      _/  ','  _/_/_/    ']],['9',['  _/_/_/    ','_/      _/  ','_/      _/  ','  _/_/_/_/  ','        _/  ','_/      _/  ','  _/_/_/    ']],[':',['    ','    ','_/  ','    ','_/  ','    ','    ']],[' ',['      ','     ','    ','   ','  ',' ','']]];\r\nprivate printTime(time:real)->printf('%s',glyphs.get(chars(formatTime(' hh:nn:ss',time))).agg(&));\r\n//*For regtest\r\nmain->begin\r\n  print('Call with any string parameter for continuous run.');\r\n  printTime(0.123);\r\nend;\r\n\r\nmain(...)->\r\nbegin\r\n  local proceed:=true;\r\n  [{begin\r\n     ask('Press enter to quit.');\r\n     proceed:=false;\r\n   end},\r\n   {while(proceed,begin\r\n     clearPrint;\r\n     print('Press enter to quit.');\r\n     printTime(systime);\r\n     sleep(1);\r\n   end)}].PEach(task,task());\r\nend;\r\n"]
,['demos/concatInts.mnh',"private f(I)->sort(I,{$a&$b>=$b&$a}).join.softCast;\r\n//*See <a href=\"http://rosettacode.org/wiki/Largest_int_from_concatenated_ints\">http://rosettacode.org/wiki/Largest_int_from_concatenated_ints</a>\r\nmain->print(f([1, 34, 3, 98, 9, 76, 45, 4])) and\r\n      print(f([54, 546, 548, 60]));\r\n"]
,['demos/continuedFractions.mnh',"private continuedFraction(a,b)->begin\r\n  local A:=a:expression ? a : {$n*0+(a)};\r\n  local B:=b:expression ? b : {$n*0+(b)};\r\n\r\n  local resultNum:=0;\r\n  local resultTxt:=\"...\";\r\n  [100..1].each(n,\r\n    resultNum       :=B(n)  /(  A(n)  +  resultNum  ),\r\n    n<=5 ? resultTxt:=B(n)&\"/(\"&A(n)&\"+\"&resultTxt&\")\" : void,\r\n      void);\r\n  [A(0)&\"+\"&resultTxt,\r\n   A(0)  +  resultNum];\r\nend;\r\n\r\n//*See http://rosettacode.org/wiki/Continued_fraction\r\nmain->begin\r\n  local data:=[continuedFraction(1,1),\r\n               continuedFraction({$n=0?1:2 }, 1           ),\r\n               continuedFraction({$n=0?2:$n},{$n=1?1:$n-1}),\r\n               continuedFraction({$n=0?3:6 },{(2*$n-1)^2} )];\r\n  printf(\"%s\\t=\\t%g\",data.getInner(0),data.getInner(1));\r\nend;\r\n"]
,['demos/countTheCoins.mnh',"private change(amount,set<>[])->\r\namount<=0 ? 1 : //there is only one way to give out 0 cents\r\nbegin\r\n  local restSet:=set.get(set<=amount); //only work with coins >= amount\r\n  local coin:=head(restSet); //the current coin is the first (i.e. largest) of the remaining coins\r\n  size(restSet)=1\r\n    ? (amount mod coin = 0 ? 1 : 0)\r\n    : [amount div coin..0].each(i,change(amount-i*coin,tail(restSet)),+);\r\nend;\r\n\r\n//*See  http://rosettacode.org/wiki/Count_the_coins\r\nmain->printf(\"There are %d ways to make a dollar from coins\\n\"&\r\n             \"  and %d ways to make a euro from coins.\",\r\n             change(100,[100,50,25,10,5,1]),\r\n             change(100,[100,50,20,10,5,2,1]));\r\n"]
,['demos/dice7fromDice5.mnh',"dice5->intRandom(5);\r\ndice7->dice7(dice5*5+dice5);\r\ndice7(n<21)->n mod 7;\r\ndice7(n   )->dice7;\r\n\r\nsimpleHist(L)->(elementFrequency(L).getInner(0)/size(L)).join(\"\\n\");\r\n\r\nmain->print(\"Distribution of seven sided dice (100000 samples): \\n\",simpleHist([1..100000].each(k,dice7)));\r\n"]
,['demos/digitSquareSum.mnh',"private POWERS_OF_TEN:=10^[0..6];\r\nmemoized\r\nprivate digitSquareFinal(1)->1;\r\nprivate digitSquareFinal(89)->89;\r\nprivate digitSquareFinal(x)->digitSquareFinal(sqr((x div POWERS_OF_TEN) mod 10).agg(+));\r\n\r\nprivate count89->([1..100000].each(i,digitSquareFinal(i))=89).trueCount;\r\n//*See <a href=\"http://rosettacode.org/wiki/Iterated_digits_squaring\">Iterated_digits_squaring</a>\r\nmain->print(count89);\r\n"]
,['demos/ethiopian.mnh',"private halve(i:int)->i div 2;\r\nprivate double(i:int)->i*2;\r\nprivate isEven(i:int)->(i and 1) = 0;\r\n\r\nethiopianMultiplication(a_>=1,b_>=1)->ethiopianMultiplication(a_,b_,false);\r\nethiopianMultiplication(a_>=1,b_>=1,doPrint:boolean)->begin\r\n  local a:=a_;\r\n  local b:=b_;\r\n  local aColumn:=[a];\r\n  local bColumn:=[b];\r\n  while(a>1,begin\r\n    aColumn|=(a:=halve(a));\r\n    bColumn|=(b:=double(b));\r\n  end);\r\n  local strikeOut:=aColumn.each(v,isEven(v));\r\n  local result:=bColumn[not(strikeOut)].agg(+);\r\n\r\n  doPrint ? begin\r\n    //Pretty printing:\r\n    printf(\"%{$0}5d  %{$2?'[':' '}s%{$1}5d%{$2?']':''}s\",aColumn,bColumn,strikeOut);\r\n    print(\"       =======\");\r\n    printf(\"        %5d\",result);\r\n  end : void;\r\n  result;\r\nend;\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Ethiopian_multiplication\">http://rosettacode.org/wiki/Ethiopian_multiplication</a>\r\nmain->ethiopianMultiplication(17,34,true);\r\n"]
,['demos/fibonacci.mnh',"memoized private\r\nfibNStep(i>=k,k>=1)->[1..k].each(j,fibNStep(i-j,k),+);\r\nfibNStep(i   ,k)->1;\r\n\r\n//*Solves the \"Fibonacci n-step\" task from <a href=\"http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences\">RosettaCode</a>\r\nmain->print('See http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences') and\r\n      print('Fibonacci n-step sequence') and\r\n      print(' n | values') and\r\n      print('---+-----------------------------------------------------------------------------------------------------') and\r\n      printf(\"%s\",[1..20].each(k,k&\"\\t| \"&\r\n                  [1..20].each(i,fibNStep(i+k-3,k)).join(\"\\t\"))) and\r\n      isGuiActive ? showTable([['n','values']]|([1..20].each(k,k| [1..20].each(i,fibNStep(i+k-3,k)))))\r\n                  : void;\r\n"]
,['demos/fibonacciWord.mnh',"USE shannonEntropy;\r\n\r\nmemoized\r\nprivate fibWord(i<=1)->\"1\";\r\nprivate fibWord(i<=2)->\"0\";\r\nprivate fibWord(n)->fibWord(n-1)&fibWord(n-2);\r\n\r\nmemoized\r\nprivate fibWordCharFreq(i<=1)->[0,1];\r\nprivate fibWordCharFreq(i<=2)->[1,0];\r\nprivate fibWordCharFreq(n)->fibWordCharFreq(n-1)+fibWordCharFreq(n-2);\r\n\r\nprivate fibWordLength(i)->fibWordCharFreq(i).agg(+);\r\nprivate fibWordEntropy(i)->-1*(fibWordCharFreq(i)/fibWordLength(i)).each(s,s*ln(s)/ln(2),+);\r\n\r\n//*Solves the <a href=\"http://rosettacode.org/wiki/Fibonacci_word\">Fibonacci Word Task</a> (with cheating)\r\nmain->print(\"N\\tLength\\tEntropy\\tWord\\n\") |\r\n      [ 1.. 9].each(i,printf('%2d %9d %15.13f %s',i,length(fibWord(i)),shannonEntropy(fibWord(i)),fibWord(i))) |\r\n      [10..37].each(i,printf('%2d %9d %15.13f',i,fibWordLength(i),fibWordEntropy(i)));\r\n"]
,['demos/fractalPlant.mnh',"USE lindenmayer;\r\n//*Draws a fractal plant\r\nmain->plot.setAxisStyle([0,0]) and\r\n      plot.plot(lindenmayerTurtle(PLANT,6)) and\r\n      plot.renderToFile(replace(myPath,'.mnh','.png'),768,768,8);\r\n"]
,['demos/fractran.mnh',"//Rational numbers are handled as arrays of their prime factor powers.\r\nprivate BASE:=  [2,3,5,7,11,13,17,19,23,29];\r\nprivate POT2TAIL:=[0,0,0, 0, 0, 0, 0, 0, 0];\r\nprivate niceRational(L)->[0..size(L)-1].each(i,L.get(i)<>0 ? BASE.get(i)&\"^\"&L.get(i) : void).join(\"*\")&\" = \"&(BASE^L).agg(*);\r\n\r\n//*This routine transforms a rational number to the corresponding prime factor powers\r\nprivate rational(enumerator:int,denominator:int)->begin\r\n  local en:=enumerator;\r\n  local de:=denominator;\r\n  BASE.each(b,begin\r\n    local k:=0;\r\n    while(en mod b=0,begin k+=1; en:=en div b; end);\r\n    while(de mod b=0,begin k-=1; de:=de div b; end);\r\n    k;\r\n  end);\r\nend;\r\n\r\n//*A list of prime factor powers denotes an integer, if all powers are nonnegative\r\nprivate isInteger(L:intList)->min(L)>=0;\r\n\r\n//*Turns an input string first into a list of tuples (denoting rational numbers) then to lists of prime factor powers\r\nprivate parseFractions(s:string)->\r\n  toExpression('[['&\r\n             replace(s,[' ', ',' ,'/'],\r\n                       ['' ,'],[',','])&\r\n             ']]')().each(tuple,rational@tuple);\r\n\r\n//*The core algorithm;\r\nprivate Fractran(out:expression,fractions,k,steplimit)->begin\r\n  local state:=k;\r\n  local terminated:=false;\r\n  out(0,state);\r\n  [1..steplimit].each(step,terminated ? void :\r\n    begin\r\n      terminated:=fractions.each(f,\r\n        isInteger(state+f) \r\n        ? begin state+=f; false; end //Do NOT terminate early when there is a matching rational \r\n        : true,AND);\r\n      out(step,state);\r\n    end);\r\nend;\r\n\r\nConway_primes_algorithm:='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33, 77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13, 13 / 11, 15 / 14, 15 / 2, 55 / 1';\r\nprivate printPowersOf2:={tail($params.get(1))==POT2TAIL ? print($step,': ',niceRational($state)) : void};\r\nprivate printAll      :={                                 print($step,': ',niceRational($state))       };\r\n\r\nmain(fractions,n)->Fractran(printAll      ,parseFractions(fractions),rational(softCast(n),1),30)|\r\n                   print('----------------------------------')|\r\n                   Fractran(printPowersOf2,parseFractions(fractions),rational(softCast(n),1),428553);\r\n//*See <a href=\"http://rosettacode.org/wiki/Fractran\">http://rosettacode.org/wiki/Fractran</a>\r\nmain('rosetta')->main(Conway_primes_algorithm,'2');\r\n//*As above but abridged for regression test\r\nmain->Fractran(printAll,parseFractions(Conway_primes_algorithm),rational(2,1),30);\r\n"]
,['demos/gol.mnh',"private worldHeight:=40;\r\nprivate worldWidth:=40;\r\n\r\nprivate\r\ninitWorld->intRandom(2,worldHeight*worldWidth);\r\nprivate\r\nprintWorld(w:intList)->printf(\"%s\",\"\\f\"|copy(join([' ','#'][w]),worldWidth*[0..worldHeight-1],worldWidth));\r\n\r\nprivate xyPos:=[0.. worldHeight-1].each(i,\r\n               [0.. worldWidth -1].each(j,[j,i]),|);\r\n\r\nprivate\r\nplotWorld(w:intList)->begin\r\n  setAxisStyle([0,0]);\r\n  plot([[0,0],[worldWidth+1,worldHeight+1]],'box RGB1,1,1');\r\n  addPlot([0..size(w)-1].each(i,\r\n                  w[i]=0 ? void : [xyPos[i],xyPos[i]+1],|),'black box');\r\n  display;\r\n  sleep(0.05);\r\nend;\r\n\r\nprivate memoized\r\nshift(di,dj)->flatten([0..worldHeight-1].each(i,\r\n                      [0..worldWidth-1].each(j,((i+di+worldHeight) mod worldHeight)*worldWidth+\r\n                                                (j+dj+worldWidth)  mod worldWidth )));\r\nprivate memoized\r\nneighbors(w)->w[shift(-1,-1)]+w[shift(0,-1)]+w[shift( 1,-1)]+\r\n              w[shift(-1, 0)]+               w[shift( 1, 0)]+\r\n              w[shift(-1, 1)]+w[shift(0, 1)]+w[shift( 1, 1)];\r\n\r\nprivate\r\nTRANSITION:=[[0,0,0,1,0,0,0,0,0],\r\n             [0,0,1,1,0,0,0,0,0]];\r\n\r\nstep(w)->step(w,TRANSITION.getInner(neighbors(w)));\r\nstep(w,t)->[0..size(w)-1].each(i,t.getInner(i).get(w[i]));\r\n\r\nplayUntilStatic(w,sleepTime)->begin\r\n  local world:=w;\r\n  local wantQuit:=false;\r\n  [\r\n {while(not(wantQuit),begin\r\n    printWorld(world);\r\n    sleep(sleepTime);\r\n    local newWorld:=step(world);\r\n    world==newWorld ? wantQuit:=true : void;\r\n    world:=newWorld;\r\n    void;\r\n  end)},\r\n {begin\r\n    ask('Press Enter to quit.');\r\n    wantQuit:=true;\r\n  end}].PEach(task,task());\r\nend;\r\n\r\n\r\nplayGui->begin\r\n  local living:=true;\r\n  local world:=initWorld;\r\n  plotWorld(world);\r\n  while(plotShowing,plotWorld(world:=step(world)));\r\nend;\r\n\r\n\r\nplaySteps(w,n>0)->begin\r\n  local world:=w;\r\n  [1..n].each(i,begin\r\n    printWorld(world);\r\n    world:=step(world);\r\n    void;\r\n  end);\r\nend;\r\n\r\nmain->playSteps(initWorld,10);\r\nmain(\"-long\")->playUntilStatic(initWorld,0.05);\r\nmain(steps)->playSteps(initWorld,softCast(steps));\r\n"]
,['demos/grep.mnh',"//*searchPattern can be a regex\r\n//*the remaining parameters are file patterns; if none is given, * is assumed\r\nmain(searchPattern,...)->begin\r\n  local filesToScan:=size(...)=0\r\n                     ? files(allFolders('.')&'/*')\r\n                     : ... .each(pattern,files(allFolders('.')&'/'&pattern)).flatten;\r\n  filesToScan.each(file,begin\r\n    local nameDisplayed:=false;\r\n    fileLines(file).each(line,\r\n      line.matches(searchPattern)\r\n      ? begin\r\n          nameDisplayed OR begin\r\n            print(file);\r\n            nameDisplayed:=true;\r\n          end;\r\n          printf('  %4d:%s',index+1,line);\r\n        end\r\n      : void);\r\n  end);\r\nend;\r\n"]
,['demos/hailstone.mnh',"memoized\r\nprivate hailstone(1  )->1;\r\nprivate hailstone(i>1)->i|((i and 1)=1 ? hailstone(3*i+1) : hailstone(i div 2));\r\n\r\nmemoized\r\nprivate hailLen(1  )->1;\r\nprivate hailLen(i>1)->1+((i and 1)=1 ? hailLen(3*i+1) : hailLen(i div 2));\r\n\r\nmemoized\r\nprivate sizes->0|[1..100000].each(i,hailLen(i));\r\n\r\n//*Solves the \"Hailstone\" task from <a href=\"http://rosettacode.org/wiki/Hailstone_sequence\">RosettaCode</a>\r\nmain->print('See http://rosettacode.org/wiki/Hailstone_sequence') and\r\n      print('Series starting @27 has ',size(hailstone(27)),' elements') and\r\n      print('Starting with: ',hailstone(27).get([0..3]),' and') and\r\n      print('  ending with: ',hailstone(27).get([size(hailstone(27))-4..size(hailstone(27))-1])) and\r\n      print('Max length=',max(sizes),' for starting value ',argMax(sizes));\r\n"]
,['demos/hamming.mnh',"private H(nMax)->unique(flatten((2^[0..floor(ln(nMax      )/ln(2))]).each(i,\r\n                        flatten((3^[0..floor(ln(nMax/ i   )/ln(3))]).each(j,\r\n                                       5^[0..floor(ln(nMax/(i*j))/ln(5))]*i*j))))).sort;\r\nprivate H:=H(2^31);\r\n//*See <a href=\"http://rosettacode.org/wiki/Hamming_numbers\">http://rosettacode.org/wiki/Hamming_numbers</a>\r\nmain->print('The first 20 Hamming numbers are: ',head(H,20))|\r\n      print('The 1691st Hamming number is    : ',H.get(1690));\r\n"]
,['demos/harshad.mnh',"private sumOfDigits(n:int)->(n div 10^[0..18] mod 10).agg(+);\r\nprivate isHarshadNumber(n:int)->n mod sumOfDigits(n) = 0;\r\nprivate mutable lastHarshad:=0;\r\nprivate synchronized nextHarshad->begin\r\n  local n:=lastHarshad+1;\r\n  while(not(isHarshadNumber(n)),n+=1);\r\n  lastHarshad:=n;\r\nend;\r\n//*See http://rosettacode.org/wiki/Harshad_or_Niven_series\r\nmain->begin\r\n  printf(\"%2d\",[1..20].each(i, nextHarshad));\r\n  print(\"The first Harshad Number >\",(lastHarshad:=1000),\" is \",nextHarshad);\r\nend;\r\n"]
,['demos/helloWorld.mnh',"main->print('Hello world');\r\n"]
,['demos/helloWorldHttp.mnh',"mutable counter:=0;\r\nmain->begin\r\n  //start server without timeout (=0) -> server will stop on end of evaluation\r\n  startHttpServer('127.0.0.1:65432',{wrapTextInHttp(\"Hello world \"&chars[counter+=1])},0);\r\n  //open provided URL\r\n  openUrl('http://127.0.0.1:65432');\r\n  //wait until server has received at least one request\r\n  while(counter=0,sleep(0.1));\r\nend;\r\n\r\n\r\n"]
,['demos/hereDoc.mnh',"//*See <a href=\"http://rosettacode.org/wiki/Here_document\">http://rosettacode.org/wiki/Here_document</a>\r\nmain->print(\r\n//!~\r\n  This is a simple text...\r\n       with a \\ which would have to be escaped otherwise.\r\n    And indentations of course.~);\r\n"]
,['demos/hofstadterConway.mnh',"private getRatios(iMax>=3)->begin\r\n  local HC:=[1,1,1];\r\n  [3..iMax].each(i,begin\r\n    HC|=HC.get(  HC.get(i-1))+\r\n        HC.get(i-HC.get(i-1));\r\n    void;\r\n  end);\r\n  HC/[1,1..size(HC)-1];\r\nend;\r\ngetRatios(k)->[0..k]*0+1;\r\n\r\nprivate maxBetween(i0,i1,L)->begin\r\n  local subList:=L.tail(i0).head(i1-i0);\r\n  local maxIdx:=argMax(subList);\r\n  format('%17.14f @i=%7d',subList.get(maxIdx),i0+maxIdx);\r\nend;\r\n\r\n//*This solves the <a href=\"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence\"> Hofstadter-Conway $10,000 sequence task from Rosetta Code</a>\r\nmain(powerOfTwo:int)->begin\r\n  local ratios:=getRatios(2^powerOfTwo);\r\n  [0..powerOfTwo-1].each(i,printf(\"range 2^%2d..2^%2d max. a(n)/n=%s\",i,i+1,maxBetween(2^i,2^(i+1),ratios)));\r\n  print(\"Mallows Number: \",[1..2^powerOfTwo].pEach(i,ratios.get(i)>0.55 ? i : void).max);\r\nend;\r\n\r\n//*This solves the <a href=\"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence\"> Hofstadter-Conway $10,000 sequence task from Rosetta Code</a>\r\nmain('rosetta')->main(20);\r\n\r\n//*As above but abridged for regression test\r\nmain->main(17);\r\n"]
,['demos/htmlFunctionPlotter.mnh',"private FIELD_FMT:='<tr><td>%s:</td><td><INPUT TYPE=\"text\" NAME=\"%s\" VALUE=\"%s\" SIZE=50 onkeydown=\"if (event.keyCode == 13) { this.form.submit(); return false; }\"></td></tr>';\r\n\r\nprivate isValidReal(x)->x:numeric AND not(x.isNan) and not(x.isInfinite);\r\nmemoized\r\npageSet(rawParameters,parameters)->begin\r\n  //extract parameters in string form\r\n  local f_ :=(parameters['f'] orElse \"sin(x)\").replace('$','');\r\n  local x0_:=parameters['x0'] orElse \"-3\";\r\n  local x1_:=parameters['x1'] orElse \"3\";\r\n  local sp_:=parameters['samples'] orElse \"1000\";\r\n\r\n  local validationMessages:=[];\r\n  //transform function in string form to expression\r\n  local f:=void;\r\n  try(begin\r\n        //replace \"x\" by valid expression variable \"$x\"\r\n        f:=f_.replace('x','$x').expression;\r\n        f.arity==1\r\n        ? void\r\n        : validationMessages|='Function must unary.';\r\n        f(random):numeric\r\n        ? void\r\n        : validationMessages|='Function must return a numeric value.';\r\n      end,\r\n      validationMessages|=(escape(f_)&' is not a valid function.'));\r\n\r\n  isValidReal(local x0:=softCast(x0_))\r\n  ? void\r\n  : validationMessages|=(escape(x0_)&' is not a valid value for x0.');\r\n\r\n  isValidReal(local x1:=softCast(x1_))\r\n  ? void\r\n  : validationMessages|=(escape(x1_)&' is not a valid value for x1.');\r\n\r\n  local sp:=softCast(sp_);\r\n  sp:int AND 2<=sp<=10000\r\n  ? void\r\n  : validationMessages|=(escape(sp_)&' is not a valid value for samples.');\r\n\r\n  local htmlCode:='<HTML><HEAD><TITLE>Simple HTML function plotter</TITLE></HEAD><BODY><FORM name=\"myForm\"><table>'&\r\n    format(FIELD_FMT,'Function:','f',f_)&\r\n    format(FIELD_FMT,'x0:','x0',x0_)&\r\n    format(FIELD_FMT,'x1:','x1',x1_)&\r\n    format(FIELD_FMT,'samples:','samples',sp_)&\r\n    '</table></FORM>';\r\n\r\n  local imageCode:='';\r\n  validationMessages==[]\r\n  ? begin\r\n      //if there are no validation messages, add link to image and generate image\r\n      htmlCode&='<img src=\"plotImg.png?'&rawParameters&'\">';\r\n      local X:=([0,1]|random(sp-2)).sort*(x1-x0)+x0;\r\n      plot(X,f(X));\r\n      imageCode:=wrapTextInHttp(plot.renderToString(400,400,4),'image/png');\r\n    end\r\n  : begin\r\n      //if there are no validation messages, append them and return httpError(404) instead of image\r\n      htmlCode&=(validationMessages.join('<br>');\r\n      imageCode:=httpError;\r\n    end;\r\n\r\n  [['/page.html',wrapTextInHttp(htmlCode&'</BODY></HTML>')],\r\n   ['/plotImg.png',imageCode]];\r\nend;\r\n\r\nmain->begin\r\n  startHttpServer('localhost:43210',{pageSet(rawParameters,parameters)[path] orElse httpError},0);\r\n  openUrl('http://localhost:43210/page.html');\r\n  ask('Press o.k. to shutdown server.',['o.k.']);\r\nend;\r\n"]
,['demos/huffmann.mnh',"USE inputs;\r\n\r\nprivate huffman(L         )->size(L)<=1 ? traverseBinaryTree(\"\",L[0,1]).sort({length($x[0])>=length($y[0])})\r\n                                        : huffman(L,sortPerm(L.getInner(0)).get([0,1]));\r\nprivate huffman(L,mergeIdx)->huffman(L.get(mergeIdx[0]<>[0..size(L)-1]<>mergeIdx[1]) | [mergeNodes@(L[mergeIdx.get([0,1])])]);\r\nprivate mergeNodes(n1,n2)->[n1[0]+n2[0],[n1[1],n2[1]]];\r\n\r\nprivate traverseBinaryTree(codePrefix,T:string)->[[codePrefix,T]];\r\nprivate traverseBinaryTree(codePrefix,T<>[])->traverseBinaryTree(codePrefix&0,T[0])|\r\n                                              traverseBinaryTree(codePrefix&1,T[1]) ;\r\n\r\nprivate charactersInFile(filename:string)->charactersInString(fileContents(filename));\r\nprivate charactersInString     (s:string)->s.chars.elementFrequency;\r\n\r\n//*Solves the \"Huffman coding\" task from <a href=\"http://rosettacode.org/wiki/Huffman_coding\">RosettaCode</a>\r\nmain(filename:string)->print('See http://rosettacode.org/wiki/Huffman_coding') and\r\n                       print(\" code\\tchar\\n \"&\r\n                             huffman(charactersInFile(filename)).each(e,\r\n                                  e[0]&\"\\t\"&e[1].escape).join(\"\\n \"));\r\n//*Calls main with unixdict.txt as input\r\nmain->main(inputs.dict);\r\n"]
,['demos/importing.mnh',"USE balancedBrackets,helloWorld,josephus,roman,hereDoc,quine,variadic,shannonEntropy,\n    lastSundays,concatInts,harshad,setConsolidation,subGen,pernicousNumbers,pascal,\n    clock,bestShuffle,primes,range_extract_expand,statistics,opTest,fibonacciWord,\n    hamming,aliquotSequence,lindenmayer,aks,fractran,continuedFractions,rk4,\n    piPlots,sierpinskiTriangle,fibonacci,root;\n\nmain->begin\n  balancedBrackets.main;\n  helloWorld.main;\n  josephus.main;\n  roman.main;\n  hereDoc.main;\n  quine.main;\n  variadic.main;\n  shannonEntropy.main;\n  lastSundays.main;\n  concatInts.main;\n  harshad.main;\n  setConsolidation.main;\n  subGen.main;\n  pernicousNumbers.main;\n  pascal.main;\n  clock.main;\n  bestShuffle.main;\n  primes.main;\n  range_extract_expand.main;\n  statistics.main;\n  opTest.main;\n  fibonacciWord.main;\n  hamming.main;\n  aliquotSequence.main;\n  lindenmayer.main;\n  aks.main;\n  fractran.main;\n  continuedFractions.main;\n  rk4.main;\n  piPlots.main;\n  sierpinskiTriangle.main;\n  fibonacci.main;\n  root.main;\nend;\n"]
,['demos/josephus.mnh',"private Josephus(n:int,k:int)->Josephus([0..(n-1)],k,k-1);\r\nprivate Josephus(L<>[],k,pos)->size(L)=1 ? L : L.get(pos)|Josephus(L.get([0..size(L)-1]<>pos),k,(k+pos-1) mod (size(L)-1));\r\nprivate Josephus(n:int,k:int,survivors:int)->print(\"Prisoners: \",n,\r\n                                                 \"\\nStep size: \",k,\r\n                                                 \"\\nSurvivors: \",tail(Josephus(n,k),n-survivors));\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Josephus_problem\">http://rosettacode.org/wiki/Josephus_problem</a>\r\nmain->Josephus(41,3,1);\r\n//*Call from console with n prisoners a step size of k and a given number of survivors\r\nmain(n:string,k:string,survivors:string)->Josephus(softCast(n),softCast(k),softCast(survivors));\r\n"]
,['demos/kochCurve.mnh',"//*The running sum of the empty list is <code>[]</code>\r\nrunningSum([])->[];\r\n//*Returns the running sum of numeric list L (nested numeric lists are supported)\r\nrunningSum(L)->(size(L)<10 ? [1..size(L)].each(i,head(L,i).agg(+)) : runningSum_merge(runningSum(head(L,size(L) div 2)),runningSum(tail(L,size(L) div 2))));\r\nprivate safePlus(summand     ,list<>[])->summand+list;\r\nprivate runningSum_merge(L1,L2)->L1|safePlus(L1.get(size(L1)-1),L2);\r\n\r\ninterlace(X,Y)->[0..size(X)-1].each(i,[X.get(i),Y.get(i)]);\r\nkochCurve(depth)->kochCurve(depth,1,0);\r\nprivate kochCurve(depth>=0,LX,LY)->kochCurve(depth-1,\r\n  (LX*0.333)|(LX*0.167-LY*0.288)|(LX*0.167+LY*0.288)|(LX*0.333),\r\n  (LY*0.333)|(LY*0.167+LX*0.288)|(LY*0.167-LX*0.288)|(LY*0.333));\r\nprivate kochCurve(depth,LX,LY)->interlace(runningSum(LX),runningSum(LY));\r\n\r\nprivate main_impl(filename:string,xRes:int,yRes:int)->\r\n  plot.setAutoscale([true,true]) and\r\n  plot.setLogscale([false,false]) and\r\n  plot.setPreserveAspect(true) and\r\n  plot.setAxisStyle([0,0]) and\r\n  plot.plot(kochCurve(7),\"0.5\") and\r\n  plot.renderToFile(filename,xRes,yRes,10);\r\n\r\n//*Plots a Koch Curve to file <code>filename</code> using a custom resolution (given as <i>xRes</i><code>x</code><i>yRes</i>)\r\nmain(filename,resolution)->main_impl(filename,softCast(split(resolution,\"x\").get(0)),softCast(split(resolution,\"x\").get(1)));\r\n//*Plots a Koch Curve to file <code>filename</code> using a custom resolution\r\nmain(filename,xRes,yRes )->main_impl(filename,softCast(xRes)                   ,softCast(yRes));\r\n//*Plots a Koch Curve to file <code>filename</code> using a resolution of 1366x768\r\nmain(filename           )->main_impl(filename                        ,1366,768);\r\n//*Plots a Koch Curve using the package path and a resolution of 1366x768\r\nmain                     ->main_impl(replace(myPath&\"#\",\"mnh#\",\"png\"),1366,768);\r\n"]
,['demos/lastSundays.mnh',"private lastSundaysInYear(year:int)->begin\r\n  local lastDays:=floor(parseTime('yyyymmdd',format('%4.4d%2.2d01',year,[2..12])|format('%4.4d0101',year+1)))-1;\r\n  local numberOfDaysAfterSuday:=(lastDays+6) mod 7;\r\n  lastDays-numberOfDaysAfterSuday;\r\nend;\r\n\r\nprivate DATE_FMT:='%{formatTime(\"dd.mm.yyyy\",$0)}s';\r\n\r\n//*Print out the last sundays of each month in 2015\r\nmain->printf(DATE_FMT,lastSundaysInYear(2015));\r\n//*Print out the last sundays of each month in given year\r\nmain(year:string)->printf(DATE_FMT,lastSundaysInYear(softCast(year)));\r\n"]
,['demos/ludic.mnh',"memoized\r\nludics_gen(1)->[1];\r\nludics_gen(2)->[1,2];\r\nludics_gen(n>2)->begin\r\n  print('Generating @',n);\r\n  local L:=ludics_gen(n-1);\r\n  local X:=[2..max(L)*4];\r\n  L.tail.each(ludic,X:=X[[0..size(X)-1] mod ludic<>0]);\r\n  L|X;\r\nend;\r\n\r\nludics_by_size(resultSize)->begin\r\n  local genIndex:=1;\r\n  local result:=ludics_gen(genIndex);\r\n  while(result.size<resultSize,result:=ludics_gen(genIndex+=1));\r\n  head(result,resultSize);\r\nend;\r\n\r\nludics_by_max(maxValue)->begin\r\n  local genIndex:=1;\r\n  local result:=ludics_gen(genIndex);\r\n  while(result.max<maxValue,result:=ludics_gen(genIndex+=1));\r\n  result[result<=maxValue];\r\nend;\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Ludic_numbers\">http://rosettacode.org/wiki/Ludic_numbers</a>\r\nmain->begin\r\n  local LUDICS:=ludics_by_size(2005).unique;\r\n  local triplets:=[0..250].intersect(LUDICS,LUDICS-2,LUDICS-6);\r\n  print(\"Ludic Numbers\",\r\n      \"\\n  The first 25 are: \",LUDICS.head(25),'.',\r\n      \"\\n  There are \",LUDICS[LUDICS<=1000].size,' lesser or equal to 1000.',\r\n      \"\\n  The 2000..2005th are \",LUDICS.get([2000..2005]-1),'.',\r\n      \"\\n  The triplets below 250 are \",format('(%{$0}s,%{$0+2}s,%{$0+6}s)',triplets).join(','));\r\nend;\r\n"]
,['demos/magicSquare.mnh',"private printSquare(S)->print(S.each(row,row.join(\"\\t\")).join(\"\\n\")) and\r\n                        print(\"The magic number is \",S.get(0).agg(+));\r\nprivate set(S:list,I,J,k)->[0..size(S)-1].each(i,i=I ? [0..size(S)-1].each(j,j=J ? k : S.get(i).get(j)) : S.get(i));\r\n\r\nprivate makeSquare(n:int)->makeSquare_(n<1 ? 1 : (n and 1)=0 ? n+1 : n);\r\nprivate makeSquare_(n:int)->makeSquare_(n,[0..n-1].each(i,[0..n-1].each(j,i=0 and j=n div 2 ? 1 : 'x')),n-1,(n div 2)+1,2);\r\nprivate makeSquare_(n,S:list,i,j,k)->k<n*n ? makeSquare_(n,set(S,i,j,k),\r\n                                                         k mod n=0 ? (i+1) mod n : (i+n-1) mod n,\r\n                                                         k mod n=0 ? j           : (j+1)   mod n,\r\n                                                         k+1)\r\n                                           : set(S,i,j,k);\r\n\r\n//*Print out an 21x21 magic square for regression testing\r\nmain->printSquare(makeSquare(21));\r\n\r\n//*Print out an n x n magic square; See <a href=\"http://rosettacode.org/wiki/Magic_squares_of_odd_order\">http://rosettacode.org/wiki/Magic_squares_of_odd_order</a>\r\nmain(n)->printSquare(makeSquare(softCast(n)));\r\n"]
,['demos/maze.mnh',"private scramble(List<>[])->List.get(sortPerm(random(size(List))));\r\nprivate scramble([])->[];\r\nprivate neighbors(width,height,index)->neighbors(width,height,index mod width,index div width);\r\nprivate neighbors(width,height,x,y)->\r\n  scramble([x>0        ? [x-1,y] : void,\r\n            y>0        ? [x,y-1] : void,\r\n            x<width-1  ? [x+1,y] : void,\r\n            y<height-1 ? [x,y+1] : void].each(p,p.get(0)+p.get(1)*width));\r\n\r\nprivate unvisitedNeighbor(width,height,currentIndex,visited)->\r\n  neighbors(width,height,currentIndex)\r\n  .each(next,next in visited ? void : next)\r\n  .head;\r\n\r\nprivate randomUnvisitedCell(width,height,visited)->\r\n  head(scramble([0..width*height-1].each(i,i in visited ? void : i)));\r\n\r\nprivate makeMaze(width,height)->\r\nbegin\r\n  local visited:=[];\r\n  local position:=randomUnvisitedCell(width,height,visited);\r\n\r\n  while(not(position==[]),begin\r\n    visited|=position;\r\n    local continue:=true;\r\n    while(continue,begin\r\n      local next:=unvisitedNeighbor(width,height,position,visited);\r\n      next==[] ? continue:=false : begin\r\n        position:=next;\r\n        visited|=next;\r\n      end;\r\n    end);\r\n    position:=randomUnvisitedCell(width,height,visited);\r\n  end);\r\n\r\n  local visitPairs:=[0..size(visited)-2].each(i,sort(visited.get([i,i+1])));\r\n  [0..height-1].each(j,\r\n       [0..width-1].each(i,[i+(j-1)*width,i+j*width] in visitPairs ? \"+   \" : \"+---\",&)&\"+\",   //wall [i,j]->[i,j-1];\r\n       [0..width-1].each(i,[(i-1)+j*width,i+j*width] in visitPairs ? \"    \" : \"|   \",&)&\"|\")  //wall [i,j]->[i-1,j]\r\n     |([0..width-1].each(i,\"+---\",&)&\"+\");\r\nend;\r\n\r\n//*See http://rosettacode.org/wiki/Maze_generation\r\nmain->printf(\"%s\",makeMaze(20,20));\r\n"]
,['demos/monteCarloPi.mnh',"private monteCarloPi(sampleSize>0)->4*samplesInCircle(sampleSize)/sampleSize;\r\n\r\n//Note:     To improve performance, replace this |vvvv| \"each\" by \"pEach\" - however this will lead to nondeterministic results\r\nprivate samplesInCircle(sampleSize>10000)->[1..9].each(i,samplesInCircle(sampleSize div 10),+)+samplesInCircle(sampleSize-9*(sampleSize div 10));\r\n\r\nprivate samplesInCircle(sampleSize>0)->trueCount(random(sampleSize)^2+random(sampleSize)^2<1);\r\n\r\n//*Solves the \"Monte carlo methods\" task from <a href=\"http://rosettacode.org/wiki/Monte_Carlo_methods\">RosettaCode</a>\r\nmain->print('See http://rosettacode.org/wiki/Monte_Carlo_methods') and\r\n      printf(\"n=%7d pi approximated as %-9.7g\",10^[1..6],(10^[1..6]).each(n,monteCarloPi(n)));\r\n"]
,['demos/pascal.mnh',"memoized\r\nprivate tri(1)->1;                       //returns first line\r\nprivate tri(n>1)->tri(n-1)|1+1|tri(n-1); //returns n-th line\r\nprivate printTri(n:int)->printf(\"%s\",[1..n].each(i,repeat(\"\\t\",n-i)&tri(i).join(\"\\t\\t\")));\r\n\r\n//*Simple output\r\nmain->printTri(10);\r\n//*See <a href=\"http://rosettacode.org/wiki/Pascal%27s_triangle\">http://rosettacode.org/wiki/Pascal's_triangle</a>\r\nmain(lineCount)->printTri(softCast(lineCount));\r\n"]
,['demos/pernicousNumbers.mnh',"private primes:=[2,3,5];\r\nprivate primes:=primes|[6..31].each(n,trueCount(n mod primes=0)=0 ? n : void);\r\nprivate isPernicious(n:int)->trueCount((2^[0..32] and n)>0) in primes;\r\nprivate pernicousInRange(iMin,iMax)->[iMin..iMax].each(i,isPernicious(i) ? i : void);\r\n//*See <a href=\"http://rosettacode.org/wiki/Pernicious_numbers\">http://rosettacode.org/wiki/Pernicious_numbers</a>\r\nmain->print(head(pernicousInRange(0,50),25),\"\\n\",\r\n            pernicousInRange(888888877,888888888));\r\n"]
,['demos/piPlots.mnh',"//Binominalkoeffizient Ã¼ber Pascalsches Dreieck:\r\nmemoized\r\nprivate pascal(n)->pascal([1],n);\r\nprivate pascal(L,n>0)->pascal(L|0+0|L,n-1);\r\nprivate pascal(L,n)->L;\r\n\r\n//Summe und gleitende Summen:\r\nprivate sum(L)->L.agg(+);\r\nprivate rsum(L)->begin\r\n  local S:=0;\r\n  L.each(x,S+=x).get([size(L)-1..0]);\r\nend;\r\n\r\nprivate weights(n)->rsum(pascal(n))/(2^n);\r\nprivate arcTanSummand(i)->(-1)^i/(2*i+1);\r\n\r\nprivate summands(n)->arcTanSummand([0..n]);\r\nprivate maxN:=39;\r\n\r\nprivate sum1(i)->sum(summands(i));\r\nprivate sum2(i)->sum(summands(i)*weights(i));\r\nprivate errors1->[1..maxN].each(i,abs(sum1(i)-arctan(1)));\r\nprivate errors2->[1..maxN].each(i,abs(sum2(i)-arctan(1)));\r\nprivate T (i)->abs(time({sum1($p)},[i]).get([2,1]).getInner(1)-[0,arctan(1)])*[60000,1];\r\nprivate T2(i)->abs(time({sum2($p)},[i]).get([2,1]).getInner(1)-[0,arctan(1)])*[60000,1];\r\n\r\ndoPlot->begin\r\n  plot.setLogscale([true,true]);\r\n  plot.setAutoscale([true,true]);\r\n  plot.setPreserveAspect(false);\r\n  print('Row #1: series A, error vs. summand count');\r\n  plot([1..maxN],errors1,\"black l .\");\r\n  print('Row #2: series B, error vs. summand count');\r\n  addPlot([1..maxN],errors2,\"red l .\");\r\n  print('Row #3: series A, error vs. time');\r\n  addPlot([1..maxN].each(i,T(i)),\"black x +\");\r\n  print('Row #4: series B, error vs. time');\r\n  addPlot([1..maxN].each(i,T2(i)),\"red x +\");\r\nend;\r\n\r\nmain('plot')->doPlot and renderToFile(replace(myPath&\"#\",\".mnh#\",\".png\"),768,768,4);\r\n\r\nmain->printf('%17.15f %17.15f',errors1,errors2);\r\n\r\ndoPlot;\r\n"]
,['demos/pythagoras.mnh',"private oyako(a,b,c,perimeter)->\r\n  a+b+c>perimeter\r\n  ? [                       0,0]\r\n  : [floor(perimeter/(a+b+c)),1]+\r\n    [[ a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c, perimeter],\r\n     [ a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c, perimeter],\r\n     [-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c, perimeter]].pEach(abc,oyako@abc,+);\r\n\r\nprivate oyako(perimeter)->format@(\"In perimeter <=%7d there are %6d pythagorean triplets, %5d of which are primitive\"|perimeter|oyako(3,4,5,perimeter));\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Pythagorean_triples\">http://rosettacode.org/wiki/Pythagorean_triples</a>\r\nmain('rosetta')->each(i,10^[1..6],print(oyako(i)));\r\n//*As above, but abridged for reg test\r\nmain->(10^[1..5]).each(i,print(oyako(i)));\r\n"]
,['demos/quine.mnh',"main:={print(\"main:=\", main)}\r\n"]
,['demos/range_extract_expand.mnh',"private exampleList:=\r\n  [0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\r\n  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\r\n  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\r\n  37, 38, 39];\r\nprivate exampleRange:=\"-6,-3--1,3-5,7-11,14,15,17-20\";\r\n\r\nprivate extractRange(L:intList)->begin\r\n  local deltaIdx:=-1|[0..size(L)-2].get(leading(L)+1<>tail(L))|(size(L)-1);\r\n  [0..size(deltaIdx)-2].each(k,[L.get(deltaIdx.get(k)+1),L.get(deltaIdx.get(k+1))]);\r\nend;\r\n\r\nprivate mnhForm   (R)->\"[\"&R.each(run,{$x=$y ? $x : $x&\"..\"&$y}@run).join(\",\")&\"]\";\r\nprivate normalForm(R)->    R.each(run,{$x=$y ? $x : $x&\"-\"& $y}@run).join(\",\")    ;\r\n\r\nprivate range(x)->x;\r\nprivate range(x0,x1)->[x0..x1];\r\n\r\nprivate expandRange(s:string)->split(s,\",\").each(run,range@softCast(split(replace(run,[\"0\"..\"9\"]&\"-\",[\"0\"..\"9\"]&\";\"),\";\")),|);\r\n\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Range_expansion\">http://rosettacode.org/wiki/Range_expansion</a>\r\n//*and <a href=\"http://rosettacode.org/wiki/Range_expansion\">http://rosettacode.org/wiki/Range_expansion</a>\r\nmain->print(\"Canonical form (as given by rosettacode.org):\")|\r\n      print(\"  The list\\t\"               ,                                    exampleList,\r\n            \"\\n  can be represented as\\t\",            normalForm(extractRange(exampleList)),\r\n            \"\\n  and be re-expanded to\\t\",expandRange(normalForm(extractRange(exampleList)))) |\r\n      print(\"\\n  The range\\t\"              ,                                    exampleRange,\r\n            \"\\n  can be expanded to\\t\"     ,                        expandRange(exampleRange),\r\n            \"\\n  and be re-compressed to\\t\",normalForm(extractRange(expandRange(exampleRange))) )|\r\n      print(\"\\nMNH form:\")|\r\n      print(\"  The list\\t\"               ,                                  exampleList,\r\n            \"\\n  can be represented as\\t\",             mnhForm(extractRange(exampleList)),\r\n            \"\\n  and be re-expanded to\\t\",toExpression(mnhForm(extractRange(exampleList)))());\r\n"]
,['demos/rk4.mnh',"//*Solves the autonomous Differential equation y(0)=y0; dy/dt=F; returns y(dt)\r\nRK4(F:expression,y0,dt>0.0)->begin\r\n  local F1:=dt*F(y0       );\r\n  local F2:=dt*F(y0+0.5*F1);\r\n  local F3:=dt*F(y0+0.5*F2);\r\n  local F4:=dt*F(y0    +F3);\r\n  y0+(1/6)*(F1+2*F2+2*F3+F4);\r\nend;\r\n\r\n//*Solves the autonomous Differential equation y(0)=y0; dy/dt=F; returns y(tEnd)\r\nrk4evolve(F,y0,dt,tEnd>0.0)->(y0:scalar ? y0 : [y0]) |rk4evolve(F,RK4(F,y0,dt),dt,round(tEnd-dt,3));\r\nrk4evolve(F,y0,dt,tEnd    )->(y0:scalar ? y0 : [y0]);\r\n\r\nprivate df     :={[1,$x.get(0)*sqrt($x.get(1))]};\r\nprivate initial:=[0,1];\r\nprivate exact  :={1/16*($t^2+4)^2};\r\n\r\n//*Solves the Runge-Kutta task from <fga href=\"http://rosettacode.org/wiki/Runge-Kutta_method\">Rosetta Code</a>\r\nmain->begin\r\n  local steps:=rk4evolve(df,initial,0.1,10).each(p,[p.get(0),p.get(1),abs(p.get(1)-exact(p.get(0)))]);\r\n  printf(\"%4.1f\\t%g\\t%e\",\r\n         'time'|steps.getInner(0),\r\n         'approximation'|steps.getInner(1),\r\n         'error'|steps.getInner(2));\r\nend;  \r\n"]
,['demos/roman.mnh',"private digT:=['','1','11','111','15','5','51','511','5111','10'];\r\nprivate dig1:=replace(digT,['1','5','0'],['I','V','X']);\r\nprivate dig2:=replace(digT,['1','5','0'],['X','L','C']);\r\nprivate dig3:=replace(digT,['1','5','0'],['C','D','M']);\r\n\r\n\r\nroman(I:intList)->I.each(i,roman(i));\r\nroman(i:int)->i > 1000 ? \"M\" & roman(i-1000) :\r\n              dig3.get(i div 100 mod 10) &\r\n              dig2.get(i div 10  mod 10) &\r\n              dig1.get(i         mod 10);\r\narabic(S:stringList)->S.each(s,arabic(s));\r\narabic(s:string)->toExpression(replace(s,['CM','CD','M','D',\r\n                                          'XC','XL','C','L',\r\n                                          'IX','IV','X','V','I'],\r\n                                         ['+900','+400','+1000','+500',\r\n                                          '+90' ,'+40' ,'+100' ,'+50' ,\r\n                                          '+9'  ,'+4'  ,'+10'  ,'+5','+1']))();\r\nprivate roman_input:=['MMXV','MCMXC','MMVIII','MDCLXVI'];\r\nprivate arabic_input:=[2000,1989,23,1666];\r\n\r\nmain->printf('%-10s (roman)  = %10d (arabic)',roman_input,arabic(roman_input)) |\r\n      printf('%10d (arabic) = %-10s (roman)',arabic_input,roman(arabic_input));\r\n"]
,['demos/root.mnh',"regulaFalsi(F:expression,x0input:numeric,x1input>x0input,steps>0)->begin\r\n  local x0:=x0input;\r\n  local f0:=F(x0);\r\n  local x1:=x1input;\r\n  local f1:=F(x1);\r\n  [1..steps].each(step,\r\n    f0=0 or f1=0 ? void :\r\n    begin\r\n      local xm:=x1-f1*(x0-x1)/(f0-f1);\r\n      local fm:=F(xm);\r\n      sign(f0)=sign(fm)\r\n      ? begin f0:=fm; x0:=xm; end\r\n      : begin f1:=fm; x1:=xm; end;\r\n      void;\r\n    end\r\n  );\r\n  abs(f1)<abs(f0) ? x1 : x0;\r\nend;\r\n\r\nroots(F:expression,x0:numeric,x1:numeric)->begin\r\n  local X:=x0|sort(x0+random(1000)*(x1-x0))|x1;\r\n  local S:=X.each(x,sign(F(x)));\r\n  [0..size(S)-2].each(i,S.get(i)<>S.get(i+1) ? regulaFalsi(F,X.get(i),X.get(i+1),100) : void);\r\nend;\r\n\r\nprivate epsilon:=1E-12;\r\n\r\nmain(F:expression)->print(\"Analyzing \",F) and\r\n                    roots(F,-6,6).each(r,print(\"Root found \",abs(F(r))<epsilon?\"at   \":\"near \",r));\r\nmain(F:string)->main(expression(F));\r\n//*Solves the \"Roots of a function\" task from <a href=\"http://rosettacode.org/wiki/Roots_of_a_function\">RosettaCode</a>\r\nmain->print('See http://rosettacode.org/wiki/Roots_of_a_function') and\r\n      main({$x^3-3*$x^2+2*$x});\r\n"]
,['demos/selfRefSeq.mnh',"private memoized //use memoization because this will be called again...\r\nstep(s:string)->\r\n  s.chars            //split the string in characters\r\n   .elementFrequency //transform characters to a list [[count1,char1],[count2,char2],...]\r\n   .flatten          //flatten to [count1,char1,count2,char2,...]\r\n   .join;            //join the list to one string\r\n\r\nseries(i:int)->begin\r\n  local s:=toString(i);\r\n  s:=sort(copy(s,[0..length(s)-1],1)).join;\r\n  local result:=[];\r\n  while(not(s in result),begin\r\n    result|=s;\r\n    s:=step(s);\r\n  end);\r\n  result;\r\nend;\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Self-referential_sequence\">http://rosettacode.org/wiki/Self-referential_sequence</a>\r\nmain->print([1..10000].pEach(i,series(i),aggregator({size($x)<size($y) ? $y : $x})).join(', '));\r\n"]
,['demos/semordnilap.mnh',"USE anagram,inputs;\r\n\r\nprivate findSemordnilaps->\r\n  readDict(inputs.dict)\r\n  .anagramsInDict\r\n  .pEach(anagramGroup,\r\n        begin\r\n          local semordnilapGroup:=intersect(anagramGroup,reverseString(anagramGroup));\r\n          size(semordnilapGroup)==0 ? void : semordnilapGroup;\r\n        end);\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Semordnilap\">http://rosettacode.org/wiki/Semordnilap</a>\r\nmain->begin\r\n  local fullList:=findSemordnilaps;\r\n  printf('Found %d Semordnilaps',size(fullList));\r\n  printf(\"%s\\t%s\",['Examples:','','','',''],fullList.get(intRandom(size(fullList),5)));\r\nend;\r\n"]
,['demos/setConsolidation.mnh',"private unpack(s:string)->toExpression(replace(s,[\"{\" ,\",\"   ,\"}\",\" \"],\r\n                                                 [\"['\",\"','\",\"']\",\",\"]))();\r\nprivate pack(L)->replace(\"#\"&toString(L)&\"#\",[\"'\",'\"',\"[\",\"]\",\"#{\",\"}#\"],\r\n                                             ['' ,'' ,\"{\",\"}\" ,\"[\",\"]\" ]);\r\nprivate consolidate(s:string)->unpack(s).consolidate.pack;\r\nprivate consolidate(ListOfSets<>[])->\r\n  size(ListOfSets)=1\r\n  ? ListOfSets\r\n  : consolidate(ListOfSets,unique(flatten(ListOfSets)));\r\n\r\nprivate consolidate(ListOfSets,consolidationPoints)->\r\n  consolidationPoints==[]\r\n  ? ListOfSets\r\n  : begin\r\n      local mask:=ListOfSets.each(set,consolidationPoints.head in set);\r\n      consolidate([ListOfSets.get(mask).flatten.unique]|ListOfSets.get(not(mask)),consolidationPoints.tail);\r\n    end;\r\n  \r\nprivate examples:=[\"[{A,B} {C,D}]\",\"[{A,B} {B,C}]\",\"[{A,B} {C,D} {D,B}]\",\"[{h,i,k} {a,b} {c,d} {d,b} {f,g,h}]\"];\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Set_consolidation\">http://rosettacode.org/wiki/Set_consolidation</a>\r\nmain->examples.each(e,print('Consolidation of ',e,\"\\n\",\r\n                            '              is ',consolidate(e)));\r\n"]
,['demos/shannonEntropy.mnh',"shannonEntropy(s:string)->shannonEntropy(s.chars);\r\nshannonEntropy(C:stringList)->-1*(unique(C).each(c,trueCount(C=c))/size(C)).each(s,s*ln(s)/ln(2),+);\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Entropy\">Entropy task from RosettaCode</a>\r\nmain->main(\"1223334444\");\r\n//*Print out the Shannon entropy of <code>s</code>\r\nmain(s)->print(shannonEntropy(s));\r\n"]
,['demos/sierpinskiCarpet.mnh',"//*See <a href=\"http://rosettacode.org/wiki/Sierpinski_carpet\">http://rosettacode.org/wiki/Sierpinski_carpet</a>\r\nmain->printf(\"%s\", [0..80].each(i,[0..80].each(j,{($ix mod 3)<>1 OR ($iy mod 3)<>1 ? ($ix>2<$iy ? $self($ix div 3,$iy div 3) : \"[]\") : \"  \"}(i,j),&)));\r\n"]
,['demos/sierpinskiCurve.mnh',"private deg45:=arctan(1);\r\n\r\nsc(depth)->begin\r\n  local result:=[];\r\n  local position:=[0.353553390593275,0.707106781186549]*2;\r\n  local direction:=deg45;\r\n  local half:={$level <=0 ? result|=[position+=[cos(direction),sin(direction)]] : begin\r\n    $self($level-1);\r\n    direction+=deg45;\r\n    result|=[position+=[cos(direction),sin(direction)]*sqrt(2)];\r\n    direction+=deg45;\r\n    $self($level-1);\r\n\r\n    direction-=deg45*2;\r\n    result|=[position+=[cos(direction),sin(direction)]];\r\n    direction-=deg45*2;\r\n\r\n    $self($level-1);\r\n    direction+=deg45;\r\n    result|=[position+=[cos(direction),sin(direction)]*sqrt(2)];\r\n    direction+=deg45;\r\n    $self($level-1);\r\n  end};\r\n  [0..1].each(i,begin\r\n    half(depth);\r\n    direction-=deg45*2;\r\n    result|=[position+=[cos(direction),sin(direction)]];\r\n    direction-=deg45*2;\r\n    void; end);\r\n  (result|result.get([0]))/2^depth;\r\nend;\r\n\r\nmain->begin\r\n  plot.setAxisStyle([0,0]);\r\n  plot   (sc(1),'l 32 GREY0.96875');\r\n  addPlot(sc(2),'l 16 GREY0.9375');\r\n  addPlot(sc(3),'l  8 GREY0.875');\r\n  addPlot(sc(4),'l  4 GREY0.75');\r\n  addPlot(sc(5),'l  2 GREY0.5');\r\n  addPlot(sc(6),'l  1 black');\r\n  plot.renderToFile(replace(myPath&\"#\",\"mnh#\",\"png\"),768,768,4);\r\nend;\r\n"]
,['demos/sierpinskiTriangle.mnh',"//*Solves the \"Sierpinski-Triangle\" task from <a href=\"http://rosettacode.org/wiki/Sierpinski_triangle\">RosettaCode</a>\r\nmain(recursionDepth:string)->begin\r\n  local n:=softCast(recursionDepth);\r\n  printf(\"%{repeat(' ',$i)&[0..2^$n-1].each(j,trueCount(($i and 2^[$n-1..0])>0<(j and 2^[$n-1..0]))=0 ? 'A ' : '  ',&)}s\",[2^n-1..0],n);\r\nend;\r\n\r\n//*For test\r\nmain->main('5');\r\n"]
,['demos/stringFib.mnh',"private lengthLimit:=18;\r\n\r\nplus(x:string,y:string)->begin\r\n  local result:='';\r\n  local maxLen:=max(length(x),length(y));\r\n  local X:=repeat('0',maxLen-length(x))&x;\r\n  local Y:=repeat('0',maxLen-length(y))&y;\r\n  local carry:=0;\r\n  while(length(X)>0,begin\r\n    local sum:=toString(softCast(copy(X,length(X)-lengthLimit,lengthLimit))+\r\n                        softCast(copy(Y,length(Y)-lengthLimit,lengthLimit))+\r\n                        carry);\r\n    sum:=repeat('0',lengthLimit-length(sum))&sum;\r\n    X:=copy(X,0,length(X)-lengthLimit);\r\n    Y:=copy(Y,0,length(Y)-lengthLimit);\r\n    result:=copy(sum,length(sum)-lengthLimit,lengthLimit) & result;\r\n    carry:=softCast(\"0\"&(copy(sum,0,length(sum)-lengthLimit)));\r\n    void;\r\n  end);\r\n  result:=replace('#'&carry&result,['#0','#'],['#','']);\r\n  result='' ? \"0\" : result;\r\nend;\r\n\r\nmemoized stringFib(i:int)->i<=1 ? \"1\" : stringFib(i-1).plus(stringFib(i-2));\r\n\r\n//*Prints out the first 1000 Fibonacci-Numbers\r\nmain->printf(\"%s\\t\",[1..1000].each(i,stringFib(i)));\r\n"]
,['demos/subGen.mnh',"private m109(x>=0)->x mod 10^9;\r\nprivate m109(x)->m109(x+10^9);\r\n\r\nmemoized\r\nprivate s(0)->292929;\r\nprivate s(1)->1;\r\nprivate s(n<=54)->m109(s(n-2)-s(n-1));\r\n\r\nmemoized\r\nprivate r(n<=54)->s((34*(n+1)) mod 55);\r\nprivate r(n)->m109(r(n-55)-r(n-24));\r\n//See: <a href=\"http://rosettacode.org/wiki/Subtractive_generator\">http://rosettacode.org/wiki/Subtractive_generator</a>\r\nmain->[220..222].each(i,printf('%3d : %9d',i,r(i)));\r\n"]
,['demos/sudoku.mnh',"private drop(list:intList,toDrop:int)->list[list!=toDrop];\r\nprivate drop(list:intList,toDrop:intList)->list.minus(toDrop);\r\n\r\nprivate\r\nCOMPONENTS:=[0..8].each(i,i+[0..8]*9)|\r\n            [0..8].each(i,i*9+[0..8])|\r\n            [0..8].each(i,[0..80].get(i=([0..80] div 27)*3+[0..80] mod 9 div 3));\r\n\r\nprivate memoized connectedIdx(i:int)->COMPONENTS.each(c,i in c ? drop(c,i) : void).flatten.sort;\r\nprivate memoized components(i)->COMPONENTS.each(c,i in c ? drop(c,i) : void);\r\n\r\n//*A board is solved when all components contain numbers [1..9]\r\nprivate isSolved(Board)->COMPONENTS.each(c,Board[c].sort==[1..9],AND);\r\n//*A board is valid when all components may contain all numbers [1..9]\r\nprivate isValid(Board)->Board.each(cell,not(cell==[]),AND) AND\r\n                        COMPONENTS.each(c,Board[c].flatten.unique==[1..9],AND);\r\n//*A board's difficulty is given by the number of cells to fill\r\nprivate difficulty(Board)->Board.each(cell,cell:int ? 0 : 1,+);\r\n\r\nprivate\r\ninitialBoard->begin\r\n  local values:=1+random(9).sortPerm;\r\n  local indexes:=[0..8]*9+random(9).sortPerm;\r\n  [0..80].each(i,i in indexes ? values[indexes=i,0] : [1..9]);\r\nend;\r\n\r\nprivate\r\nprintBoard(B)->[0..8].each(row,print(row in [3,6] ? \"---------+---------+---------\\n\" : '',\r\n               [0..8].each(col,begin\r\n                 local i:=col+9*row;\r\n                 (col in [3,6] ? '|' : '')&\r\n                 \" \"&(B[i] :int ? B[i] : \" \")&\" \";\r\n               end,&)))|B;\r\n\r\nprivate\r\nsolve(B)->begin\r\n  local needRun:=isValid(B);\r\n  local Board:=B;\r\n  while(needRun,\r\n  begin\r\n    needRun:=false;\r\n    local intsOnly:=Board.each(c,c:int ? c : []);\r\n    Board:=[0..80].each(i,\r\n      Board[i]:int\r\n      ? Board[i]\r\n      : begin\r\n          local newList:=drop(Board[i],intsOnly[connectedIdx(i)].flatten);\r\n          size(newList)=1\r\n          ? begin\r\n              needRun:=true;\r\n              newList[0];\r\n            end\r\n          : begin\r\n              local tmp:=drop(Board[i],flatten(Board.get(components(i)[0])));\r\n              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : begin\r\n              tmp:=drop(Board[i],Board.get(components(i)[1]).flatten);\r\n              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : begin\r\n              tmp:=drop(Board.get(i),Board.get(components(i)[2]).flatten);\r\n              size(tmp)=1 ? begin needRun:=true; tmp[0]; end : newList; end; end;\r\n            end;\r\n        end);\r\n  end);\r\n  Board;\r\nend;\r\n\r\nprivate\r\nbruteForceSolve(B)->begin\r\n  local Board:=solve(B);\r\n  isSolved(Board) ? Board : begin\r\n    local firstListIdx:=min(81|each(i,[0..80],Board[i]:int ? void : i));\r\n    local candidates:=Board[firstListIdx];\r\n    local numberOfSolutions:=0;\r\n    local finalSolution:=void;\r\n    each(candidate,candidates,numberOfSolutions>1 ? void : begin\r\n      local newSolution:=bruteForceSolve(each(i,[0..80],i=firstListIdx ? candidate : Board[i]));\r\n      isSolved(newSolution)\r\n      ? begin\r\n          finalSolution:=newSolution;\r\n          numberOfSolutions+=1;\r\n        end\r\n      : void;\r\n    end);\r\n    numberOfSolutions=1 ? finalSolution : initialBoard;\r\n  end;\r\nend;\r\n\r\nprivate restrictRandom(B)->begin\r\n  local listIndexes:=[0..80].each(i,B[i]:int ? void : i);\r\n  listIndexes==[] ? B : begin\r\n    local randomListIdx:=listIndexes[intRandom(size(listIndexes))];\r\n    [0..80].each(i,i=randomListIdx ? B[i,intRandom(size(B.get(i)))] : B[i]);\r\n  end;\r\nend;\r\n\r\nrandomSolution->begin\r\n  local foundSolution:=false;\r\n  local Board:=void;\r\n  while(not(foundSolution),begin\r\n    Board:=initialBoard.restrictRandom.solve;\r\n    while(isValid(Board) AND not(Board.isSolved),Board:=Board.restrictRandom.solve);\r\n    foundSolution:=Board.isSolved;\r\n  end);\r\n  Board;\r\nend;\r\n\r\nrandomRiddle->begin\r\n  local riddle:=randomSolution;\r\n  random(81).sortPerm.each(undefIdx,begin\r\n    local previousRiddle:=riddle;\r\n    riddle:=[0..80].each(i,i=undefIdx ? [1..9] : riddle[i]);\r\n    riddle.solve.isSolved ? void : riddle:=previousRiddle;\r\n    void;\r\n  end);\r\n  print('Generated a riddle with difficulty: ',riddle.difficulty);\r\n  riddle;\r\nend;\r\n\r\n//*For regression test: create a random riddle and print it out\r\nmain->randomRiddle.printBoard;\r\n\r\n"]
,['demos/task.mnh',"//*Format is [[name1,timeSpent1],[name2,timeSpent2],...]\r\nprivate persistent allTasks:=[];\r\n//*Format is [name,timeSpent,startedAt]\r\nprivate persistent runningTask:=[];\r\n\r\nprivate endTask->runningTask==[] ? void : //If there is no running task, there is nothing to do\r\nbegin\r\n  allTasks:=each(t,allTasks,\r\n                 t%0=runningTask%0\r\n                 ? begin\r\n                     printf(\"Task %s finished after %{formatTime('hh:nn:ss',$1)}s; total time spent: %{formatTime('hh:nn:ss',$2)}s\",\r\n                      t%0,systime-runningTask%2,t%1+systime-runningTask%2);\r\n                     [t%0,                      t%1+systime-runningTask%2];\r\n                   end\r\n                 : t);\r\n  runningTask:=[];\r\nend;\r\n\r\n//*Ends the current task and lists all tasks\r\nmain()->begin\r\n  endTask;\r\n  print('All tasks:');\r\n  printf(\"  %s\\t%{$1:string?$1:formatTime('hh:nn:ss',$1)}s\",\r\n    'Task'      | allTasks%%0,\r\n    'Time spent'| allTasks%%1);\r\nend;\r\n\r\n//*Resumes a task\r\nmain('?')->size(allTasks)>0 \r\n           ? main(ask('Task to resume',allTasks%%0))\r\n           : print('There are no tasks to resume.');\r\n\r\n//*Resumes a task or starts a new one\r\nmain(taskName)->begin\r\n  endTask;\r\n  trueCount(allTasks%%0=taskName)=0\r\n  ? begin allTasks|=[leading(runningTask:=[taskName,0,systime])]; print('New task ',taskName); end\r\n  : begin runningTask:=(allTasks%(allTasks%%0=taskName)%0)|systime; print('Resmuming task ',taskName); end;\r\nend;\r\n"]
,['demos/timer.mnh',"//This is the safest way to parallelize a list of tasks;\r\nprivate parallelize(...)->\r\n  size(...)=0 OR ... .each(task,task:expression,AND)\r\n  ? ... .PEach(task,task())\r\n  : fail('parallelize expects expressions as arguments');\r\n\r\n//This must be a global variable because it is shared by different threads (A1 and A2)\r\nprivate mutable beepOn:=true;\r\nbeepUntilKeyIsPressed:={parallelize(\r\n {while(beepOn,begin [1..4].each(i,beep(1000,100)); sleep(1); end)},                //A1\r\n {begin ask('Press Enter to stop this annoying beeping...'); beepOn:=false; end})}; //A2\r\n \r\nprivate lockScreen:={execPipeless('rundll32.exe',['user32.dll,LockWorkStation'])};\r\n\r\n//Just a conversion factor\r\nprivate MINUTES_PER_DAY:=24*60;\r\n//This must be a global variable because it is shared by different threads (B1 and B2)\r\nprivate mutable timerCancelled:=false;\r\n\r\nmain->begin\r\n  local timerAction:=ask('Timer action...',['Beep','Lock screen'])='Beep'\r\n  ? beepUntilKeyIsPressed\r\n  : lockScreen;\r\n  local timeOut:=systime+softCast(ask('Time in minutes'))/MINUTES_PER_DAY;\r\n  parallelize(\r\n    {begin //B1\r\n       while(not(timerCancelled) AND systime<timeOut,\r\n       begin\r\n         print(formatTime('hh:mm:ss',timeOut-systime),' - press Enter to cancel');\r\n         sleep(1);\r\n         clearPrint;\r\n       end);\r\n       timerCancelled ? void : timerAction();\r\n     end},\r\n    {begin //B2\r\n       ask('');\r\n       timerCancelled:=true;\r\n     end});\r\nend;\r\n"]
,['demos/travellingSalesmanProblem.mnh',"private points:=[0..1199].each(i,sqrt(i)*[cos(2.39996323*i),sin(2.39996323*i)]).each(p,-25<p.get(0)<25 and -25<p.get(1)<25 ? p : void);\r\n\r\nprivate norm(x)->sqrt(x.sqr.agg(+));\r\n\r\nprivate pathLength(points)->begin\r\n  local result:=0;\r\n  local lastPoint:=points.trailing;\r\n  points.each(p,result:=result+norm(lastPoint-p),lastPoint:=p);\r\n  result;\r\nend;\r\n\r\nprivate len4(a,b,c,d)->norm(b-a)+norm(c-b)+norm(d-c);\r\n\r\nscSort(L)->begin\r\n  local x:=L.getInner(0); local xr:=[min(x),max(x)];\r\n  local y:=L.getInner(1); local yr:=[min(y),max(y)];\r\n  local h:=max(xr.get(1)-xr.get(0),yr.get(1)-yr.get(0))/2;\r\n  xr:=(xr.get(1)+xr.get(0))*0.5;\r\n  yr:=(yr.get(1)+yr.get(0))*0.5;\r\n  local x0:=xr-h;\r\n  local x1:=xr+h;\r\n  local y0:=yr-h;\r\n  local y1:=yr+h;\r\n  local mask:=sqr(x-x0)+sqr(y-y1)<\r\n              sqr(x-x1)+sqr(y-y0);\r\n  local result:=scSort_(x0,y0,x0,y1,x1,y1,x.get(    mask ),y.get(    mask ))|\r\n                scSort_(x1,y1,x1,y0,x0,y0,x.get(not(mask)),y.get(not(mask)));\r\n  print('Path length after construction is ',round(pathLength(result),3));\r\n  result;\r\nend;\r\n\r\npolish(L)->begin\r\n  local result:=L;\r\n  local changing:=true;\r\n  while(changing,begin\r\n    changing:=false;\r\n    [0..size(result)-1].each(i,begin\r\n      local beforeSwapping:=len4@(result.get([i,i+1,i+2,i+3] mod size(result)));\r\n      local afterSwapping :=len4@(result.get([i,i+2,i+1,i+3] mod size(result)));\r\n      afterSwapping<beforeSwapping ? begin\r\n        changing:=true;\r\n        local j0:=(i+1) mod size(result);\r\n        local j1:=(i+2) mod size(result);\r\n        result:=result.get([0..size(result)-1].each(j,j=j0 ? j1 :\r\n                                                      j=j1 ? j0 : j));\r\n        void;\r\n      end : void;\r\n    end);\r\n  end);\r\n  print('Path length after polishing is    ',round(pathLength(result),3));\r\n  result;\r\nend;\r\n\r\nprivate scSort_(ax:numeric,ay:numeric,bx:numeric,by:numeric,cx:numeric,cy:numeric,x:numericList,y:numericList)->\r\n  size(x)>1\r\n  ? (sqr(ax-cx)+sqr(ay-cy)>1E-12\r\n    ? begin\r\n        local mask:=sqr(x-ax)+sqr(y-ay) <\r\n                    sqr(x-cx)+sqr(y-cy);\r\n        scSort_(ax,ay,(ax+cx)/2,(ay+cy)/2,bx,by,x.get(    mask ),y.get(    mask )) |\r\n        scSort_(bx,by,(ax+cx)/2,(ay+cy)/2,cx,cy,x.get(not(mask)),y.get(not(mask)));\r\n      end\r\n    : begin\r\n        print('Aboring at ',ax,'  ',ay,' | ',\r\n                            bx,'  ',by,' | ',\r\n                            cx,'  ',cy,' with ',size(x),' points');\r\n        each(i,[0..size(x)-1],[x.get(i),y.get(i)]);\r\n      end)\r\n  : size(x)=1 ? [x|y] : [];\r\n\r\n//*Approximately solves the Travelling Salesman Problem using sorting by Sierpinski-Curve\r\nmain->begin\r\n  plot.setAxisStyle([0,0]);\r\n  local L:=polish(scSort(points));\r\n  plot(L|L.get([0]),'. l');\r\n  plot.renderToFile(replace(myPath,'.mnh','.png'),768,768,4);\r\nend;\r\n"]
,['demos/ulam.mnh',"USE primes;\r\n\r\nmemoized\r\nprivate Ulam(1)->[[1]];\r\nprivate Ulam(n)->(n and 1)=0 ? [[n*n..n*(n-1)+1]] | [0..n-2].each(j,(Ulam(n-1).get(j))|(n*(n-1)-j))\r\n                             :                      [0..n-2].each(j,((sqr(n-1)+1+j)| Ulam(n-1).get(j))) | [[n*(n-1)+1..n*n]];\r\n\r\nprivate mark(i<=9)->\" _\"&i;\r\nprivate mark(i<=99)->\" \"&i;\r\nprivate mark(i    )->\" XX\";\r\nprivate UlamSpiral(n:int)->UlamSpiral(Ulam(n),primes(n*n));\r\nprivate UlamSpiral(Lines,Primes)->printf(\"%s\",Lines.each(l,l.each(n,n in Primes ? mark(n)  : \"   \",&)));\r\n\r\n//*Displays a 40x40 Ulam-Spiral\r\nmain->UlamSpiral(40);\r\n//*Displays a n x n Ulam-Spiral\r\nmain(n:string)->info and UlamSpiral(softCast(n));\r\n"]
,['demos/unbiasedRandom.mnh',"mutable N:=3;\r\nprivate biasedRandom->random<1/N ? 1 : 0;\r\nprivate unbiasedRandom->unbias(biasedRandom,biasedRandom);\r\nprivate unbias(x,x)->unbiasedRandom;\r\nprivate unbias(x,y)->x;\r\n\r\nprivate\r\ntestUnbiasing(n:int)->printf('%d %5.2f%% %5.2f%%',N:=n,\r\n                             [1..10000].each(i,  biasedRandom,+)/100,\r\n                             [1..10000].each(i,unbiasedRandom,+)/100);\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Unbias_a_random_generator\">http://rosettacode.org/wiki/Unbias_a_random_generator</a>\r\nmain->print('I biased unbiased') and [3..6].each(i,testUnbiasing(i));\r\n"]
,['demos/vampire.mnh',"private getFangs(i:int)->begin\r\n  local digits:=length(toString(i)) div 2;\r\n  local toTest1:=10^(digits-1);\r\n  local toTest2:=round(sqrt(i));\r\n  local toTest3:=10^digits-1;\r\n  local toTest:=abs(toTest2-toTest1)<abs(toTest3-toTest2)\r\n                 ? [toTest1..toTest2]\r\n                 : [toTest3..toTest2];\r\n  local iDigits:=toString(i).chars.sort;\r\n  toTest\r\n  .get(i mod toTest=0)\r\n  .pEach(d,(toString(d)&toString(i div d)).chars.sort==iDigits\r\n           ? [i div d,d]\r\n           : void);\r\nend;\r\n\r\nprivate printVampire(i:int)->begin\r\n  local fangs:=getFangs(i);\r\n  fangs==[]\r\n  ? false\r\n  : begin\r\n      print(i,\" is a vampire. It's fangs are: \",join(fangs,\" or \"));\r\n      true;\r\n    end;\r\nend;\r\n\r\nprivate verbosePrintVampire(i)->printVampire(i) OR print(i,' is not a vampire.');\r\n\r\nprivate step(99  ):=1000;\r\nprivate step(9999):=100000;\r\nprivate step(k)->k+1;\r\n\r\nprivate printFirstKVampires(k:int)->begin\r\n  local found:=0;\r\n  local toTest:=9;\r\n  while(found<k,printVampire(toTest:=step(toTest)) ? found+=1 : void);\r\nend;\r\n\r\n//*Solves the \"Vampire-Number\" task from <a href=\"http://rosettacode.org/wiki/Vampire_number\">RosettaCode</a>\r\nmain('rosetta')->begin\r\n  print('See http://rosettacode.org/wiki/Vampire_number');\r\n  main;\r\n  print('-----------------------------------------------');\r\n  verbosePrintVampire(16758243290880);\r\n  verbosePrintVampire(24959017348650);\r\n  verbosePrintVampire(14593825548650);\r\nend;\r\n\r\n//*As above but abridged for regression test\r\nmain->printFirstKVampires(25);\r\n"]
,['demos/variadic.mnh',"//*See <a href=\"http://rosettacode.org/wiki/Variadic_function\">http://rosettacode.org/wiki/Variadic_function</a>\r\nmain->print('Example parameters: \"A\",\"B\",\"C\"')|main(\"A\",\"B\",\"C\");\r\n//*Print all the script parameters - each in a new line\r\nmain(...)->$params.each(p,print(p));\r\n"]
,['demos/weasel.mnh',"private target:=\"METHINKS IT IS LIKE A WEASEL\";\r\nprivate fitness(s:string)-> abs(ord(target.chars)-\r\n                                ord(     s.chars)).agg(+);\r\nprivate CHARSET:=['A'..'Z',' '];\r\nprivate randomCharacter->CHARSET.get(intRandom(size(CHARSET)));\r\n\r\nprivate multiplyAndSelect(parent:string,offspringCount, mutateProb)->\r\n   [0..offspringCount].each(i,\r\n        begin\r\n          local individual:=i=0 ? parent : parent.chars.each(c,random<mutateProb ? randomCharacter : c).join;\r\n          [individual,fitness(individual)];\r\n        end,\r\n        aggregator({$x.get(1)<=$y.get(1) ? $x : $y})) //Selection: the fittest survives this aggregator ;-)\r\n        .head;\r\n\r\nprivate evolve(mutationFalloff,offspringCount,generationLimit)->begin\r\n  local parent:=[0..length(target)-1].each(i,randomCharacter,&);\r\n  local generationCount:=0;\r\n  local mutationRate:=1;\r\n  while(parent<>target AND generationCount<generationLimit,\r\n  begin\r\n    parent:=multiplyAndSelect(parent,offspringCount,mutationRate);\r\n    mutationRate:=max(0.05,mutationRate*mutationFalloff);\r\n    (generationCount+=1) mod 20 = 0\r\n    ? printf('%4d %s (%3d)',generationCount,parent,fitness(parent))\r\n    : void;\r\n  end);\r\n  printf('%4d %s',generationCount,parent);\r\nend;\r\n\r\n//*See <a href=\"http://rosettacode.org/wiki/Evolutionary_algorithm\">http://rosettacode.org/wiki/Evolutionary_algorithm</a>\r\nmain->evolve(0.96,20,10000);\r\n"]
,['demos/wordCount.mnh',"USE inputs;\r\n\r\nprivate cleanSplitString(s:stringList)->begin\r\n  local result:=join(s,' ')           //join lines -> processing one long string\r\n               .lower                 //convert to lowercase\r\n               .clean(['a'..'z'],' ') //retain only letters\r\n               .split(' ');           //split at spaces\r\n  result[result<>'']; //return those elements from the result list which are not empty strings\r\nend;\r\n\r\nprivate processLinesInChunks(lines:stringList,chunkSize)->\r\n  group(lines,[0..size(lines)-1] div chunkSize)\r\n  .pEach(chunk,cleanSplitString(chunk))\r\n  .flatten\r\n  .elementFrequency;\r\n        \r\nprivate analyze(lines:stringList)->begin\r\n  local wordCount:=processLinesInChunks(lines,100).sort({$x[0]>=$y[0]});\r\n  print('Words total:    ',local total:=wordCount.getInner(0).agg(+));\r\n  print('Distinct words: ',size(wordCount));\r\n  local top50:=head(wordCount,50);\r\n  print('Most frequent:');\r\n  printf(\"%s\\t%s\\t%s\",\r\n    'word' |(top50.getInner(1)),\r\n    'count'|(top50.getInner(0)),\r\n    '%'    |round(top50.getInner(0)/total*100,2));\r\n\r\nend;\r\n\r\nprivate filesWords(pattern)->each(f,files(pattern),|,fileLines(f));\r\n\r\n//*Displays a short info on words in kjv.txt\r\nmain->analyze(fileLines(inputs.kjv));\r\n//*Displays a short info on words in the given file or files matching a search pattern\r\nmain(fileOrPattern:string)->analyze(filesWords(fileOrPattern));\r\n"]
,['demos/y.mnh',"Y(F:expression)->{F($n,F)};\r\nfakForY:={$n<=1 ? 1 : $n*$f($n-1,$f)};\r\nfibForY:={$n<=1 ? 1 :    $f($n-1,$f)+\r\n                         $f($n-2,$f)};\r\n//*Solves the <a href=\"http://rosettacode.org/wiki/Y_combinator\">Y combinator task</a> from rosettacode.org\r\nmain->[0..20].each(i,print(i,' ',Y(fakForY)(i),' ',Y(fibForY)(i)));\r\n"]
,['demos/zeckendorf.mnh',"private memoized fib(i> 0)->fib(i-1)+fib(i-2);\r\nprivate          fib(i<=0):=1;\r\nprivate inv(F:expression,n  )->inv(F,n,0);\r\nprivate inv(F:expression,n,i)->(F(i))>=n ? i : inv(F,n,i+1);\r\n\r\nprivate encode(F,n:int     )->replace('#'&encode(F,n,inv(F,n)),[\"#0\",\"#\"],[\"#\",\"\"]);\r\nprivate encode(F,n:int,i>=0)->(F(i))<=n ? 1 & encode(F,n-(F(i)),i-1)\r\n                                        : 0 & encode(F,n       ,i-1);\r\nprivate encode(F,n:int,i)->\"\";\r\nprivate encode(F,N:intList     )->N.pEach(n,encode(F,n));\r\n\r\nprivate FIB:={fib($i)};\r\nprivate POT:={2^$i};\r\n\r\nprivate memoized avgLen(bits)->[2^(bits-1)..2^bits-1].pEach(i,length(encode(FIB,i)),+)/(2^(bits-1));\r\nprivate examples:=[1,2,3,4,5,17,100,255];\r\n\r\n//*Displays examples for Zeckendorf-encoding\r\n//*and average lengths compared to binary representation\r\nmain->\r\nprintf('%8d %8d %12d',\r\n  'decimal'|examples,\r\n  'binary'|encode(POT,examples),\r\n  'Zeckendorf'|encode(FIB,examples))|\r\nprint(\"\\n    bits rel. overhead\") |\r\nprintf('%2d %5.2f     %9.4f',\r\n       [1..12],\r\n       [1..12].each(i,avgLen(i)),\r\n       [1..12].each(i,avgLen(i))/[1..12]);\r\n"]
,['demos/inputs/inputs.mnh',"private ensureFile(path,URL)->fileExists(path) ? path : begin\r\n  writeFile(path,httpGet(URL));\r\n  path;\r\nend;\r\n\r\nkjv ->ensureFile(splitFileName(myPath).directory&\"/kjv.txt\"     ,'http://www.ccel.org/ccel/bible/kjv.txt');\r\ndict->ensureFile(splitFileName(myPath).directory&\"/unixdict.txt\",'http://www.puzzlers.org/pub/wordlists/unixdict.txt');\r\n"]
].each(f,fileExists($0&f[0]) ? void : writeFile($0&f[0],f[1]))}
