{
[['packages/combinatorics.mnh',"private drop(L<>[],i:int)->L.get([0..size(L)-1].each(j,j<>i));\r\nprivate myUnique([])->[];\r\nprivate myUnique(L)->[head(L)]|L.get(L.each(E,not(E==head(L)))).myUnique;\r\n\r\n//*Returns all permutations of list <code>[0..i-1]</code>\r\npermutations(i:int)->permutations([],[0..i-1]);\r\n//*Returns all permutations of list <code>L</code>\r\npermutations(L:list)->myUnique(permutations([],L));\r\nprivate permutations(Head:list,[])->[Head];\r\nprivate permutations(Head:list,L)->[0..size(L)-1].each(i,permutations(Head|(L.get(i)),drop(L,i)),|);\r\n\r\n//*Returns <code>[[],[S]]</code>\r\nsubsets(S:scalar)->[[],[S]];\r\n//*Returns the set of all subsets of <code>L</code>\r\nsubsets(L:list)->myUnique(subsets([],L));\r\nprivate subsets(Head:list,[])->[Head];\r\nprivate subsets(Head:list,L)->subsets(Head,tail(L))|subsets(Head|head(L),tail(L));\r\n\r\nprivate testEx(e:expression)->printf(\"%-26s = %s\",unbrace(string(e)),string(e()));\r\n//*For reg-test\r\nmain->testEx({permutations(3)})|\r\n      testEx({permutations([0,1,2,2])})|\r\n      testEx({subsets('X')})|\r\n      testEx({subsets(['a'..'c'])})|\r\n      testEx({subsets(['a'..'c','a'])});\r\n"]
,['packages/lindenmayer.mnh',"USE turtleGfx;\r\n\r\nlindenmayer(config,depth)->lindenmayer@(config|depth);\r\nprivate lindenmayer(data,productionLHS,productionRHS,depth>0)->\r\n        lindenmayer(replace(upper(data),upper(productionLHS),lower(productionRHS)),\r\n                    productionLHS,\r\n                    productionRHS,\r\n                    depth-1);\r\nprivate lindenmayer(data,productionLHS,productionRHS,depth)->upper(data);\r\nlindenmayerTurtle(config,depth)->turtle@(config.get(1)|lindenmayer(config.get(0),depth));\r\n\r\nHILBERT       :=[['A'      ,['A','B'],['-BF+AFA+FB-','+AF-BFB-FA+']],[ 0, 90,'F' ]];\r\nKOCH_SNOWFLAKE:=[['F++F++F',['F'    ],['F-F++F-F'                 ]],[ 0, 60,'F' ]];\r\nSIERPINSKI    :=[['A'      ,['A','B'],['B-A-B'      ,'A+B+A'      ]],[ 0, 60,'AB']];\r\nSIERPINSKI2   :=[['F-G-G'  ,['F','G'],['F-G+F+G-F'  ,'GG'         ]],[ 0,120,'FG']];\r\nPLANT         :=[['X'      ,['X','F'],['F-[[X]+X]+F[+FX]-X','FF'  ]],[70, 25,'F' ]];\r\n\r\n//*For regTest\r\nmain->print(round(lindenmayerTurtle(HILBERT,3),2));\r\n"]
,['packages/primes.mnh',"private mutable cached_primes:=[2,3];\r\nprivate mutable max_cached:=3;\r\n\r\n//*Return prime numbers <= n\r\nsynchronized\r\nprimes(n:int)->begin\r\n  n>max_cached ? begin\r\n    local candidates:=[(max(cached_primes)+1) div 2..ceil(n/2)-1]*2+1; //only odd numbers as candidates\r\n    cached_primes.each(p,candidates:=candidates.get(candidates mod p!=0)); //filter candidates using cached_primes\r\n    local lastPrime:=head(candidates);\r\n    candidates:=tail(candidates);\r\n    while(lastPrime^2<n,begin\r\n      cached_primes|=lastPrime;\r\n      candidates:=candidates.get(candidates mod lastPrime!=0);\r\n      lastPrime :=head(candidates);\r\n      candidates:=tail(candidates);\r\n    end);\r\n    cached_primes|=lastPrime;\r\n    cached_primes|=candidates;\r\n    max_cached:=n;\r\n  end : void;\r\n  cached_primes.get(cached_primes<=n);\r\nend;\r\n\r\n//*Return prime numbers <= floor(n)\r\nprimes(n:real)->primes(floor(n));\r\n\r\nisPrime(n:int)->n in cached_primes ? true :\r\n                n <= max_cached    ? false :\r\n                trueCount(n mod primes(sqrt(n))=0)=0;\r\nisPrime(N:intList)->begin\r\n  local maxP:=sqrt(max(N));\r\n  maxP>max_cached ? primes(maxP) : void;\r\n  pEach(n,N,n in cached_primes ? true : trueCount((n mod cached_primes)=0)=0);\r\nend;\r\n\r\n//*Returns the first k primes\r\nfirstKPrimes(k:int)->k<size(cached_primes) ? head(cached_primes,k)\r\n                                           : (primes(max(k*11,round(max_cached*1.1)))).get(-1) | firstKPrimes(k);\r\n\r\n//*Factorize number <code>n</code> using prime numbers from function <code>primes</code>\r\nfactorize(n:int)-> n<=1 ? [1] :\r\nbegin\r\n  local factors:=[];\r\n  local k:=n;\r\n  local P:=primes(sqrt(k));\r\n  P.get(k mod P=0).each(p,\r\n    while(k mod p = 0, begin\r\n      k:=k div p;\r\n      factors|=p;\r\n    end));\r\n  factors|k;\r\nend;\r\n\r\n//*Return the dividers of integer <code>n</code>\r\ndividers(n:int)->begin\r\n  local C:=[2..floor(sqrt(n))];\r\n  C:=C.get(n mod C = 0);\r\n  unique(1|C|(n div C));\r\nend;\r\n//*Return the divider-sum of integer <code>n</code>\r\nmemoized dividerSum(n:int)->dividers(n).agg(+);\r\n\r\n\r\ndividerPairs(n:int)->[2..floor(sqrt(n))].get(n mod [2..floor(sqrt(n))]=0).each(d,[d,n div d]);\r\n\r\nprivate testEx(e:expression)->printf(\"%-20s = %s\",unbrace(string(e)),string(e()));\r\n//*Call functions for reg-testing\r\nmain->testEx({primes(100)}) |\r\n      testEx({factorize(121350)}) |\r\n      testEx({dividers(121350)}) |\r\n      testEx({dividerSum(121350)}) |\r\n      testEx({dividerPairs(121350)});\r\n"]
,['packages/statistics.mnh',"//*Returns the mean of all values in <code>X</code>\r\nmean    (X:numericList)->X.agg(+)/size(X);\r\n//*Returns the (statistical) variance of all values in <code>X</code>\r\nvariance(X:numericList)->mean(X^2)-mean(X)^2;\r\n\r\nmedian(X:numericList)->sort(X).get(size(X) div 2);\r\n\r\ndecils(L)->sort(L).get(round([0..10]/10*(size(L)-1)));\r\n\r\nprivate testEx(e:expression)->printf(\"%-29s = %s\",unbrace(string(e)),string(e()));\r\nmain->testEx({mean([1,2,3.2,-1.8])}) |\r\n      testEx({variance([1,2,3.2,-1.8])})|\r\n      testEx({median(random(100))}) |\r\n      testEx({decils(round(random(1000),3))});\r\n"]
,['packages/turtleGfx.mnh',"private degToRad:=arctan(1)/45;\r\nprivate removeRedundantSequences(s,s)->s;\r\nprivate removeRedundantSequences(s,prev)->removeRedundantSequences(replace(s,['+-','-+','[]','[+]','[-]'],''),s);\r\n\r\nprivate cleanString(drawChars:string, input:string, allowShortening:boolean)->begin\r\n  local ignorables:=('~'|input.chars).minus(['+','-','F','[',']']);\r\n  local clean:=replace(replace(input,\r\n                               copy(drawChars,[0..length(drawChars)-1],1),\r\n                               'F'),\r\n                       ignorables,\r\n                       '');\r\n\r\n  replace(\r\n    removeRedundantSequences(clean,''),\r\n    allowShortening ? ['F','00','11','22','33','44','55','66','77','88'] : 'F',\r\n    allowShortening ? ['0','1' ,'2' ,'3' ,'4' ,'5' ,'6' ,'7' ,'8' ,'9'] : '0');\r\nend;\r\n\r\n\r\nturtle(startAngle:numeric,rotAngleInDegrees:numeric,drawChars:string,s:string)->turtle(startAngle,rotAngleInDegrees,drawChars,s,true);\r\nturtle(startAngle:numeric,rotAngleInDegrees:numeric,drawChars:string,s:string,allowShortening:boolean)->begin\r\n  local cleanInput:=cleanString(drawChars,s,allowShortening);\r\n  //init State variables\r\n  local turtlePos:=[0,0];\r\n  local turtleDir:=startAngle*degToRad;\r\n  local posStack:=[];\r\n  local dirStack:=[];\r\n  local rotAngle:=rotAngleInDegrees*degToRad;\r\n  local OP:=toMap([['0', {begin local oldPos:=turtlePos; turtlePos+=    [cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['+', {begin turtleDir-=rotAngle; void; end}],\r\n                   ['-', {begin turtleDir+=rotAngle; void; end}],\r\n                   ['[', {begin\r\n                           posStack|=[turtlePos];\r\n                           dirStack|=turtleDir;\r\n                           void;\r\n                         end}],\r\n                   [']', {begin\r\n                           turtlePos:=trailing(posStack);\r\n                           posStack := leading(posStack);\r\n                           turtleDir:=trailing(dirStack);\r\n                           dirStack := leading(dirStack);\r\n                           [[Nan,Nan]] | turtlePos;\r\n                         end}],\r\n                   ['1', {begin local oldPos:=turtlePos; turtlePos+=  2*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['2', {begin local oldPos:=turtlePos; turtlePos+=  4*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['3', {begin local oldPos:=turtlePos; turtlePos+=  8*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['4', {begin local oldPos:=turtlePos; turtlePos+= 16*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['5', {begin local oldPos:=turtlePos; turtlePos+= 32*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['6', {begin local oldPos:=turtlePos; turtlePos+= 64*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['7', {begin local oldPos:=turtlePos; turtlePos+=128*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['8', {begin local oldPos:=turtlePos; turtlePos+=256*[cos(turtleDir),sin(turtleDir)]; oldPos; end}],\r\n                   ['9', {begin local oldPos:=turtlePos; turtlePos+=512*[cos(turtleDir),sin(turtleDir)]; oldPos; end}]]);\r\n  cleanInput.chars.each(c,OP[c]()) | [turtlePos];\r\nend;\r\n\r\n//*For reg-test\r\nmain->plot.setAxisStyle([0,0]) and plot(turtle(0,59,'F',[1..100].each(i,repeat('F',i),'+',&))) and renderToFile(replace(myPath,'.mnh','.png'),768,768,4);\r\n\r\n"]
].each(f,fileExists($0&f[0]) ? void : writeFile($0&f[0],f[1]))}
