private voidify(...)->void;
private degToRad:=arctan(1)/45;
mutable turtlePos:=[0,0];
mutable turtleDir:=0;
mutable posStack:=[];
mutable dirStack:=[];
mutable rotAngle:=90*degToRad;

synchronized private doTurtle('+')->voidify(turtleDir:=turtleDir-rotAngle);
synchronized private doTurtle('-')->voidify(turtleDir:=turtleDir+rotAngle);
synchronized private doTurtle('F')->turtlePos|voidify(turtlePos:=turtlePos+[cos(turtleDir),sin(turtleDir)]);
synchronized private doTurtle('[')->voidify(posStack:=posStack|[turtlePos],
                                            dirStack:=dirStack|turtleDir);
synchronized private doTurtle(']')->[[Nan,Nan]]|voidify(turtlePos:=trailing(posStack),
                                                        posStack := leading(posStack),
                                                        turtleDir:=trailing(dirStack),
                                                        dirStack := leading(dirStack));
private doTurtle(...)->void;
private turtle(s:string)->each(c,copy(s,[0..length(s)-1],1),doTurtle(c))|[turtlePos];

private ignorables(prodRules)->each(c,unique(each(s,flatten(prodRules),|,copy(s,[0..length(s)-1],1))),c in ['+','-','F','[',']'] ? void : c);
private cleanString(s:string,drawChars:string,ignorables:stringList)->
  cleanString_(
    replace(
      replace(upper(s),
              copy(drawChars,[0..length(drawChars)-1],1),
              'F'),
      ignorables,
      ''));
private cleanString_(s)->cleanString_(s,"");
private cleanString_(s,s)->s;
private cleanString_(s,prev)->cleanString_(replace(s,['+-','-+','[]','[+]','[-]'],''),s);

private nvl([],fallback)->fallback;
private nvl(x ,fallback)->x;
parseLindenmayer_(L:list,depth)->
  parseLindenmayer_(nvl(softCast(L%"initialAngle"),0),
                    nvl(softCast(L%"deltaAngle"),90),
                    nvl(softCast(L%"axiom"),"F"),
                    nvl(softCast(L%"drawBy"),"F"),
                    L%(L%%0<>"initialAngle" and
                       L%%0<>"deltaAngle" and
                       L%%0<>"axiom" and
                       L%%0<>"drawBy")%%0,
                    L%(L%%0<>"initialAngle" and
                       L%%0<>"deltaAngle" and
                       L%%0<>"axiom" and
                       L%%0<>"drawBy")%%1,depth);
private parseLindenmayer_(initialAngle,deltaAngle,axiom,drawBy,productionLHS,productionRHS,depth)->
  voidify(turtlePos:=[0,0],
          turtleDir:=initialAngle*degToRad,
          rotAngle:=deltaAngle*degToRad,
          posStack:=[],
          dirStack:=[])|turtle(cleanString(lindenmayer(axiom,productionLHS,productionRHS,depth),drawBy,ignorables(productionLHS|productionRHS)));
private lindenmayer(data:string,productionLHS:stringList,productionRHS:stringList,depth>0)->
  lindenmayer(replace(upper(data),upper(productionLHS),lower(productionRHS)),
              productionLHS,
              productionRHS,
              depth-1);
private lindenmayer(data:string,productionLHS:stringList,productionRHS:stringList,depth)->upper(data);


HILBERT:='axiom = A;'+
         'A -> -BF+AFA+FB-;'+
         'B -> +AF-BFB-FA+';
KOCH_SNOWFLAKE:='deltaAngle = 60;'+
                'axiom      = F++F++F;'+
                'F -> F-F++F-F';
SIERPINSKI :='deltaAngle = 60;'+
             'axiom      = A;'+
             ' drawBy    = AB;'+
             'A -> B-A-B;'+
             'B -> A+B+A;';
SIERPINSKI2:='deltaAngle   = 120;'+
             'axiom        = F-G-G;'+
             'F -> F-G+F+G-F;'+
             'G -> GG;'+
             'drawBy = FG';
parseLindenmayer(s:string,depth:int)->parseLindenmayer_(each(el,split(replace(s,[' ',';;'],['',';']),';'),split(el,['=','->'])),depth);

plot(turtle(each(i,[1..20],&,repeat(repeat('F',i)&'+',2))));
