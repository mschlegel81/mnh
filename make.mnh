#!/usr/bin/mnh_light
USE mnhInfo,formattingUtils,make_config,distroLog,testExpectation;
tprint(...)->print@(formatTime('hh:nn.ss ',systime)|...);
//Configuration:=====================================================
private needBuild(B)->B['canBuild'] AND (!(B['targetDest'].fileExists) OR !([B['targetDest'].flavour,B['targetDest'].codeVersion]==[B['flavour'],ensureCodeHash]));

private delp->(isLinux ? 'delp' : DelpPath).exec(
       ['gui/lib/i386-win32',
        'gui/lib/x86_64-linux',
        'gui/lib/x86_64-win64',
        'core',
        'common',
        '3rd_party',
        'consoles/lib/i386-win32',
        'consoles/lib/x86_64-linux',
        'consoles/lib/x86_64-win64']);

private templateToInc(inFile,outFile<>inFile)->begin
  local pasId:=clean(inFile.extractFileName,['a'..'z','A'..'Z'],'_');
  local inLines:=fileLines(inFile);
  local outText:=
  'CONST '&pasId&': array[0..'&(inLines.size-1)&"] of string=(\n"&
  inLines.each(line,line.escapePascal).join(",\n")&');';
  outFile.fileContents==outText
  ? void
  : writeFile(outFile,outText);
end;

private ensureDefaultFilesSource->begin
  local code:=
  format('(%{escapePascal($0)}s,%{escapePascal($0.fileContents.compress.base64encode)}s)',
  sort(allFiles('demos\','*.mnh')|allFiles('packages\','*.mnh')));
  local header:='CONST DEFAULT_FILES:array[0..'&(code.size-1)&',0..1] of string=(';
  code:=header|code.each(f,f&(index=code.size-1 ? ');':','));

  local filename:='gui/res_defaultFiles.inc';
  fileExists(filename) AND fileLines(filename)==code
  ? void
  : writeFileLines(filename,code);
end;

private mutable currentCodeHash:=void;
private synchronized updateCurrentCodeHash->
currentCodeHash:=begin
  fileExists('../checkstyle.mnh')
  ? begin
      tprint('Checkstyle');
      runScript('../checkstyle.mnh',['fix'],3);
    end
  : void;
  tprint('Updating generated files');
  //convert here to ensure these files are considered in code hash calculation
  templateToInc('resources/examples.txt'                   ,'gui/res_examples.inc');
  templateToInc('resources/html_template.txt'              ,'gui/res_html_template.inc');
  templateToInc('resources/ensureAssoc.mnh'                ,'gui/res_ensureAssoc.inc');
  templateToInc('resources/removeAssoc.mnh'                ,'gui/res_removeAssoc.inc');
  ensureDefaultFilesSource;
  //update code hash
  tprint('Updating code hash based on ',hashFiles.size,' files');
  local result:=format('%8.8x',fileStats(hashFiles).getInner(3).agg(+)).copy(0,8);
  local expectedContents:=format("CODE_HASH='%s';",result);
  fileContents('core/code_hash.inc')==expectedContents
  ? void
  : begin
      writeFile('core/code_hash.inc',expectedContents);
      tprint('core/code_hash.inc updated with current hash ',result);
    end;
  result;
end;
private ensureCodeHash->currentCodeHash orElse updateCurrentCodeHash;

private ensureBuildNumber->begin
  local expectedContents:=format("BUILD_NUMBER=%s;",getBuildNumber(ensureCodeHash));
  fileContents('core/build_number.inc')==expectedContents
  ? void
  : begin
      writeFile('core/build_number.inc',expectedContents);
      tprint('core/build_number.inc updated with current build number ',getBuildNumber(ensureCodeHash));
    end;
end;

USE oeis_server;

private stopOeisServer->while(isIpcServerRunning(oeis_server.ipcId),sendIpcRequest(oeis_server.ipcId,['stop']));

private myMove(source,dest:String)->fileExists(source) ? begin
  local tries:=3;
  while(fileExists(dest) AND tries>0,
    deleteFile(dest) ? void : begin
    tries-=1;
    stopOeisServer;
    sleep(0.5);
  end);
  fileExists(dest) ? fail('Failed deleting '+dest) : void;
  moveFile(source,dest) ? void : fail('File move '+source+' -> '+dest+' failed!');
end : fail('File  '+source+' does not exist');

private BUILD_LOG:='build.log';
private buildExe(B:Map)->
  B.needBuild AND B['canBuild']
  ? begin
      ensureCodeHash;
      ensureBuildNumber;
      tprint('Building ',B['targetDest']);
      local compilerOutput:=head(exec@(B['compilerCall']));
      local sepLine:=repeat('-',compilerOutput.each(line,line.length,max) orElse 0);
      compilerOutput:=sepLine|
                      B['compilerCall'].flatten.join(' ')|
                      sepLine|
                      compilerOutput;
      BUILD_LOG.appendFileLines(compilerOutput);
      myMove(B['compilate'],B['targetDest']);
      B.needBuild
      ? fail('Build failed - see '&BUILD_LOG&' for details')
      : tprint('Build successful');
    end
  : void;

private testExe(B:Map,...)->begin
  !(B['canBuild']) OR !(B['doTest'])
  ? return void : void;
  B['distro'] AND needBuild(B) ? B.buildExe : void;
  allTestsPassed(B['flavour'],ensureCodeHash) OR needBuild(B) ? return true : void;
  tprint('Testing ',B['targetDest']) orElse
  B['targetDest'].execPipeless(['regTest/regTest.mnh']|...)=0
  ? tprint('Test passed') orElse true
  : tprint('Test failed') orElse false;
end;

private showStatus->
  print orElse
  tprint('Current code hash: ',ensureCodeHash,"\n") orElse
  BUILDS.each(B,begin
    local exe  :=B['targetDest'].systemSpecificFilename;
    local exist:=fileExists(exe);
    local canBuild:=B['canBuild'];
    local version :=exist ? canBuild ? exe.codeVersion : '?' : '';
    local cmpTime :=exist ? canBuild ? exe.compileTime : '?' : '';
    [B['flavour'],
     exe,
     version==ensureCodeHash ? 'o.k.' : version,
     cmpTime,
     B['doTest'] ? timeForFullTest(B['flavour'],version).roundToRelevantDigits(4) : '(n/a)'
     ];
  end).formatTable(['Flavour','Binary','CodeVersion','Compile time','Time for test']).join("\n").print
  orElse print;

private verboseDelete(file)->
  fileExists(file)
  ? deleteFile(file)
    ? void
    : fail('Could not delete ',file)
  : void;

private cleanup->begin
  allFolders('.')
  .each(f,extractFileName(f) in ["nppBackup","backup"] ? f : void)
  .each(f,begin
           tprint('Deleting ',f);
           deleteDir(f);
          end);
  (files(allFolders('.')&'/*.png')|
   files(allFolders('..')&'/*.bak')|
   files('gui/res_*.inc')|
   files('regTest/testFailures.log')|
   allFiles('versions','*.exe')|
   files(BUILDS.getInner(5))|
   files('build.log'))
  .unique
  .map(::verboseDelete);
  delp;
  currentCodeHash:=void;
end;

private isSameFileName(filename1:String,filename2:String)->begin
  local case:=isLinux ? {$x} : {$x.upper};
  (filename1.expandedFileName.case)==
  (filename2.expandedFileName.case);
end;

private acceptedMainParameters->inspect['declares','main','subrules'].getInner('pattern').clean(['a'..'z','A'..'Z'],' ').trim.each(p,p='' ? void : p);
main->main('build');
//*Build all targets
main('build')->BUILDS.reverseList.each(B,B.buildExe);
//*Test all targets - non-debug versions will be built if necessary
main('test')->BUILDS.reverseList.each(B,B.testExe,and) ? void : fail('There are failed tests');
//*Test all targets even if the test already has been passed - non-debug versions will be built if necessary
main('retest')->BUILDS.reverseList.each(B,B.testExe('retest'),and) ? void : fail('There are failed tests');
//*Test all targets even if the test already has been passed - non-debug versions will be built if necessary
main('noLogTest')->BUILDS.reverseList.each(B,B.testExe('noLog'),and) ? void : fail('There are failed tests');
//*Show the current built status
main('status')->showStatus;
//*Show the current built status
main('prepare')->ensureCodeHash;
//*Clean the output files
main('clean')->tprint('Cleaning') orElse cleanup;
//*Deep cleaning, including deleting all executables
main('CLEAN')->begin
  tprint('Deep cleaning');
  stopOeisServer;
  cleanup;
  allFiles('target').map(::verboseDelete);
  files('3rd_party/*').minus(hashFiles).map(::verboseDelete);
end;
//*Beep - just for notification purposes
main('beep')->beep;

main('distro')->isLinux ? fail('Must be executed in windows environment') : begin

  BUILDS.each(B,B['canBuild'] AND B['distro'] ? B.testExe : void,AND)
  ? void
  : fail('Cannot make distro because there are failed tests');

  packSets(getBuildNumber(ensureCodeHash)).pEach(zipTask,call7z@zipTask);
  writeAllDataStores;
  {fileExists($0)
   ? runScript($0,[],3)
   : void}('distro_hook.mnh');
end;

//*Build one specific target
main(target:String)->begin
  local testAfterBuild:=false;
  local tgt:=target;
  target.copy(target.length-1,1)=='!'
  ? begin
      tgt:=target.copy(0,target.length-1);
      testAfterBuild:=true;
    end
  : void;
  local buildAndTest:=
    testAfterBuild ? {buildExe($B) orElse testExe($B) orElse true}
                   : {buildExe($B) orElse                    true};

  BUILDS.each(B,isSameFileName(B['targetDest'],tgt) OR tgt=B['flavour'] ? buildAndTest(B) OR fail orElse true : false,OR) OR
  BUILDS.each(B,matches       (B['targetDest'],tgt)                     ? buildAndTest(B) OR fail orElse true : false,or)
  ? void
  : fail("Don't know what to do with: "+target+". Accepted parameters are\n"+(acceptedMainParameters | '<target name or pattern>').join("\n"));
end;

//*Several steps in succession
main(...)->... .each(step,
  printf(SKEWED_FRAME_FMT,step),
  main(step));
