//Basics package
//--------------
//This package contains general purpose/convenience methods

//Aggregations:--------------------------------------------
//*The sum of the empty list is <code>0</code>
sum([]):=0;
//*Returns the sum of all elements in <code>L</code>
sum(L:numericList)->each(n,L,+);

//*The running sum of the empty list is <code>[]</code>
runningSum([])->[];
//*Returns the running sum of numeric list L (nested numeric lists are supported)
runningSum(L)->(size(L)<10 ? each(i,[1..size(L)],each(s,head(L,i),+)) : runningSum_merge(runningSum(head(L,size(L) div 2)),runningSum(tail(L,size(L) div 2))));
private safePlus(summand:list,list<>[])->each(l,list,l+summand);
private safePlus(summand     ,list<>[])->summand+list;
private runningSum_merge(L1,L2)->L1|safePlus(trailing(L1),L2);

//*The product of the empty list is <code>1</code>
prod([]):=1;
//*Returns the product of all elements in <code>L</code>
prod(L)->each(n,L,*);

//*The conjuction of the empty list is <code>true</code>
And([]):=true;
//*Returns the conjuction of of all elements in <code>L</code>
And(L:booleanList)->trueCount(L)=size(L);

//*The disjuction of the empty list is <code>true</code>
Or([]):=false;
//*Returns the disjuction of of all elements in <code>L</code>
Or(L:booleanList)->trueCount(L)>0;

//*Gives the empty string
join([])->"";
//*Returns a string concatenation of all elements in <code>L</code>
join(L<>[])->each(n,L,&,string(n));
//*Gives the empty string
join([],joiner:string)->"";
//*Returns a concatenation of flat list <code>L</code> using <code>joiner</code> as joiner.
join(L<>[],joiner:string)->each(n,L,aggregator({$x&joiner&$y}),string(n));
//*Gives the empty string
join([],joiner1:string,joiner2:string)->"";
//*Returns a concatenation of nested list <code>L</code> using <code>joiner1</code>
//*as joiner on the higher level and <code>joiner2</code> as joiner on the deeper level.
join(L<>[],joiner1:string,joiner2:string)->each(inner,L    ,aggregator({$x&joiner1&$y}),
                                           each(n    ,inner,aggregator({$x&joiner2&$y}),string(n)));
//--------------------------------------------:Aggregations
//Pretty printing
//*Pretty-prints a nested list
tabPrint(L)->print(join(L,"\n","\t"));
//---------------------------------------------------------
//Set operations:------------------------------------------
//*Set union of <code>A</code> and <code>B</code>
union    (A:list,B:list)->unique(A|B);
//*Set intersection of <code>A</code> and <code>B</code>
intersect(A:list,B:list)->A%    each(a,A,a in B);
//*Set difference; returns <code>A</code> without <code>B</code>
minus    (A:list,B:list)->A%not(each(a,A,a in B));
//------------------------------------------:Set operations
//List operations:-----------------------------------------
//*Returns indexes in list <code>A</code>
indexes(A:list)->[0..size(A)-1];
//*Returns <code>A</code> with reversed order of elements
reverse(A:list)->A%[size(A)-1..0];
//-----------------------------------------:List operations

//*Ludolf's Number (commonly known as pi)
pi:=4*arctan(1);

//*Factorial
memoized
fak(n<1)->1.0;
fak(n:int)->n*fak(n-1);
fak(N:list)->each(n,N,fak(n));

private testEx(e:expression)->printf("%X31% = %X%",unbrace(string(e)),string(e()));
//*For reg-testing
main->testEx({sum([1,2,3.2,-1.8])}) |
      testEx({runningSum([1,2,3.2,-1.8])}) |
      testEx({runningSum([[0,-100],1..10..1,[-100,0]])}) |
      testEx({prod([1,2,3.2,-1.8])}) |
      testEx({And([true,false,true])}) |
      testEx({Or([true,false,true])}) |
      testEx({join([1,2,3])}) |
      testEx({join([1,2,3],";")}) |
      testEx({join([[1,2,3],[4,5,6]],";"," ")}) |
      testEx({union([1,2,3],[2,3,4])})|
      testEx({intersect([1,2,3],[2,3,4])})|
      testEx({minus([1,2,3],[2,3,4])})|
      testEx({indexes([1,2,3]|[2,3,4])})|
      testEx({reverse([1,2,3,5])})|
      testEx({fak(10)})|
      printf("%X31% = %0.00000000%","pi",pi) |
      tabPrint([[1,2,3],[4,5,6]]);
