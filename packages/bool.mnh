private param(count)->each(i,[0..2^count-1],(2^[0..count-1] and i)>0);
//*Returns a list of lists of booleans representing the konjunctive normal form
trueParams(f:expression)->trueParams(f,param(arity(f)));
private trueParams(f,Params)->pEach(p,Params,f@p ? p : void);

private //*All 16 binary operators with format string
BIN:=[[trueParams({$x or $y or true}),    "true"],
      [trueParams({$x and $y and false}), "false"],
      [trueParams({$x or $x and $y}),     "%X%"],
      [trueParams({$x ? $y : $y}),        "%X0%%X%"],
      [trueParams({not($x or $x and $y)}),"not(%X%)"],
      [trueParams({not($x ? $y : $y)}),   "not(%X0%%X%)"],
      [trueParams({$x  or $y}),           "%X% or %X%"],
      [trueParams({$x and $y}),           "%X% and %X%"],
      [trueParams({not($x  or $y)}),      "not(%X% or %X%)"],
      [trueParams({not($x and $y)}),      "not(%X% and %X%)"],
      [trueParams({$x xor $y}),           "%X% xor %X%"],
      [trueParams({$x  =  $y}),           "%X%=%X%"],
      [trueParams({$x  >  $y}),           "%X%>%X%"],
      [trueParams({$x  <  $y}),           "%X%<%X%"],
      [trueParams({$x >=  $y}),           "%X%>=%X%"],
      [trueParams({$x <=  $y}),           "%X%<=%X%"]];
private //*All 4 unary operators with format string
UN:=[[trueParams({$x}),            "%X%"],
     [trueParams({not($x)}),       "not(%X%)"],
     [trueParams({$x or not($x)}), "true"],
     [trueParams({$x and not($x)}),"false"]];

//*Returns the konjunctive normal form as a string
normalForm(f:expression)->each(par,trueParams(f)   ,aggregator({$x&" or "&$y}),
                          each(i  ,[0..size(par)-1],aggregator({$x&" and "&$y}),
                               format(par%i ? "%X%" : "not(%X%)",parameterNames(f)%i)));
//*Returns a compact representation of boolean function f as string
compactForm(f:expression)->compactForm(trueParams(f),arity(f),head(parameterNames(f),arity(f)));
private compactForm(TL:list,arity=1,IDs)->each(un ,UN ,&,un %0==TL ? format(un %1,IDs%0      ) : void);
private compactForm(TL:list,arity=2,IDs)->each(bin,BIN,&,bin%0==TL ? format(bin%1,IDs%0,IDs%1) : void);
private compactForm(TL:list,arity>2,IDs)->each(i,[0..arity-1],aggregator({length($x)>length($y) ? $y : $x}),
                                                      binaryCompact(TL%   (TL%%i)%%([0..arity-1]<>i),
                                                                    TL%not(TL%%i)%%([0..arity-1]<>i),
                                                                    arity-1,
                                                                    IDs%i,
                                                                    IDs%([0..arity-1]<>i)));
private binaryCompact(TrueTL,FalseTL,remArity,thisID,remIDs)->
  TrueTL==FalseTL      ?                         compactForm(TrueTL ,remArity,remIDs) :
  flatten(FalseTL)==[] ?        thisID& " and ("&compactForm(TrueTL ,remArity,remIDs)&")" :
  flatten(TrueTL) ==[] ? "not("&thisID&") and ("&compactForm(FalseTL,remArity,remIDs)&")" :
                                thisID&"?"&      compactForm(TrueTL ,remArity,remIDs)
                                      &":"&      compactForm(FalseTL,remArity,remIDs);
//*Converts an boolean expression string to an expression
myFormToExpression(s:string)->expression(replace(s,ID_LIST,"$"&ID_LIST));

//*For reg-test
main(x:string)->print('Input       : ',x) |
                print('Normal Form : ',normalForm (expression(x))) |
                print('Compact Form: ',compactForm(expression(x)));
//*For reg-test
main->main('trueCount($A|$B|$C)=1');
