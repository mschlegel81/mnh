private drop(L<>[],i:int)->L.get([0..size(L)-1].each(j,j<>i));
private myUnique([])->[];
private myUnique(L)->[head(L)]|L.get(L.each(E,not(E==head(L)))).myUnique;

//*Returns all permutations of list <code>[0..i-1]</code>
permutations(i:int)->permutations([],[0..i-1]);
//*Returns all permutations of list <code>L</code>
permutations(L:list)->myUnique(permutations([],L));
private permutations(Head:list,[])->[Head];
private permutations(Head:list,L)->[0..size(L)-1].each(i,permutations(Head|(L.get(i)),drop(L,i)),|);

//*Returns <code>[[],[S]]</code>
subsets(S:scalar)->[[],[S]];
//*Returns the set of all subsets of <code>L</code>
subsets(L:list)->myUnique(subsets([],L));
private subsets(Head:list,[])->[Head];
private subsets(Head:list,L)->subsets(Head,tail(L))|subsets(Head|head(L),tail(L));

private testEx(e:expression)->printf("%-26s = %s",unbrace(string(e)),string(e()));
//*For reg-test
main->testEx({permutations(3)})|
      testEx({permutations([0,1,2,2])})|
      testEx({subsets('X')})|
      testEx({subsets(['a'..'c'])})|
      testEx({subsets(['a'..'c','a'])});
