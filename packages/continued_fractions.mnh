//*translation of a continued fraction to a real number:
CF2real([])->0;
CF2real(L)->head(L)+1/CF2real(tail(L));

//*translation of a continued fraction to a series of real numbers
CF2real_chain([])->[];
CF2real_chain(L)->head(L)|(head(L)+1/CF2real_chain(tail(L)));
//*Error estimate for continued fraction representation:
CFErr(x)->abs(x-CF2real_chain(ratCF(x)));

//*Translation of a continued fraction to a rational number:
CF2rat(L)->CF2rat(L,1,0,0,1);
private CF2rat(L<>[],p1,p2,q1,q2)->CF2rat(tail(L),head(L)*p1+p2,p1,p2,head(L)*q1+q2,q1,q2);
//proceed only if no integer overflow occurred:
private CF2rat(L<>[],p0>=0,p1,p2,q0>=0,q1,q2)->CF2rat(L,p0,p1,q0,q1);
private CF2rat(L<>[],p0   ,p1,p2,q0   ,q1,q2)->[p1,q1];
private CF2rat(L    ,p0   ,p1,p2,q0   ,q1,q2)->[p0,q0];
private CF2rat(L    ,p1,p2,q1,q2)->[p1,q1];

//*greatest common denominator:
pure gcd(x:intList,y:intList)->each(i,[0..min(size(x),size(y))-1],gcd(x%i,y%i));
     gcd(i>0,j>i)->gcd(i,j mod i);
     gcd(i>0,j>0)->gcd(i mod j,j);
     gcd(i,j)->max(i,j);

trimTrailingZeros(x)->x%[0..max([0..size(x)-1]%(x<>0))];
//build a continued fraction from a real:
realCF(x:real)->trimTrailingZeros(realCF(x,45));
realCF(x:real,depth)->realCF(x,floor(x),depth);
realCF(x,next,depth>0)->(x<1E10 or next>0) ? next|realCF(1/(x-next),depth-1) : [];
realCF(x,next,depth)->next;

ratString(x:real,depth:int)->ratString(CF2rat(realCF(x,depth)));
ratString(Rational:numericList)->Rational%0&"/"&Rational%1;
