private timedFolderContent(folderPath:string)->files(folderPath&'/*').each(file,[file,fileInfo(file)]).sort(0);
private changeToContent(L:list)->L.each(el,el[1]='deleted' ? void : el[[0,2]]).sort(0);
private
waitForFolderChange(folderPath:string,maxSleepTimeInSeconds:numeric,timeoutInSeconds:numeric,initialContent)->begin
  local scanInterval:=-1;
  local currentContent:=initialContent;
  local timeout:=time+timeoutInSeconds;
  while(currentContent==initialContent AND time<timeout,begin
    sleep(scanInterval:=min(scanInterval+1,maxSleepTimeInSeconds));
    currentContent:=timedFolderContent(folderPath);
  end);
  local names:=initialContent.getInner(0).union(currentContent.getInner(0)).sort;
  names.each(n,n in initialContent.getInner(0)
               ? n in currentContent.getInner(0)
                 ? initialContent[n]==currentContent[n]
                   ? [n,'',currentContent[n]]
                   : [n,'modified',currentContent[n]]
                 : [n,'deleted',initialContent[n]]
               : [n,'new',currentContent[n]]);
end;

changeSymbol:=[['',''],['modified','*'],['deleted','-'],['new','+']];


//*Waits for a folder change and returns the changes as a list:
//*[[filename,changetype,fileInfo],...]
//*where changetype is one of ['new','deleted','modified',''].
//*If the file is deleted, fileInfo is the info of the old file
waitForFolderChange(folderPath:string,maxSleepTimeInSeconds:numeric,timeoutInSeconds:numeric)->waitForFolderChange(folderPath,maxSleepTimeInSeconds,timeoutInSeconds,timedFolderContent(folderPath));
//*As above but without timeout
waitForFolderChange(folderPath:string,maxSleepTimeInSeconds:numeric)->waitForFolderChange(folderPath,maxSleepTimeInSeconds,2^31);

//*Returns a list as waitForFolderChange but without waiting
pseudoFolderChange(folderPath:string)->timedFolderContent(folderPath).each(e,[e[0],'',e[1]]);

//*Waits for a folder change and calls onChange when the folder is changed
watchFolder(folderPath:string,onChange:expression,maxSleepTimeInSeconds:numeric)->
  async({begin
    local contents:=timedFolderContent(folderPath);
    while(true,begin
      contents:=waitForFolderChange(folderPath,maxSleepTimeInSeconds,2^31,contents);
      onChange(contents);
      contents:=contents.changeToContent;
    end);
  end});

//*Returns a temp file name by the specified pattern.
//*pattern must contain exactly one "#" as placeholder
tempFile(pattern:string)->
  trueCount(pattern.chars='#')!=1
  ? fail('pattern must contain exactly one "#" as placeholder')
  : begin
      local tmpFileIndex:=0;
      while(fileExists(replace(pattern,'#',tmpFileIndex.toString)),tmpFileIndex+=1);
      replace(pattern,'#',tmpFileIndex.toString);
    end;

//*Returns the file time of the newest file in the subTree or -1 if there is no file
//*Optional parameters indicate patterns
maxFileTime(folder,...)->allFiles(folder,...==[] ? void : ...).fileInfo.getInner('time').agg(max) orElse -1;

//*Returns the file time of the given file
fileTime(file)->file.fileInfo['time'] orElse -1;
