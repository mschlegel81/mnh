//*Wraps sourceGenerator so that it generates (at max) for the given period of time
@SuppressUnusedWarning=all
timingOutGenerator(sourceGenerator:IteratableExpression,runForSeconds:Numeric)->
{begin
   local gen:=sourceGenerator;
   local timeout:=scriptTime+runForSeconds;
 save;
   scriptTime<timeout
   ? gen()
   : void;
 end}.toIteratableExpression;

//*Returns a list of all integer pairs [a,b] with initialSum<=(a+b)<=finalSum and a,b>=minElementValue, ordered by (a+b)
pairGenerator(initialSum,finalSum,minElementValue<=initialSum)->{begin
  local k:=initialSum;
  local i:=minElementValue-1;
save;
  (k-i<=minElementValue) ? begin k+=1; i:=minElementValue-1; end : void;
  k<=finalSum ? [i+=1,k-i] : void;
end}.toIteratableExpression;

//*Returns a list of all integer pairs [a,b] with initialSum<=(a+b) and a,b>=1, ordered by (a+b)
//*Warning: (potentially) infinite generator!
pairGenerator(initialSum)->pairGenerator(initialSum,2^63-1,1);

private subsetMapping(elements,basePerElement)->begin
  assert(elements.isList);
  assert(basePerElement.isList(elements.size));
  {begin
     local k:=[$0];
     [elements,basePerElement.each(b,k:=divMod(k[0],b)).getInner(1)].transpose.each(V,V[1]=0 ? void : [1..V[1]].each(i,V[0]),|);
   end};
end;

//*Returns an iterator over all distinct subsets of C
subSetIterator(C:Collection)->
begin
  local elements:=C.elementFrequency.sort;
  local basePerElement:=elements.getInner(1)+1;
  rangeGenerator(0,basePerElement.agg(*)-1).pMap(subsetMapping(elements.getInner(0),basePerElement));
end;

//*Returns the count of iteratable expression i
count(i:IteratableExpression)->begin
  local result:=0;
  while(!isVoid(i()),result+=1);
  result;
end;

//*The fallback for other literals is size
count(i)->i.size;

//*Returns an "out-of-order-map"
//*Behaves mostly like pMap but returns the elements in the order
//*  their calculation is finished, not in enqueue-order.
outOfOrderMap(parameters:Collection,f:Expression(1))->{begin
  local pending:=map(parameters,(parameter)->future(f,[parameter]));
save;
  pending.size=0
  ? return void
  : void;
  local firstDone:=void;
  local sleepTime:=1E-4;
  while(firstDone.isVoid,
    firstDone:=pending.each(task,task.peekFuture
                                 ? index
                                 : void,orElse)
    orElse sleep(sleepTime:=min(sleepTime*1.2,1))); //sleep not longer than one second
  local result:=pending[firstDone]();
  pending[firstDone]:=void;
  result;
end}.toIteratableExpression;

//*Wraps iterator in a new IteratableExpression which removes duplicates
deduplicate(iterator:IteratableExpression)->{begin
  local seen:=[].toSet;
save;
  local next:=iterator();
  while(!next.isVoid AND next in seen,next:=iterator());
  seen||=next;
  next;
end}.toIteratableExpression;

//*Wraps iterator in a new IteratableExpression which removes duplicates
//*Terminates when more than maxDuplicates duplicates have been encountered or the underlying iterator terminates
deduplicate(iterator:IteratableExpression,maxDuplicates>=1)->{begin
  local seen:=[].toSet;
  local duplicatesCounted:=0;
save;
  local next:=iterator();
  while(!next.isVoid AND next in seen AND (duplicatesCounted+=1)<=maxDuplicates,next:=iterator());
  seen||=next;
  duplicatesCounted>maxDuplicates
  ? void
  : next;
end}.toIteratableExpression;

//*Creates a co-iterator from multiple iterators/iteratables
//*Requires at least two arguments as input
coIterator(...)->
assert(size(...)>1,'coIterator requires at least two iteratables as input') orElse
{begin
  local iterators:=(...).each(i,i.isIteratableExpression
                                ? i
                                : i.isIteratable
                                  ? i.toIteratableExpression
                                  : fail('Non iteratable argument: ',i));
save;
  iterators.each(iterator,begin
    local fromIterator:=iterator();
    fromIterator.isVoid ? return void : fromIterator;
  end);
end}.toIteratableExpression;
