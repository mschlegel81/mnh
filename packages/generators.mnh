//*Wraps sourceGenerator so that it generates (at max) for the given period of time
@SuppressUnusedWarning=all
timingOutGenerator(sourceGenerator:IteratableExpression,runForSeconds:Numeric)->
{begin
   local gen:=sourceGenerator;
   local timeout:=time+runForSeconds;
 save;
   time<timeout
   ? gen()
   : void;
 end}.toIteratableExpression;

//*Returns a list of all integer pairs [a,b] with initialSum<=(a+b)<=finalSum and a,b>=minElementValue, ordered by (a+b)
pairGenerator(initialSum,finalSum,minElementValue<=initialSum)->{begin
  local k:=initialSum;
  local i:=minElementValue-1;
save;
  (k-i<=minElementValue) ? begin k+=1; i:=minElementValue-1; end : void;
  k<=finalSum ? [i+=1,k-i] : void;
end}.toIteratableExpression;

//*Returns a list of all integer pairs [a,b] with initialSum<=(a+b) and a,b>=1, ordered by (a+b)
//*Warning: (potentially) infinite generator!
pairGenerator(initialSum)->pairGenerator(initialSum,2^63-1,1);

//*Returns a chunk iterator
chunkIterator(iter:Iteratable,chunkSize>=1)->{begin
  local g:=iter.isIteratableExpression
           ? iter
           : iter.toIteratableExpression;
  local next:={begin
    local r:=g.head(chunkSize);
    r==[] ? void : r;
  end};
save;
  next();
end}.toIteratableExpression;

private subsetMapping(elements,basePerElement)->begin
  assert(elements.isList);
  assert(basePerElement.isList(elements.size));
  {begin
     local k:=[$0];
     [elements,basePerElement.each(b,k:=divMod(k[0],b)).getInner(1)].transpose.each(V,V[1]=0 ? void : [1..V[1]].each(i,V[0]),|);
   end};
end;

//*Returns an iterator over all distinct subsets of C
subSetIterator(C:Collection)->
begin
  local elements:=C.elementFrequency.sort;
  local basePerElement:=elements.getInner(1)+1;
  rangeGenerator(0,basePerElement.agg(*)-1).futureMap(subsetMapping(elements.getInner(0),basePerElement));
end;
