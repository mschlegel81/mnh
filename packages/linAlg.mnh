type Matrix(M:List)->M.pEach(row,row.isNumericList,AND) AND M.pEach(row,row.size).unique.size=1;
type SquareMatrix(M:List)->M.each(row,row.isNumericList(M.size),AND);

private subMatrix(M:List,skipRow,skipCol)->
  M.each(row,index=skipRow
             ? void
             : row.each(cell,index=skipCol ? void : cell));

private matrixDimensions(M:Matrix)->[M.size,M[0].size];

//*Matrix multiplication
mult(x:Matrix,y:Matrix)->begin
  local dimX:=matrixDimensions(x);
  local dimY:=matrixDimensions(y);
  (dimX[1]==dimY[0]) ? [0..dimX[0]-1].each(i,
                       [0..dimY[1]-1].each(k,(x.get(i)*y.getInner(k)).agg(+)))
                     : fail('Matrices must have compatible sizes for multiplication.');
end;
//*Matrix+vector multiplication
mult(x:Matrix,vec:NumericList)->x.mult(vec.each(c,[c]));
//*Vector+matrix multiplication
mult(vec:NumericList,y:Matrix)->[vec].mult(y);

determinant(M:SquareMatrix)->
  M.size=1 ? M[0,0] :
  M.size=2 ? M[0,0]*M[1,1]-M[1,0]*M[0,1] :
             [0..M.size-1].each(i,-1^(i)*M[i,0]*M.subMatrix(i,0).determinant,+);

crossProd(x:NumericList(3),y:NumericList(3))->[x[1]*y[2]-y[1]*x[2],
                                           x[2]*y[0]-y[2]*x[0],
                                           x[0]*y[1]-y[0]*x[1]];
euclidNorm(x:NumericList)->x.sqr.agg(+).sqrt;
randomVec3OnSphere->begin
  local x:=random(3)-0.5;
  x/euclidNorm(x);
end;

//@SuppressUnusedWarning
randomOrthoMatrix->begin
  local x:=randomVec3OnSphere;
  local y:=x.crossProd(randomVec3OnSphere);
        y:=y/euclidNorm(y);
  local z:=x.crossProd(y);
  [x,y,z];
end;

//@SuppressUnusedWarning
printMatrix(M)->M.each(row,row.join("\t")).join("\n").print;

//@SuppressUnusedWarning
invert(M:SquareMatrix)->begin
  //Gauss-Jordan Algorithm
  local aid:=M.each(row,begin local i:=index; row|(row.each(i,index=i ? 1 : 0)); end);
  [0..M.size-1].each(rowIndex,
    begin
      //Pivot
      aid:=aid.head(rowIndex) | //upper rows remain untouched
           aid.tail(rowIndex).sort(rowIndex).reverseList;
      //Divide by diagonal element
      aid[rowIndex]:=aid[rowIndex]/aid[rowIndex,rowIndex];
      //Subtract
      local x:=aid[rowIndex];
      [0..M.size-1].each(i,i=rowIndex ? void :
        aid[i]:=aid[i]-aid[i,rowIndex]*x);
      void;
    end);
  aid.each(row,row.tail(M.size));
end;

//@SuppressUnusedWarning
isUnitMatrix(M:SquareMatrix)->M.each(row,begin local rowIndex:=index; row.each(x,index=rowIndex ? x=1 : x=0,AND); end,AND);

//@SuppressUnusedWarning
rotZ(angle)->[[ cos(angle),sin(angle),0],
              [-sin(angle),cos(angle),0],
              [         0 ,        0 ,1]];
//@SuppressUnusedWarning
rotY(angle)->[[ cos(angle),0,sin(angle)],
              [         0 ,1,        0 ],
              [-sin(angle),0,cos(angle)]];
//@SuppressUnusedWarning
rotX(angle)->[[1,         0 ,        0 ],
              [0, cos(angle),sin(angle)],
              [0,-sin(angle),cos(angle)]];
