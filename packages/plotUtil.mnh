private PLOT_STYLE_KEYS:=['scale','color','ti','style'];
type PlotStyle(m:Map)->m.getInner(0).minus(PLOT_STYLE_KEYS).size=0;
private modifyStyle(S:PlotStyle,key=='style',value)->begin
  local R:=S;
  R[key]:=isVoid(S[key])
          ? value
          : S[key]&' '&value;
  R.toPlotStyle;
end;
private modifyStyle(S:PlotStyle,key in PLOT_STYLE_KEYS,value)->begin
  local R:=S;
  R[key]:=value;
  R.toPlotStyle;
end;

@SuppressUnusedWarning=all
toString(style:PlotStyle)->style.getInner(1).join(" ");

LINE     :=[['style','line'     ]].toMap.toPlotStyle;
STEPLEFT :=[['style','stepLeft' ]].toMap.toPlotStyle;
STEPRIGHT:=[['style','stepRight']].toMap.toPlotStyle;
BAR      :=[['style','bar'      ]].toMap.toPlotStyle;
BOX      :=[['style','box'      ]].toMap.toPlotStyle;
ELLIPSE  :=[['style','ellipse'  ]].toMap.toPlotStyle;
TUBE     :=[['style','tube'     ]].toMap.toPlotStyle;
POLYGON  :=[['style','polygon'  ]].toMap.toPlotStyle;
DOT      :=[['style','.']].toMap.toPlotStyle;
PLUS     :=[['style','+']].toMap.toPlotStyle;
CROSS    :=[['style','x']].toMap.toPlotStyle;
IMPULSE  :=[['style','i']].toMap.toPlotStyle;
withDot    (S:PlotStyle)->modifyStyle(S,'style','.');
withPlus   (S:PlotStyle)->modifyStyle(S,'style','+');
withCross  (S:PlotStyle)->modifyStyle(S,'style','x');
withImpulse(S:PlotStyle)->modifyStyle(S,'style','i');
filled     (S:PlotStyle)->modifyStyle(S,'style','f');
fillSolid  (S:PlotStyle)->modifyStyle(S,'style','s');
withScale(S:PlotStyle,scaleModifier>0.0)->modifyStyle(S,'scale',scaleModifier);
coloredBlack (S:PlotStyle)->modifyStyle(S,'color','black');
coloredRed   (S:PlotStyle)->modifyStyle(S,'color','red');
coloredBlue  (S:PlotStyle)->modifyStyle(S,'color','blue');
coloredGreen (S:PlotStyle)->modifyStyle(S,'color','green');
coloredPurple(S:PlotStyle)->modifyStyle(S,'color','purple');
coloredOrange(S:PlotStyle)->modifyStyle(S,'color','orange');
coloredRGB   (S:PlotStyle,r:Numeric,g:Numeric,b:Numeric)->modifyStyle(S,'color',format('RGB%s,%s,%s',r,g,b));
coloredHSV   (S:PlotStyle,h:Numeric,s:Numeric,v:Numeric)->modifyStyle(S,'color',format('HSV%s,%s,%s',h,s,v));
coloredHUE   (S:PlotStyle,hue:Numeric)->modifyStyle(S,'color',format('HUE%s',hue));
coloredGREY  (S:PlotStyle,brightness:Numeric)->modifyStyle(S,'color',format('GREY%s',brightness));


setPlotAutoscaleFactor(factor) ->
  setOptions('autoscaleFactor',factor);
setPlotAutoscale(axis in ['x','y'],enableAutoscale:Boolean) ->
  setOptions('autoscale'&upper(axis),enableAutoscale);
setPlotAxisStyle(axis in ['x','y'],tics:Boolean,majorGrid:Boolean,minorGrid<=majorGrid) ->
  setOptions('axisStyle'&upper(axis),(tics ? 1 : 0) or (majorGrid ? 2 : 0 ) or (minorGrid ? 4: 0));
setPlotLogscale(axis in ['x','y'],useLoscale:Boolean) ->
  setOptions('logscale'&upper(axis),useLoscale);
setPlotPreserveAspect(preserve:Boolean) ->
  setOptions('preserveAspect',preserve);
setPlotFontsize(relativeSize>=0.1) ->
  setOptions('fontsize',relativeSize);
setPlotRangeManually(x0:Numeric,x1>x0,y0:Numeric,y1>y0) ->
  setOptions([['autoscaleX',false],
              ['autoscaleY',false],
              ['x0'        ,x0],
              ['x1'        ,x1],
              ['y0'        ,y0],
              ['y1'        ,y1]]);
setPlotRangeManually(centerX:Numeric,centerY:Numeric,range:Numeric) ->
  setOptions([['autoscaleX',false],
              ['autoscaleY',false],
              ['preserveAspect',true],
              ['x0'        ,centerX-range],
              ['x1'        ,centerX+range],
              ['y0'        ,centerY-range],
              ['y1'        ,centerY+range]]);

private prepareGeometry(F:Expression(2),x0,x1>x0,y0,y1>y0,triangleCount>=2)->begin
  local stretch:=0.5*sqrt(3);
  local kx:=sqrt((x1-x0)/(y1-y0)*triangleCount/2*stretch).round.max(1);
  local ky:=sqrt((y1-y0)/(x1-x0)*triangleCount/2/stretch).round.max(1);
  local hx:=(x1-x0)/(kx-0.5);
  local hy:=(y1-y0)/(ky-1);
  local N:=[0..kx-1].each(ix,
           [0..ky-1].each(iy,[x0+(ix+(iy and 1)*0.5)*hx,
                              y0+ iy                *hy]),|);
  local T:=cross([0..kx-2],[0..ky-2])
           .each(i,(i[1] and 1)=0 ? [i      ,i+[0,1],i+[1,0]] :
                                    [i      ,i+[0,1],i+[1,1]],
                   (i[1] and 1)=0 ? [i+[1,0],i+[1,1],i+[0,1]] :
                                    [i      ,i+[1,0],i+[1,1]])|
   [1..ky-2].each(iy,(iy and 1)=1 ? [[0   ,iy-1],[0   ,iy],[0   ,iy+1]] :
                                    [[kx-1,iy-1],[kx-1,iy],[kx-1,iy+1]]);
  //Fill out gaps in the corners
  T:=T.map({$tri.map({$i[0]*ky+$i[1]})});
  N|=[[x1,y0]];
  T|=[[size(N)-1,ky*(kx-1),ky*(kx-1)+1]];
  (ky and 1)=1
  ? begin
      N|=[[x1,y1]];
      T|=[[size(N)-1,kx*ky-1,kx*ky-2]];
    end
  : begin
      N|=[[x0,y1]];
      T|=[[size(N)-1,ky-1,ky-2]];
    end;

  local sample:=F((x0+x1)/2,(y0+y1)/2);
  [sample.isNumeric        ? N.pMap({$x|F@$x}) :
   sample.isNumericList(3) ? N.pMap({   F@$x}) :
   fail("Invalid function ",F,"\nShould return Numeric or NumericList(3) but returns ",sample.typeOf),
   T];
end;

//*Returns a list of edges in the polyon (in node index space)
//*The returned edges are sorted
private edges(poly:IntList)->transpose([[0..poly.size-1],[1..poly.size-1,0]]).map({poly.getAll($i).sort});

private cutLine(F:Expression(2),x:NumericList(2),dx:NumericList(2),level:Numeric,
                t_:Numeric,F0:Numeric,F1:Numeric,quality:Int)->begin
  local t0:= 0; local f0:=F0         -level;
  local t1:= 1; local f1:=F1         -level;
  local tm:=t_; local fm:=F@(x+dx*t_)-level;
  [1..quality].each(step,begin
    f0*fm>0
    ? begin f0:=fm; t0:=tm; end
    : begin f1:=fm; t1:=tm; end;
    local tm_:=t1-f1*(t0-t1)/(f0-f1);
    tm:=0<=tm_<=1
        ? tm_
        : (t0+t1)/2;
    fm:=F@(x+dx*tm)-level;
  end);
  x+dx*tm;
end;

USE customFormUtil;

@SuppressUnusedWarning=all
contourPlot(F:Expression(2),x0,x1>x0,y0,y1>y0,triangleCount>=2,contourLevels:NumericList,qualityLevel>=0,interactive:Boolean)->begin
  local geometry:=prepareGeometry(F,x0,x1,y0,y1,triangleCount);
  local nodes    :=geometry[0];
  local triangles:=geometry[1];
  //Convert geometry to a list of adjacent edges
  plot();
  local edgePairs:=[].toSet;
  local edgeList:=[].toSet;
  triangles.each(tri,begin
    local e:=tri.edges;
    e.subSets(2).each(pair,edgePairs|=[pair.sort]);
    e.each(edge,edgeList|=[edge]);
    void;
  end);
  edgeList:=edgeList.sort;
  local edgeZ0:=nodes.getAll(edgeList.getInner(0));
  local edgeZ1:=nodes.getAll(edgeList.getInner(1));
  local edgeXY0:=edgeZ0.getInner([0,1]); edgeZ0:=edgeZ0.getInner(2);
  local edgeXY1:=edgeZ1.getInner([0,1]); edgeZ1:=edgeZ1.getInner(2);
  edgeList:=edgeList.pEach(e,[e,index]).toMap;
  edgePairs:=edgePairs.pMap({edgeList.getAll($p)});

  edgeZ1 :=1/(edgeZ1 -edgeZ0 );
  edgeXY1:=  (edgeXY1-edgeXY0);

  local dataForLevel:={begin
    local t:=($level-edgeZ0)*edgeZ1;
    local mask:=0<=t<=1;
    local cut:=edgeXY0+edgeXY1*t;
    qualityLevel>0
    ? cut:=mask.pEach(m,m
         ? cutLine(F,edgeXY0[index], edgeXY1[index],$level,
                     t[index],edgeZ0[index],edgeZ0[index]+1/edgeZ1[index],qualityLevel)
         : 0)
    : void;
    edgePairs.pEach(p,mask[p[0]] AND mask[p[1]]
                      ? [cut[p[0]],cut[p[1]],[Nan,Nan]]
                      : void,|);
  end};

  contourLevels
  .sort
  .map(dataForLevel)
  .each(sample,
    sample.size==0
    ? void
    : sample.addPlot(contourLevels.size=0 ? 'black' : 'HUE'&(index*2/(3*contourLevels.size-1))));

  interactive ? void : return void;

  display;
  local x:=0;
  local y:=0;
  local f:=0;
  showDialog('Interactive Contour Plot',[
    newLabel.withCaption({'x='&x}),
    newLabel.withCaption({'y='&y}),
    newLabel.withCaption({'f(x,y)='&f}),
    newPlotLink.withMouseMoved({begin
    x:=$x;
    y:=$y;
    f:=F($x,$y);
    local lines:=dataForLevel(f);
    lines.size==0 ? void : addPlot(lines,'black');
    display;
    lines.size==0 ? void : removePlot;
  end})]);
end;

densityPlot(f:Expression(2),x0,x1>x0,y0,y1>y0,sampleCount>=4,interactive:Boolean)->begin
  local xSamples:=sqrt((x1-x0)/(y1-y0)*sampleCount).round.max(1);
  local ySamples:=sqrt((y1-y0)/(x1-x0)*sampleCount).round.max(1);
  local hx:=(x1-x0)/xSamples;
  local hy:=(y1-y0)/ySamples;
  local samples:=cross(x0+hx*([0..xSamples-1]+0.5),
                       y0+hy*([0..ySamples-1]+0.5)).pMap({$x||(f@$x)});

  samples.getInner(2).isNumericList
  ? void
  : fail('f must return a numeric result');

  local z0:=samples.getInner(2).min;
  local z1:=samples.getInner(2).max;
  z1:=1/(z1-z0);
  local c:={format('polygon 0 TI0 RGB%s,%s,%s',
  1-max(2*$x-1       ,0),
  1-max(1-2*$x,2*$x-1,0),
  1-max(1-2*$x       ,0))};
  local style:={c(($z-z0)*z1)};

  local d0:=[hx,-hx,-hx, hx]/2;
  local d1:=[hy, hy,-hy,-hy]/2;

  plot();
  samples
  .pMap({[$s[0]+d0,$s[1]+d1,style($s[2])]})
  .each(polygon,addPlot@polygon);

  interactive ? void : return void;

  display;
  local x:=0;
  local y:=0;
  local f:=0;
  showDialog('Interactive Density Plot',[
    newLabel.withCaption({'x='&x}),
    newLabel.withCaption({'y='&y}),
    newLabel.withCaption({'f(x,y)='&f}),
    newPlotLink.withMouseMoved({begin
    x:=$x;
    y:=$y;
    f:=f($x,$y);
  end})]);
end;
