mutable cached_primes:=[2,3];
mutable max_cached:=3;

//*Return prime numbers <= n
synchronized
primes(n:int)->
  n<=max_cached
  ? cached_primes%(cached_primes<=n)
  : begin
      while(n>max_cached,begin
        local candidates:=[max_cached+1..max_cached:=min(n,max_cached*max_cached)];
        cached_primes:=cached_primes|(candidates%each(p,cached_primes%(cached_primes<=sqrt(max_cached)),and,candidates mod p != 0));
      end);
      cached_primes%(cached_primes<=n);
    end;

//*Return prime numbers <= floor(n)
primes(n:real)->primes(floor(n));

isPrime(n:int)->n in cached_primes ? true :
                n <= max_cached    ? false :
                trueCount(n mod primes(sqrt(n))=0)=0;

//*Returns the first k primes
firstKPrimes(k:int)->k<size(cached_primes) ? head(cached_primes,k)
                                           : (primes(max(k*11,round(max_cached*1.1))))%-1 | firstKPrimes(k);

//*Factorize number <code>n</code> using prime numbers from function <code>primes</code>
factorize(n:int)-> n<=1 ? [1] :
begin
  local factors:=[];
  local k:=n;
  local P:=primes(sqrt(k));
  each(p,P%(k mod P=0),
    while(k mod p = 0, begin
      k:=k div p;
      factors|=p;
    end));
  factors|k;
end;

//*Return the dividers of integer <code>n</code>
dividers(n:int)->begin
  local C:=[2..floor(sqrt(n))];
  C:=C%(n mod C = 0);
  unique(1|C|(n div C));
end;
//*Return the divider-sum of integer <code>n</code>
memoized dividerSum(n:int)->each(d,dividers(n),+);


dividerPairs(n:int)->each(d,[2..floor(sqrt(n))]%(n mod [2..floor(sqrt(n))]=0),[d,n div d]);

private testEx(e:expression)->printf("%X20% = %X%",unbrace(string(e)),string(e()));
//*Call functions for reg-testing
main->testEx({primes(100)}) |
      testEx({factorize(121350)}) |
      testEx({dividers(121350)}) |
      testEx({dividerSum(121350)}) |
      testEx({dividerPairs(121350)});
