USE GUI;

private avg([])->Nan;
private avg(L:numericList)->L.agg(+)/L.size;
private sigma(L:numericList)->sqrt(avg(sqr(L-L.avg)));
private quartiles([])->[Nan,Nan,Nan];
private quartiles(L:numericList)->L.sort[(L.size*[1..3] div 4)];
private quartiles(x:numeric)->[x,x,x];

private average(X)->X.agg(+)/X.size;
private averageAndRelativeSigma(X)->begin
  local avg:=average(X);
  local variance:=average((X-avg)^2);
  [avg,sqrt(variance)/avg];
end;


private doAnalysis(rt:list)->begin
  ([['Test','|','o.s.','25%ile','opt.median','75%ile','|','d.s.','25%ile','deb.median','75%ile','|','ratios']]|
  rt.getInner(0).unique.pEach(testCase,
    begin
      local debugSamples:=rt[rt.getInner(0)=testCase];
      local debugMask:=debugSamples.getInner(1).matches('^[F|L]D');
            debugSamples:=debugSamples.getInner(2);
      local optSamples  :=debugSamples[not(debugMask)];// debugSamples.each(sample,sample[1].matches('^[F|L]D') ? void : sample[2]).sort;
            debugSamples:=debugSamples[    debugMask ];// debugSamples.each(sample,sample[1].matches('^[F|L]D') ? sample[2] : void).sort;
      [testCase,'|',
       optSamples.size,
       local optQ:=optSamples.quartiles.round(4),'|',
       debugSamples.size,
       local debQ:=debugSamples.quartiles.round(4),'|',
       round(debQ/optQ,2)].flatten;
    end)
  ).showTable('Test times',true);

  [true,false].each(debugVersions,begin
    local filteredTests:=rt.each(t,t[1].matches('^[F|L]I?D')=debugVersions ? t : void);
    print("=====================================================================\n",
          " Analysis for ",debugVersions ? '' : 'non-',"debug flavours\n",
          "=====================================================================\n");
    local tests  :=filteredTests.getInner(0).unique;
    local flavors:=filteredTests.getInner(1).unique;
    local testsWithTime:=tests.each(t,t|averageAndRelativeSigma(filteredTests.get(filteredTests.getInner(0)=t).getInner(2))).sort(1);
    local totalTime:=testsWithTime.getInner(1).agg(+);
    print("Fast tests: ");
    print(testsWithTime.head(5)    .each(t,"  \v"&t[0]&"\t"&t[1]&"\vs\t"&round(100*t[1]/totalTime,3)&"\v%\n",&));
    print("Slow tests: ");
    print(testsWithTime.trailing(5).each(t,"  \v"&t[0]&"\t"&t[1]&"\vs\t"&round(100*t[1]/totalTime,3)&"\v%\n",&));
    testsWithTime:=testsWithTime.sort(2);
    print("Tests with big relative variance: ");
    print(testsWithTime.trailing(5).each(t,"  \v"&t[0]&"\t"&round(t[1],6)&"\v+/-\v"&round(100*t[2],3)&"%\n",&));
    testsWithTime:=testsWithTime[sortPerm(testsWithTime.getInner(1)*testsWithTime.getInner(2))];
    print("Tests with big absolute variance: ");
    print(testsWithTime.trailing(5).each(t,"  \v"&t[0]&"\t"&round(t[1],6)&"\v+/-\v"&round(t[1]*t[2],6)&"s\n",&));
    totalTime:=filteredTests.getInner(2).agg(+);

    local quartileTimes:=filteredTests
                       .group(filteredTests.getInner([0,1]),{[$x[0],$x[1],$x[2]|$y[2]]}) //group by flavour + case
                       .each(entry,entry[[0,1]]|[quartiles(entry[2])]) //median time per test case
                       .group(1,{[$x[0],$x[1],$x[2]+$y[2]]}) //group by flavour
                       .getInner([1,2]); //drop case
    totalTime:=quartileTimes.getInner(1,1).agg(+);
    local star:=80/quartileTimes.getInner(1,2).max;
    print('Median test time by flavour: ');
    print("  \vFlavour\t25%ile\v\t50%ile\v\t75%ile\v\trel.\t\vvisual\n",
          flavors.each(f,"\v"&f&"\t"&round(quartileTimes[f,0],3)&"\vs\t"
                                    &round(quartileTimes[f,1],3)&"\vs\t"
                                    &round(quartileTimes[f,2],3)&"\vs\t"&round(100*quartileTimes[f,1]/totalTime,3)&"\v%\t"&bar(star,quartileTimes[f]) &"\n",&));
  end);
end;

private analyzeCase(data,testCase:string)->begin
  local debugSamples:=[];
  local optSamples:=[];
  data[data.getInner(0)=testCase]
  .each(sample,sample[1].matches('^[F|L]D')
               ? debugSamples|=[sample[[2,1]]]
               : optSamples  |=[sample[[2,1]]]);
  local allSamples:=debugSamples|optSamples;
  allSamples.group(1).pEach(g,g[0,1]|g.getInner(0).reverseList).transpose('').showTable('Times for '&testCase&' (newest first)',true);

  debugSamples:=debugSamples.sort;
  optSamples:=optSamples.sort;
  print("Samples for optimized versions:\t",optSamples.size,"\nSamples for debug versions:\t",debugSamples.size,"\n");

  local table:=[['',"25%ile","50%ile","75%ile","average","std. dev"]]|
        ([['optimized',optSamples.getInner(0)]]|
         (optSamples.getInner(1).unique.each(flavour,["  "&flavour,optSamples[optSamples.getInner(1)=flavour].getInner(0)]))|
         [["\ndebug",debugSamples.getInner(0)]]|
         (debugSamples.getInner(1).unique.each(flavour,["  "&flavour,debugSamples[debugSamples.getInner(1)=flavour].getInner(0)])))
         .each(set,[set[0],set[1].quartiles,set[1].avg,set[1].sigma].flatten);

  local star:=80/table.getInner(3).tail.max;
  table:=table.each(line,index=0 ? line|'visual' : line|bar(star,line[[1..3]]));
  table.each(line,line.each(x,x.isNumeric ? round(x,4) : x).join("\t")).join("\n").print;

  setOptions([['fontsize',6],['preserveAspect',false],['autoscaleX',true],['autoscaleY',true]]);
  plot([]);
  allSamples:=allSamples.group(1).each(g,g.getInner(0));
  local minSize:=allSamples.pMap(::size).min;
  allSamples.each(g,g.trailing(minSize).addPlot);
  plot.display;
end;

private analyzeFlavour(data,flavour:string)->begin
  local groupedData:=
  data[data.getInner(1)=flavour] //filter by flavour
  .pEach(e,e[[0,2]]) //drop flavour info
  .group(0,{[$x[0],$x[1]|$y[1]]}) //group by case
  .sort;
  groupedData
  .pEach(case,[case[0],                       //0 - case name
               case[1].size,                  //1 - sample count
               case[1].agg(+)/size(case[1]),  //2 - average
               case[1].trailing(2).head,      //3 - sample before last
               case[1].trailing])             //4 - last sample
  .{$L|['TOTAL'| $L.agg(+).tail]}
  .pEach(case,[case[0],case[1]  ,case[2]  ,case[3] ,case[4],case[4]-case[2],case[4]-case[3],round((case[4]/case[2]-1)*100,2),round((case[4]/case[3]-1)*100,2)])
  .{showTable([['case','samples','average','before','last','+avg','+before','+%avg','+%before']]|$L,true)};
  setOptions([['fontsize',6],['preserveAspect',false],['autoscaleX',true],['autoscaleY',true]]);
  plot;
  //times only
  groupedData:=groupedData.getInner(1);
  //fill with Nan from left to equal size
  local maxSize:=groupedData.each(L,L.size,max);
  groupedData:=groupedData.each(L,L.size<maxSize ? [1..maxSize-L.size].each(i,Nan)|L : L).each(L,L.isList ? L : [L]);
  groupedData.each(L,addPlot(L,'0.5 black'));
  plot.display;
  [0..maxSize-1].each(i,groupedData.getInner(i).each(t,isNan(t) ? void : t).{$T.agg(+)/$T.size}).addPlot('2 red');
  plot.display;
end;

private compareFlavours(data,flavour1:string,flavour2:string)->begin
  local dat1:=data[data.getInner(1)=flavour1].pEach(e,e[[0,2]]).group(0,{[$x[0],$x[1]|$y[1]]}).pEach(case,[case[0],[case[1].agg(+)/size(case[1]),case[1].trailing]]);
  local dat2:=data[data.getInner(1)=flavour2].pEach(e,e[[0,2]]).group(0,{[$x[0],$x[1]|$y[1]]}).pEach(case,[case[0],[case[1].agg(+)/size(case[1]),case[1].trailing]]);
  local tableData:=dat1.getInner(0).union(dat2.getInner(0))
    .each(case,case|(dat1[case] orElse [0,0])|(dat2[case] orElse [0,0]))
    .{$L|['TOTAL'| $L.agg(+).tail]}
    .each(line,line|(100*(1-line[[3,4]]/line[[1,2]]))|(line[[3,4]]-line[[1,2]]));

  showTable([['case','avg. '&flavour1,'last '&flavour1,
                     'avg. '&flavour2,'last '&flavour2,
                     'rel.avg. (%)'  ,'rel.last (%)',
                     'Delta.avg.'  ,'Delta.last']]|tableData,'Flavour comparison',true);
end;

private loadAndFilterUnplausible(filename)->filename.fileContents.deserialize.pEach(i,0<=i[2]<=500 ? i : void);

main(inputFile:string)->doAnalysis(inputFile.loadAndFilterUnplausible);
bar(factor,q)->begin
  local a:=round(factor*q[0]);
  local b:=round(factor*q[1]);
  local c:=round(factor*q[2]);
  (a<b ? repeat('-',a-1)&'<' : repeat('-',a-1))&
         repeat('=',b-a-1)&'|'&
  (b<c ? repeat('=',c-b-1)&'>' : '');
end;

main(inputFile:string,testCaseOrFlavour:string)->begin
  local data:=inputFile.loadAndFilterUnplausible;
  testCaseOrFlavour in data.getInner(0)
  ? analyzeCase(data,testCaseOrFlavour)
  : testCaseOrFlavour in data.getInner(1)
    ? analyzeFlavour(data,testCaseOrFlavour)
    : begin
        print('Input is neither test case nor flavor');
        print('Flavours: ',data.getInner(1).unique.join(' '));
        print('Cases: ',data.getInner(0).unique.join(' '));
      end;
end;

main(inputFile:string,flavour1:string,flavour2:string)->begin
  local data:=inputFile.loadAndFilterUnplausible;
  flavour1 in data.getInner(1) AND
  flavour2 in data.getInner(1)
  ? compareFlavours(data,flavour1,flavour2)
  : begin
      print('Input must be two flavours to compare');
      print('Flavours: ',data.getInner(1).unique.join(' '));
    end;
end;
