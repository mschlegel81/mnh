 in> arity({3});
out> 0
 in> arity({sin($x)/$x});
out> 1
 in> arity({sin($x)/$y});
out> 2
 in> arity({printf('%X%%X%',$a,...)});
out> 1
 in> expression('$x-$x^2+$x^3');
out> {($x-$x^2+$x^3)}
 in>                expression('');
Error               The parsed expression appears to be empty
Error               Cannot apply intrinsic rule expression to parameter list ('')
Error [stack trace] 0:  || expression('')
out>                expression('')
 in> not(true);
out> false
 in> not([true,false,true]);
out> [false,true,false]
 in> not({$x});
out> {not($x)}
 in> not(7);
out> -8
 in> parameterNames({3});
out> []
 in> parameterNames({sin($x)/$x});
out> ['$x']
 in> parameterNames({sin($x)/$y});
out> ['$x','$y']
 in> parameterNames({printf('%X%%X%',$a,...)});
out> ['$a']
 in> ord(3);
out> 3
 in> ord(true);
out> 1
 in> ord(false);
out> 0
 in> ord('A');
out> 65
 in> ord('abc');
out> -1
 in>                ord(2.1);
Error               ord can only be applied to booleans, ints and strings
Error [stack trace] 0:  || <ERR>
out>                <ERR>
 in> softCast('A');
out> 'A'
 in> softCast('"B"');
out> 'B'
 in> softCast(3);
out> 3
 in> softCast([1,'2','true',"'TEXT'",'1.5','2,6']);
out> [1,2,true,'TEXT',1.5,'2,6']
 in> splitFileName('../test.txt');
out> [['input','../test.txt'],['expanded','D:/dev/test.txt'],['relative','../test.txt'],['directory','..'],['filename','test.txt'],['extension','.txt']]
 in> string('a');
out> 'a'
 in> string(234);
out> '234'
 in> string([1,2.6,'a',true,{$x}]);
out> "[1,2.6,'a',true,{$x}]"
 in> abs(-0.92);
out> 0.92
 in> abs(3);
out> 3
 in> abs({1+$x});
out> {abs(1+$x)}
 in> arccos(-0.92);
out> 2.73887681200913
 in> arccos(3);
out> Nan
 in> arccos({1+$x});
out> {arccos(1+$x)}
 in> arcsin(-0.92);
out> -1.16808048521424
 in> arcsin(3);
out> Nan
 in> arcsin({1+$x});
out> {arcsin(1+$x)}
 in> tan(-0.92);
out> -1.31326369932025
 in> tan(3);
out> -0.142546543074278
 in> tan({1+$x});
out> {tan(1+$x)}
 in> tan(2*arctan(1));
out> 1.63317787283838E16
 in> arctan(-0.92);
out> -0.74375558429886
 in> pi :=4*arctan(1);
 in> pi;
out> 3.14159265358979
 in> arctan({$x});
out> {arctan($x)}
 in> argMax(sin([0..10]));
out> 8
 in> argMax([1,3,3,0,2]);
out> 1
 in> argMin(sin([0..10]));
out> 5
 in> argMin([1,3,3,0,2]);
out> 3
 in> ceil(20/3);
out> 7
 in> ceil([0..3]/3);
out> [0,1,1,1]
 in> ceil([0..3]/3,2);
out> [0.0,0.34,0.67,1.0]
 in> ceil(20/3,[-1..3]);
out> [10.0,7.0,6.7,6.67,6.667]
 in> floor(20/3);
out> 6
 in> floor([0..3]/3);
out> [0,0,0,1]
 in> floor([0..3]/3,2);
out> [0.0,0.33,0.66,1.0]
 in> floor(20/3,[-1..3]);
out> [0.0,6.0,6.6,6.66,6.666]
 in> round(20/3);
out> 7
 in> round([0.5,1.5,2.5,3.5]);
out> [0,2,2,4]
 in> round([0..3]/3,2);
out> [0.0,0.33,0.67,1.0]
 in> round(20/3,[-1..3]);
out> [10.0,7.0,6.7,6.67,6.667]
 in> isInRange(7,0,10);
out> true
 in> isInRange(7,0.3,+Inf);
out> true
 in> isInRange([0..9]/10,0.3,0.57);
out> [false,false,false,true,true,true,false,false,false,false]
 in> isInfinite(Nan);
out> false
 in> isInfinite(+Inf);
out> true
 in> isInfinite(-+Inf);
out> true
 in> isInfinite([-3.4344,Nan,+Inf]);
out> [false,false,true]
 in> isNan(Nan);
out> true
 in> isNan(+Inf);
out> false
 in> isNan(-+Inf);
out> false
 in> isNan([-3.4344,Nan,+Inf]);
out> [false,true,false]
 in> cos(-0.92);
out> 0.605820156643463
 in> cos(3);
out> -0.989992496600446
 in> cos({1+$x});
out> {cos(1+$x)}
 in> exp(-0.92);
out> 0.398519041084514
 in> exp(3);
out> 20.0855369231877
 in> exp({1+$x});
out> {exp(1+$x)}
 in> ln(-0.92);
out> Nan
 in> ln(3);
out> 1.09861228866811
 in> ln({1+$x});
out> {ln(1+$x)}
 in> ln(-0.92);
out> Nan
 in> sin(3);
out> 0.141120008059867
 in> sin({1+$x});
out> {sin(1+$x)}
 in> sqr(-0.92);
out> 0.8464
 in> sqr(3);
out> 9
 in> sqr({1+$x});
out> {sqr(1+$x)}
 in> sqrt(-0.92);
out> Nan
 in> sqrt(3);
out> 1.73205080756888
 in> sqrt({1+$x});
out> {sqrt(1+$x)}
 in> sign(-0.92);
out> -1
 in> sign(3);
out> 1
 in> sign({1+$x});
out> {sign(1+$x)}
 in> max(['a'..'z']);
out> 'z'
 in> max([0..9]/2);
out> 4.5
 in> max(true,false);
out> true
 in> min(['a'..'z']);
out> 'a'
 in> min([0..9]/2);
out> 0.0
 in> min(true,false);
out> false
 in> copy('abcde',1,3);
out> 'bcd'
 in> escape('a');
out> "'a'"
 in> escape("\t");
out> '"\t"'
 in> format('%X5% is a string or something left aligned',true);
out> 'true  is a string or something left aligned'
 in> format('%I5% is a string or something right aligned',true);
out> ' true is a string or something right aligned'
 in> format('%I%',3);
out> '3'
 in> format('%dd.mm.yyyy%',3.21);
out> '02.01.1900'
 in> format('%hh:nn:ss%',3.21);
out> '05:02:24'
 in> format('%00.000%',3.21);
out> '03.210'
 in> format('%#0.00##%',[3.21567,5]);
out> " 3.2157\n 5.00  "
 in> group([1..10],[1..10] mod 3=0);
out> [[1,2,4,5,7,8,10],[3,6,9]]
 in>                fail;
Error               Fail.
Error               Cannot apply intrinsic rule fail to empty parameter list
Error [stack trace] 0:  || fail
out>                fail
 in>                fail("Told you this wouldn't work!");
Error               "Told you this wouldn't work!"
Error               Cannot apply intrinsic rule fail to parameter list ('Told ... work')
Error [stack trace] 0:  || fail('Told ... work')
out>                fail('Told ... work')
 in> hash(1);
out> 3
 in> hash([1..3]);
out> 271003
 in> hash('a');
out> 252
 in> each(func,listBuiltin,copy(func,0,4)=='mnh.' ? func : void);
out> ['mnh.string','mnh.executor','mnh.sandBoxExecute','mnh.fail','mnh.expression','mnh.group','mnh.parameterNames','mnh.myPath','mnh.not','mnh.sleep','mnh.splitFileName','mnh.arity','mnh.listBuiltin','mnh.ord','mnh.softCast','mnh.hash']
 in> group([[1,'a'],[2,'a'],[1,'b'],[4,'c'],[2,'a'],[2,'b']],1,aggregator({[$x%0+$y%0,$x%1]}));
out> [[5,'a'],[3,'b'],[4,'c']]
 in> abs(3);
out> 3
 in> abs(-3);
out> 3
 in> abs([-2..2]/2);
out> [1.0,0.5,0.0,0.5,1.0]
 in> chars('This is a test.');
out> ['T','h','i','s',' ','i','s',' ','a',' ','t','e','s','t','.']
 in> chars%100;
out> 'd'
 in> clean('+21/232/2116-11',['0'..'9'],' ');
out> ' 21 232 2116 11'
 in> join(['a','b','c']);
out> 'abc'
 in> join([1..5],' ');
out> '1 2 3 4 5'
 in> length('Test');
out> 4
 in> length(['Text','AbC']);
out> [4,3]
 in> lower('Test');
out> 'test'
 in> lower(['Text','AbC']);
out> ['text','abc']
 in> upper('Test');
out> 'TEST'
