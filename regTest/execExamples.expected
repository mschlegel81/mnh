 in> arity({3});
out> 0
 in> arity({sin($x)/$x});
out> 1
 in> arity({sin($x)/$y});
out> 2
 in> arity({printf('%s%s',$a,...)});
out> 1
 in> expression('$x-$x^2+$x^3');
out> {($x-$x^2+$x^3)}
 in>                expression('');
Error               The parsed expression appears to be empty
Error [stack trace]   # expression('')
out>                expression('')
 in> not(true);
out> false
 in> not([true, false, true]);
out> [false,true,false]
 in> not({$x});
out> {not($x)}
 in> not(7);
out> -8
 in> parameterNames({3});
out> []
 in> parameterNames({sin($x)/$x});
out> ['$x']
 in> parameterNames({sin($x)/$y});
out> ['$x','$y']
 in> parameterNames({printf('%s%s',$a,...)});
out> ['$a']
 in> ord(3);
out> 3
 in> ord(true);
out> 1
 in> ord(false);
out> 0
 in> ord('A');
out> 65
 in> ord('abc');
out> -1
 in>                ord(2.1);
Error               ord can only be applied to booleans, ints and strings
Error [stack trace]   # <ERR>
out>                <ERR>
 in> softCast('A');
out> 'A'
 in> softCast('"B"');
out> 'B'
 in> softCast(3);
out> 3
 in> softCast([1,'2','true',"'TEXT'",'1.5','2,6']);
out> [1,2,true,'TEXT',1.5,'2,6']
 in> splitFileName('../test.txt');
out> [['input','../test.txt'],['expanded','D:/dev/test.txt'],['relative','../test.txt'],['directory','..'],['filename','test.txt'],['extension','.txt'],['drive','D:']]
 in> string('a');
out> 'a'
 in> string(234);
out> '234'
 in> string([1, 2.6,'a', true,{$x}]);
out> "[1,2.6,'a',true,{$x}]"
 in> abs(-0.92);
out> 0.92
 in> abs(3);
out> 3
 in> abs({1+$x});
out> {abs(1+$x)}
 in> arccos(-0.92);
out> 2.73887681200913
 in> arccos(3);
out> Nan
 in> arccos({1+$x});
out> {arccos(1+$x)}
 in> arcsin(-0.92);
out> -1.16808048521424
 in> arcsin(3);
out> Nan
 in> arcsin({1+$x});
out> {arcsin(1+$x)}
 in> tan(-0.92);
out> -1.31326369932025
 in> tan(3);
out> -0.142546543074278
 in> tan({1+$x});
out> {tan(1+$x)}
 in> tan(2*arctan(1));
out> 1.63317787283838E16
 in> arctan(-0.92);
out> -0.74375558429886
 in>  pi :=4*arctan(1);
Note  Creating new rule: pi
 in>  pi;
out>  3.14159265358979
 in> arctan({$x});
out> {arctan($x)}
 in> argMax(sin([0..10]));
out> 8
 in> argMax([1, 3, 3, 0, 2]);
out> 1
 in> argMin(sin([0..10]));
out> 5
 in> argMin([1, 3, 3, 0, 2]);
out> 3
 in> ceil(20/3);
out> 7
 in> ceil([0..3]/3);
out> [0,1,1,1]
 in> ceil([0..3]/3, 2);
out> [0.0,0.34,0.67,1.0]
 in> ceil(20/3,[-1..3]);
out> [10.0,7.0,6.7,6.67,6.667]
 in> floor(20/3);
out> 6
 in> floor([0..3]/3);
out> [0,0,0,1]
 in> floor([0..3]/3, 2);
out> [0.0,0.33,0.66,1.0]
 in> floor(20/3,[-1..3]);
out> [0.0,6.0,6.6,6.66,6.666]
 in> round(20/3);
out> 7
 in> round([0.5, 1.5, 2.5, 3.5]);
out> [0,2,2,4]
 in> round([0..3]/3, 2);
out> [0.0,0.33,0.67,1.0]
 in> round(20/3,[-1..3]);
out> [10.0,7.0,6.7,6.67,6.667]
 in> isInRange(7, 0, 10);
out> true
 in> isInRange(7, 0.3,+Inf);
out> true
 in> isInRange([0..9]/10, 0.3, 0.57);
out> [false,false,false,true,true,true,false,false,false,false]
 in> isInfinite(Nan);
out> false
 in> isInfinite(+Inf);
out> true
 in> isInfinite(-+Inf);
out> true
 in> isInfinite([-3.4344, Nan,+Inf]);
out> [false,false,true]
 in> isNan(Nan);
out> true
 in> isNan(+Inf);
out> false
 in> isNan(-+Inf);
out> false
 in> isNan([-3.4344, Nan,+Inf]);
out> [false,true,false]
 in> cos(-0.92);
out> 0.605820156643463
 in> cos(3);
out> -0.989992496600446
 in> cos({1+$x});
out> {cos(1+$x)}
 in> exp(-0.92);
out> 0.398519041084514
 in> exp(3);
out> 20.0855369231877
 in> exp({1+$x});
out> {exp(1+$x)}
 in> ln(-0.92);
out> Nan
 in> ln(3);
out> 1.09861228866811
 in> ln({1+$x});
out> {ln(1+$x)}
 in> ln(-0.92);
out> Nan
 in> sin(3);
out> 0.141120008059867
 in> sin({1+$x});
out> {sin(1+$x)}
 in> sqr(-0.92);
out> 0.8464
 in> sqr(3);
out> 9
 in> sqr({1+$x});
out> {sqr(1+$x)}
 in> sqrt(-0.92);
out> Nan
 in> sqrt(3);
out> 1.73205080756888
 in> sqrt({1+$x});
out> {sqrt(1+$x)}
 in> sign(-0.92);
out> -1
 in> sign(3);
out> 1
 in> sign({1+$x});
out> {sign(1+$x)}
 in> max(['a'..'z']);
out> 'z'
 in> max([0..9]/2);
out> 4.5
 in> max(true, false);
out> true
 in> min(['a'..'z']);
out> 'a'
 in> min([0..9]/2);
out> 0.0
 in> min(true, false);
out> false
 in> copy('abcde', 1, 3);
out> 'bcd'
 in> escape('a');
out> "'a'"
 in> escape("\t");
out> '"\t"'
 in> group([1..10],[1..10] mod 3=0);
out> [[1,2,4,5,7,8,10],[3,6,9]]
 in>                fail;
Error               Fail.
Error [stack trace]   # fail
out>                fail
 in>                fail("Told you this wouldn't work!");
Error               "Told you this wouldn't work!"
Error [stack trace]   # fail("Told you this wouldn't work!")
out>                fail("Told you this wouldn't work!")
 in> hash(1);
out> 3
 in> hash([1..3]);
out> 271003
 in> hash('a');
out> 252
 in> listBuiltin.each(func,copy(func, 0, 4)=='mnh.' ? func : void);
out> ['mnh.string','mnh.executor','mnh.expression','mnh.parameterNames','mnh.sleep','mnh.splitFileName','mnh.addPrintAdapter','mnh.arity','mnh.relativeFilename','mnh.listBuiltin','mnh.softCast','mnh.hash','mnh.sandBoxExecute','mnh.fail','mnh.group','mnh.addFullAdapter','mnh.myPath','mnh.not','mnh.ord','mnh.removeAdapter']
 in> group([[1,'a'],[2,'a'],[1,'b'],[4,'c'],[2,'a'],[2,'b']], 1, aggregator({[$x.get(0)+$y.get(0),$x.get(1)]}));
out> [[5,'a'],[3,'b'],[4,'c']]
 in> abs(3);
out> 3
 in> abs(-3);
out> 3
 in> abs([-2..2]/2);
out> [1.0,0.5,0.0,0.5,1.0]
 in> chars('This is a test.');
out> ['T','h','i','s',' ','i','s',' ','a',' ','t','e','s','t','.']
 in> chars.get(100);
out> 'd'
 in> clean('+21/232/2116-11',['0'..'9'],' ');
out> ' 21 232 2116 11'
 in> join(['a','b','c']);
out> 'abc'
 in> join([1..5],' ');
out> '1 2 3 4 5'
 in> length('Test');
out> 4
 in> length(['Text','AbC']);
out> [4,3]
 in> lower('Test');
out> 'test'
 in> lower(['Text','AbC']);
out> ['text','abc']
 in> upper('Test');
out> 'TEST'
 in> upper(['Text','AbC']);
out> ['TEXT','ABC']
 in>                  t :=[0..1000]*0.006283;
Note                  Creating new rule: t
 in>                  plot(t, sin(t));
Deferred plot request
Deferred plot request
out>                  void
 in>                  plot.renderToFile('plotDemo1.png', 600, 300, 4);
Image:                D:\dev\mnh5\plotDemo1.png
out>                  void
 in>                              printf('%s', sandBoxExecute('f(x<1)->random; f(x)->f(x-1)+random; f(3)').each(message,join(message,"\t")));
printline                          in>  @:1,1  f(x<1)->random;
Note  @:1,1  Creating new rule: f
 in>  @:1,17 f(x)->f(x-1)+random;
 in>  @:1,38 f(3);
out>  @:1,30 2.75506309582852
out>                              void
 in>                              abs({$x});
out>                              {abs($x)}
 in> abs(3);
out> 3
 in> abs(-5/7);
out> 0.714285714285714
 in> abs([-2..2]);
out> [2,1,0,1,2]
 in> chars('Test');
out> ['T','e','s','t']
 in> pos('o','Hello World');
out> 4
 in> pos(',',['Hello','Test','1,2,3']);
out> [-1,-1,1]
 in> pos(['a','b'],'cdb');
out> [-1,2]
 in> repeat('-', 10);
out> '----------'
 in> replace('[[][]][]][][','[]','');
out> ']['
 in> replace('aba','b','bb');
out> 'abba'
 in> replaceOne('[[][]][]][][','[]','');
out> '[[]][]][]['
 in> replaceOne('1:.-.; 2:.-.; 3:.-.','.',['a'..'e']);
out> '1:a-b; 2:c-d; 3:e-.'
 in> split('1,2,3;4,5,6',',');
out> ['1','2','3;4','5','6']
 in> split('1,2,3;4,5,6',';');
out> ['1,2,3','4,5,6']
 in> split('1,2,3;4,5,6',[';',',']);
out> ['1','2','3','4','5','6']
 in> tokenSplit('f(x)->x+1; //Stupid, but just an example...','mnh');
out> ['f','(','x',')','->','x','+','1',';',' ','//Stupid, but just an example...']
 in> trim(" \tA B C\t ");
out> 'A B C'
 in> trimLeft(" \tA B C\t ");
out> "A B C\t "
 in> trimRight(" \tA B C\t ");
out> " \tA B C"
 in> unbrace('3');
out> '3'
 in> unbrace('(3)');
out> '3'
 in> unbrace('(3]');
out> '(3]'
 in> unbrace('"3"');
out> '"3"'
 in> add([[1],[2]],[3]);
out> [[1],[2],[3]]
 in> chars('Testtext').elementFrequency;
out> [[1,'T'],[2,'e'],[1,'s'],[3,'t'],[1,'x']]
 in> flatten([1,[2,[3, 4],[5]], 6]);
out> [1,2,3,4,5,6]
 in> head(['A'..'Z']);
out> 'A'
 in> head(['A'..'Z'], 3);
out> ['A','B','C']
 in> tail(['A'..'Z']);
out> ['B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
 in> tail(['A'..'Z'], 3);
out> ['D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
 in> leading(['A'..'Z']);
out> ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y']
 in> leading(['A'..'Z'], 3);
out> ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W']
 in> trailing(['A'..'Z']);
out> 'Z'
 in> trailing(['A'..'Z'], 3);
out> ['X','Y','Z']
 in> minus([1..10]^2, 2*[0..50]);
out> [1,9,25,49,81]
 in> sort(intRandom(10, 5));
out> [1,2,3,5,9]
 in> sort(['01','10','100','1','010'],{softCast($x)<=softCast($y)});
out> ['01','1','10','010','100']
 in> sortPerm(random(10));
out> [0,2,3,4,8,7,9,5,6,1]
 in> sortPerm(['a'..'c'..'a']);
out> [0,4,1,3,2]
 in> intersect([0..1000]^2,[0..1000]^3);
out> [0,4096,262144,1,64,1000000,729,117649,531441,15625,46656]
 in> union(1/[1..5], 2/[2..6]);
out> [1.0,0.5,0.25,0.2,0.4,0.333333333333333,0.666666666666667]
 in> deleteFile('plotDemo1.png');
out> true
 in> driveInfo;
out> [['C',[['type','fixed'],['serial',1779773958],['label','']]],['D',[['type','fixed'],['serial',1915365941],['label','Cache SSD']]],['T',[['type','removable'],['serial',314219895],['label','']]]]
 in> drop([['A', 1],['B', 2],['C', 0]],'B');
out> [['A',1],['C',0]]
 in> get(['a'..'f'], 3);
out> 'd'
 in> get(['a'..'f'],[3, 1, 2]);
out> ['d','b','c']
 in> get([0..4],[2..6] mod 3=0);
out> [1,4]
 in> get([['A', 1],['B', 2],['C', 0]],'B');
out> 2
 in> getInner([[1, 2, 3],[4, 5, 6],[7, 8, 9]], 1);
out> [2,5,8]
 in> getInner([[1, 2, 3],[4, 5, 6],[7, 8, 9]],[1, 0]);
out> [[2,1],[5,4],[8,7]]
 in> getInner([[1, 2, 3],[4, 5, 6],[7, 8, 9]],[true, false, true]);
out> [[1,3],[4,6],[7,9]]
 in> indexOf([1..6]^2 mod 3=0);
out> [2,5]
 in> mapGet([['A', 1],['B', 2],['C', 0]],'B');
out>  2
 in> mapGet([['A', 1],['B', 2],['C', 0]],'D');
out> []
 in> mapGet([['A', 1],['B', 2],['C', 0]],'B',-1);
out>  2
 in> mapGet([['A', 1],['B', 2],['C', 0]],'D',-1);
out> -1
 in> mapPut([['A', 1],['B', 2],['C', 0]],'A', 0);
out> [['A',0],['B',2],['C',0]]
 in> mapPut([['A', 1],['B', 2],['C', 0]],'D', 3);
out> [['A',1],['B',2],['C',0],['D',3]]
 in> reverseList([1..5]);
out> [5,4,3,2,1]
 in> size([0.5, 0.1, 0.2]);
out> 3
 in> toMap([['A', 1],['B', 2],['C', 0],['B', 4]]);
out> [['A',1],['B',2],['C',0]]
 in> trueCount(10<[0..10]^2<50);
out> 4
 in> unique([3, 1, 2, 1, 4, 1, 5]);
out> [1,2,3,4,5]
