#!/usr/bin/mnh
USE testExpectation,test_config;

private mutable longestCaseText:=0;
private printCase(s:String)->begin
  longestCaseText:=max(longestCaseText,s.length);
  printDirect("\r",s,repeat(' ',longestCaseText-length(s)));
  s=='' ? void : note("Testcase: ",s);
end;

PREFIX_OF_MESSAGE_TYPE:=['el1_note'        =>'Note',
                         'el1_userNote'    =>'Note',
                         'el2_warning'     =>'Warning',
                         'el2_userWarning' =>'Warning',
                         'el3_userDefined' =>'Error',
                         'el3_evalError'   =>'Error',
                         'el4_systemError' =>'Error',
                         'echo_input'      =>'in>' ,
                         'echo_declaration'=>'in>' ,
                         'echo_output'     =>'out>'].toMap;
ECHOS:=['echo_input'      ,
        'echo_declaration',
        'echo_output'];

EXAMPLE_EXCLUDES:=['exitCode','timing_info','clearConsole'];
DEMO_EXCLUDES:=EXAMPLE_EXCLUDES|['echo_input','echo_declaration', 'echo_output','el1_note', 'el2_warning','el1_userNote' ,'el2_userWarning' ];

processSingleOutput('printline'  ,     location:String,output:String)->output;
processSingleOutput('echo_output',     location:String,output:String)->'out> '&output.escape&';';
processSingleOutput('echo_output',     location:String,output       )->'out> '&output.toString&';';
processSingleOutput(messageType in ['echo_input','echo_declaration'],
                                       location:String,output       )->format("%s %s",PREFIX_OF_MESSAGE_TYPE[messageType] orElse fail('Unkown prefix ',messageType),output.replace("\n","").join);
processSingleOutput(messageType:String,location:String,output:String)->format("%s %s",PREFIX_OF_MESSAGE_TYPE[messageType] orElse fail('Unkown prefix ',messageType),output);

processSandboxOutput(L:List,excludes:List)->
  L.filter((l)->l[0] not in excludes).map((output)->processSingleOutput@output).split("\n").flatten;
//   output[0]='printline'
//  ? output[2]
//  : output[0] in excludes
//    ? void
//    : output[0] in ECHOS
//      ? format("%s %s",PREFIX_OF_MESSAGE_TYPE[output[0]] orElse fail('Unkown prefix ',output[0]),output[2].toString.replace("\n ","\n").replace("\n","")&(output[0]='echo_output' ? ';' : void))
//      : format("%s %s",PREFIX_OF_MESSAGE_TYPE[output[0]] orElse fail('Unkown prefix ',output[0]),output[2])).split("\n").flatten;

testFile(scriptFileName:String,doLog:Boolean)->
 begin
    printCase(scriptFileName);
    local logName:=extractFileNameOnly(scriptFileName);
    local startTime:=scriptTime;
    local output:=runScript(testConfiguration(scriptFileName))
                 .processSandboxOutput(DEMO_EXCLUDES)
                 |checkAfterTest(scriptFileName);
    note("Collected the following output: \n",output.join("\n"));
    scriptFileName.isSmokeTest
    ? logSmokeTestRunTime(logName,
                          time-startTime,
                          doLog)
    : checkExpectation(
        logName,
        output,
        scriptTime-startTime,
        doLog);
  end;

private shorter(s:String)->
  s.length<30 ? s : copy(s,0,27)&'...';
private shorter([])->void;

private sbExecute([])->void;
private sbExecute(code:StringList)->begin
  note("Examples test code:  \n"&code.join("  \n"));
  printCase(EXAMPLES_LOG_NAME&' '&shorter(code.head));
  sandBoxExecute(code,WHITELIST_FOR_EXAMPLES).processSandboxOutput(EXAMPLE_EXCLUDES);
end;

private executeExamples(doLog:Boolean)->begin
  printCase(EXAMPLES_LOG_NAME);
  resetRandom;
  local output:=[];
  local collectOut:=true;
  local codeToExecute:=[];
  local inputLines:=fileLines(myPath.extractFileDirectory&'/../resources/examples.txt');
  local startTime:=scriptTime;
  inputLines.each(line,
    line==''
    ? begin
        collectOut
        ? output|=sbExecute(codeToExecute)
        : void;
        codeToExecute:=[];
      end
    : line.matches('==END REG TEST==')
      ? collectOut:=false
      : codeToExecute|=line);
  checkExpectation(
        EXAMPLES_LOG_NAME,
        output,
        scriptTime-startTime,
        doLog);
end;

//*Runs tests and returns true if no test failed
testAll(logging:Boolean, forceRun:Boolean)->begin
  assertUniqueInstance;
  sandBoxExecute('1');
  local toRun:=allDemos
           .filter({!skipFile($f)})
           .filter({forceRun OR !isTestAlreadyPassed(extractFileNameOnly($script))});
  local allPassed:=
  (toRun.map({testFile($script,logging)})|((local runExamples:=forceRun OR !isTestAlreadyPassed(EXAMPLES_LOG_NAME)) ? executeExamples(logging) : void)).agg(AND);
  printCase("");
  printDirect("\r");
  printf("Tests total:\t%s\nSkipped:\t%s\nExecuted:\t%s\nFailed:\t%s",
    allDemos.size+1,
    allDemos.size+1-toRun.size-ord(runExamples),
                    toRun.size+ord(runExamples),
    getFailedTests.size);
  allPassed ? print("All tests ok     ",repeat(' ',50))
            : print("Some tests failed:",repeat(' ',50),"\n",join("    "&getFailedTests,"\n")) orElse setExitCode(99);
  showTestTimeInfo;
end;

main->testAll(true,false);

//*Test again, even if all tests have been passed
main('retest')->testAll(true,true);

//*Test again, without logging passed tests
main('noLog')->testAll(false,true);

//*Display info on test cases
main('info')->allDemos.map({[$0,$0.isSmokeTest ? 'SMOKE' : '',$0.skipFile ? 'SKIP' : '',$0.testParameters.join(" ")]})
                      .sort(2)
                      .sort(1)
                      .map({$x.join("\t")})
                      .join("\n")
                      .print;

//*Run only the tests matching case, without logging and even if the test has been passed
main('only',case)->begin
  assertUniqueInstance;
  local includeTest:={$x.matches(case)};

  sandBoxExecute('1');
  local toRun:=allDemos
           .filter({!skipFile($f)})
           .filter({includeTest($script)});
  local allPassed:=
  (toRun.map({testFile($script,false)})|((local runExamples:=includeTest(EXAMPLES_LOG_NAME)) ? executeExamples(false) : void)).agg(AND);
  printCase("");
  printDirect("\r");
  printf("Tests total:\t%s\nSkipped:\t%s\nExecuted:\t%s\nFailed:\t%s",
    allDemos.size+1,
    allDemos.size+1-toRun.size-ord(runExamples),
                    toRun.size+ord(runExamples),
    getFailedTests.size);
  allPassed ? print("All tests ok     ",repeat(' ',50))
            : print("Some tests failed:",repeat(' ',50),"\n",join("    "&getFailedTests,"\n")) orElse setExitCode(99);
  showTestTimeInfo;
end;

//*Create a file test.bat for testcase by testcase heaptracing
main('makebat',exeName)->begin
  local batname:=myPath.extractFileDirectory.extractFileDirectory&'/test_reg.bat';
  local batLines:=
  allDemos.filter({!skipFile($f)})
          .map(::extractFileNameOnly)
          .|(EXAMPLES_LOG_NAME)
          .each(d,exeName&' regTest\regTest.mnh only '&d&' 2> test_'&index&'_'&d&'.log',
                  d.matches('oeis') ? '@demos\oeis.mnh stopServer' : void);
  writeFileLines(batname,batLines,"\r\n");
  print(batname,' created');
  //------------------------------------------------------------------------------
  batname:=myPath.extractFileDirectory.extractFileDirectory&'/test_noValidate.bat';
  batLines:=
  allDemos.filter({!skipFile($f)})
          .each(d,exeName&' '&join(d|testParameters(d),' ')&' 2> test_'&index&'_'&extractFileNameOnly(d)&'.log',
                  d.matches('oeis') ? '@demos\oeis.mnh stopServer' : void);
  writeFileLines(batname,batLines,"\r\n");
  print(batname,' created');
end;
