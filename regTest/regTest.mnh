USE hash;

testDirectory:=replace(splitFileName(myPath)%"relative",
                       splitFileName(myPath)%"filename","");

private PASSED_TESTS_STORE:='regTest/passedTests.dat';

restore->fileExists(PASSED_TESTS_STORE) ? expression(fileContents(PASSED_TESTS_STORE))() : [];

mutable passedTests:=restore;

storePassedTests->begin
  fileExists(PASSED_TESTS_STORE) ? begin
    local oldVal:=restore;
    each(v,oldVal,v%[0,1] in passedTests%%[0,1] ? void : passedTests|=[v]);
  end : void;
  writeFile(PASSED_TESTS_STORE,replace(string(passedTests),'],[','],\n['));
end;

synchronized markAsPassed(case,exeHash,runTime)->begin passedTests|=[[exeHash,case,fileHash(case),runTime]]; void; end;
synchronized isMarkedAsPassed(case,exeHash)->[exeHash,case,fileHash(case)] in passedTests%%[0..2];

mutable testsFailed:="";
mutable previouslyPassedTests:=0;
synchronized addFailedTest(scriptName)->copy(testsFailed:=testsFailed&format("\nkdiff %X% %X%",expectedResultName(scriptName),lastResultName(scriptName)),1,0);

expectedResultName  (scriptname)->testDirectory&replace(splitFileName(scriptname)%"filename"&"#",".mnh#",".expected");
lastResultName      (scriptname)->testDirectory&replace(splitFileName(scriptname)%"filename"&"#",".mnh#",".last");
expectedResultExists(scriptname)->fileExists(expectedResultName(scriptname));
expectedResult      (scriptname)->fileLines (expectedResultName(scriptname));
storeResult(filename,data)-> writeFileLines(filename,data) ? void : void;

runTest(executor,exeHash, scriptName,outputFileName,delOutputBefore,FMT_STRING)->
  begin
    delOutputBefore and outputFileName<>''
    ? deleteFile(outputFileName)
    : void;
    local startTime:=systime;
    local scriptOutput:=exec(executor,["-det",scriptName]) | (outputFileName="" ? [] : fileHash(outputFileName));
    local scriptTime:=(systime-startTime)*24*60*60;
    expectedResultExists(scriptName)
    ? begin
        expectedResult(scriptName)==scriptOutput
        ? printf(FMT_STRING,scriptName,scriptTime,'o.k.' | markAsPassed(scriptName,exeHash,scriptTime))
        : printf(FMT_STRING,scriptName,scriptTime,"Results differ!" &
                                                   addFailedTest(scriptName) &
                                                   storeResult(lastResultName(scriptName),scriptOutput));
      end
    : printf(FMT_STRING,scriptName,scriptTime,"No reference result found. Storing "&storeResult(expectedResultName(scriptName),scriptOutput));
  end;

main('compare')->each(test,unique(passedTests%%[1,2]),begin
  local times:=passedTests%(passedTests%%1 = test%0 and passedTests%%2 = test%1);
  size(times)<=1 ? void : begin
    times:=times%sortPerm(times%%3);
    print(test%0,' ',test%1);
    printf('%I30%\t%X%',times%%0,times%%3);
  end;
end);

main->main(executor);

main(exe,...)->begin
  testsFailed:="";
  previouslyPassedTests:=0;
  local testFilter       := tail($params);
  local currentExeInfo   := exec(exe,["-version"] ).head;
  local currentExeHash   := exec(exe,["-codeHash"]).head;
  local currentExeCanPlot:= copy(currentExeInfo,5,4)="full";
  local randomSample     := testFilter==['randomSample'];
  local checkOnly        := testFilter==['checkOnly'];
  local specific_tests   := not((testFilter==[]) or checkOnly or randomSample);
  checkOnly or randomSample ? testFilter:=[] : void;
  local testCases:=sort(each(case,
                   expression(fileContents('regTest/regTestCases.dat'))(),
                   (currentExeCanPlot or not(case%3)) and
                   (testFilter==[] OR each(f,testFilter,OR,pos(f,case%0)>=0)) ? case%[0..2] : void));

  //count already passed tests and remove them from the list
  testCases:=each(test,testCases,
    isMarkedAsPassed(test%0,currentExeHash) and not(specific_tests)
    ? begin previouslyPassedTests+=1; void; end
    : test);
  local stopAtTime:=systime+1;
  randomSample AND size(testCases)>0 ? begin
    testCases:=testCases%sortPerm(size(testCases).random);
    stopAtTime:=systime+5/(24*60*60);
  end : void;
  local FMT_STRING:="%X"&(size(testCases)=0 ? 0 : max(length(testCases%%0)))&"% %###0.00%sec %X%";
  local first:=true;
  each(test,testCases, systime>stopAtTime ? void : begin
    checkOnly ? addFailedTest(test%0) :
    begin
      first and not(checkOnly)
      ? print('---------------------------------------------------------\n',
             'Starting test runs with executable ',exe,'\n',currentExeInfo,
             '\n---------------------------------------------------------')
      : void;
      first:=false;
      runTest@(exe|currentExeHash|test|FMT_STRING);
      void;
    end;
  end);
  first ? setErrorlevel(1) : print(testsFailed);
  testsFailed<>'' ? setErrorlevel(2) : void;

  size(testCases)>0 ? begin
    print(previouslyPassedTests,' Tests were already marked as passed.');
    storePassedTests;
    //displayUncoveredTests:--------------
    local coveredTests:= replace(unique(expression(fileContents('regTest/regTestCases.dat'))()%%0),'\\','/');
    first:=true;
    each(script,
         replace(unique(files('demos/*.mnh')|files('packages/*.mnh')),'\\','/'),
         script in coveredTests ? void : begin
           first ? begin
             first:=false;
             print('The following scripts are not covered by tests:');
           end : void;
           print('  ',script);
         end);
    //--------------:displayUncoveredTests
  end : void;

  checkOnly and testsFailed<>'' ? print(size(split(testsFailed,'\n')),' tests have not been passed or executed') : void;
  testsFailed='';
end;
