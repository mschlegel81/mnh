USE hash;

private TEST_DIRECTORY    :=replace(splitFileName(myPath)%"relative",splitFileName(myPath)%"filename","");
private ROOT_DIRECTORY    :=TEST_DIRECTORY&'../';
private PASSED_TESTS_STORE:=TEST_DIRECTORY&'passedTests.dat';
private TESTS_STORE       :=TEST_DIRECTORY&'regTestCases.dat';
private NEED_PLOT_IDX:=3;

private restore->fileExists(PASSED_TESTS_STORE) ? expression(fileContents(PASSED_TESTS_STORE))() : [];
mutable passedTests:=restore;
private storePassedTests->begin
  fileExists(PASSED_TESTS_STORE) ? begin
    local oldVal:=restore;
    each(v,oldVal,v%[0,1] in passedTests%%[0,1] ? void : passedTests|=[v]);
  end : void;
  writeFile(PASSED_TESTS_STORE,string(passedTests).replace('],[',"],\n["));
end;

private synchronized markAsPassed(case,exeHash,runTime)->begin passedTests|=[[exeHash,case,fileHash(ROOT_DIRECTORY&case),runTime]]; void; end;
private synchronized isMarkedAsPassed(case,exeHash)->[exeHash,case,fileHash(case)] in passedTests%%[0..2];

mutable testsFailed:="";
mutable previouslyPassedTests:=0;
synchronized addFailedTest(scriptName)->copy(testsFailed:=testsFailed&format("\nkdiff %X% %X%",expectedResultName(scriptName),lastResultName(scriptName)),1,0);

private expectedResultName  (scriptname)->TEST_DIRECTORY&replace(splitFileName(scriptname)%"filename"&"#",".mnh#",".expected");
private lastResultName      (scriptname)->TEST_DIRECTORY&replace(splitFileName(scriptname)%"filename"&"#",".mnh#",".last");
private expectedResultExists(scriptname)->fileExists(expectedResultName(scriptname));
private expectedResult      (scriptname)->fileLines (expectedResultName(scriptname));
private storeResult(filename,data)-> writeFileLines(filename,data) ? void : void;

private average(L:numericList)->each(x,L,+)/size(L);
//*Shows statistics on passed tests
main('compare')->size(passedTests)<=0 ? print('No tests have been passed.') : begin
  local timePerTest:=each(testFile,unique(passedTests%%1),begin
    local avg  :=average(passedTests%(passedTests%%1=testFile)%%3);
    local sigma:=sqrt(average(sqr(avg-(passedTests%(passedTests%%1=testFile)%%3))));
    [testFile, avg,sigma];
  end).sort({$x%1<=$y%1});

  print('All tests ordered by time:');
  printf("%X%\t%I%s\t+/-\t%I%s",timePerTest%%0,round(timePerTest%%1,4),round(timePerTest%%2,4));
  print;

  printf@('Fastest test: %X%; average time: %0.0000%s+/-%0.0000%s'| timePerTest%(argMin(timePerTest%%1)));
  local testFile:=timePerTest%(argMin(timePerTest%%1))%0;
  local relAvgTimePerBin:=(passedTests%(passedTests%%1=testFile)%%[0,3]).sort({$x%1<=$y%1});
  printf("%X%\t:\t%X%\t%I%\ts",
    split(relAvgTimePerBin%%0,':')%%0,
    split(relAvgTimePerBin%%0,':')%%1,
    round(relAvgTimePerBin%%1,3));
  print;

  printf@('Slowest test: %X%; average time: %0.0000%s+/-%0.0000%s'| timePerTest%(argMax(timePerTest%%1)));
  local testFile:=timePerTest%(argMax(timePerTest%%1))%0;
  local relAvgTimePerBin:=(passedTests%(passedTests%%1=testFile)%%[0,3]).sort({$x%1<=$y%1});
  printf("%X%\t:\t%X%\t%I%\ts",
    split(relAvgTimePerBin%%0,':')%%0,
    split(relAvgTimePerBin%%0,':')%%1,
    round(relAvgTimePerBin%%1,3));
  print;

  local testWithTime:=timePerTest%(argMax(timePerTest%%2/timePerTest%%1));
  printf@('Test with the largest relative variance: %X%; average time: %0.0000%s+/-%0.0000%s'|(testWithTime));
  local relAvgTimePerBin:=(passedTests%(passedTests%%1=testWithTime%0)%%[0,3]).sort({$x%1<=$y%1});
  printf("%X%\t:\t%X%\t%I%\ts",
    split(relAvgTimePerBin%%0,':')%%0,
    split(relAvgTimePerBin%%0,':')%%1,
    round(relAvgTimePerBin%%1,3));
  print;

  local currentExeHash:= executor.exec(["-codeHash"]).head.split(':');
  local currentBin:=currentExeHash%0;
  local relAvgTimePerBin:=each(bin,unique((passedTests%%0).split(':')%%0),begin
    local passedByBin:=passedTests%(((passedTests%%0).split(':')%%0)=bin)%%[1,3]; //testFile and time
    [bin,100*(average(each(pass,passedByBin,pass%1/((timePerTest%%[0,1])%(pass%0))))-1),bin=currentBin ? " (current)":""];
  end).sort({$x%1<=$y%1});
  print('Average relative time of executables by flavour: ');
  printf("%I20%\t%I%\t%%\t%X%",relAvgTimePerBin%%0,round(relAvgTimePerBin%%1,2),relAvgTimePerBin%%2);
  print;
  
  currentBin:=currentExeHash%1;  
  relAvgTimePerBin:=each(bin,unique((passedTests%%0).split(':')%%1),begin
    local passedByBin:=passedTests%(((passedTests%%0).split(':')%%1)=bin)%%[1,3]; //testFile and time
    [bin,100*(average(each(pass,passedByBin,pass%1/((timePerTest%%[0,1])%(pass%0))))-1),bin=currentBin ? " (current)":""];
  end).sort({$x%1<=$y%1});
  print('Average relative time of executables by code hash: ');  
  printf("%I20%\t%I%\t%%\t%X%",relAvgTimePerBin%%0,round(relAvgTimePerBin%%1,2),relAvgTimePerBin%%2);
end;

//*Executes all tests with current interpreter
main->main(executor);

private runTest(executor,exeHash, scriptName,outputFileName,delOutputBefore,FMT_STRING)->
  begin
    delOutputBefore and outputFileName<>''
    ? deleteFile(ROOT_DIRECTORY&outputFileName)
    : void;
    local startTime:=systime;
    local scriptOutput:=exec(executor,["-det",ROOT_DIRECTORY&scriptName]) | (outputFileName="" ? [] : fileHash(ROOT_DIRECTORY&outputFileName));
    local scriptTime:=(systime-startTime)*24*60*60;
    expectedResultExists(scriptName)
    ? begin
        expectedResult(scriptName)==scriptOutput
        ? printf(FMT_STRING,scriptName,scriptTime,'o.k.' | markAsPassed(scriptName,exeHash,scriptTime))
        : printf(FMT_STRING,scriptName,scriptTime,"Results differ!" &
                                                   addFailedTest(scriptName) &
                                                   storeResult(lastResultName(scriptName),scriptOutput));
      end
    : printf(FMT_STRING,scriptName,scriptTime,"No reference result found. Storing "&storeResult(expectedResultName(scriptName),scriptOutput));
  end;


//*Executes tests; 
//*Optionals can be: "randomSample" or (parts of) test case names
main(exe,...)->begin
  testsFailed:="";
  previouslyPassedTests:=0;
  local testFilter       := ...;
  local currentExeInfo   := exe.exec(["-version"] ).head;
  local currentExeHash   := exe.exec(["-codeHash"]).head;
  local currentExeCanPlot:= copy(currentExeInfo,5,4)="full";
  local randomSample     := testFilter==['randomSample'];
  local specific_tests   := not((testFilter==[]) or randomSample);
  randomSample ? testFilter:=[] : void;
  local testCases:=sort(each(case,
                   expression(fileContents(TESTS_STORE))(),
                   (currentExeCanPlot OR not(case%NEED_PLOT_IDX)) and
                   (testFilter==[] OR each(f,testFilter,OR,pos(f,case%0)>=0)) ? case%[0..2] : void));

  //count already passed tests and remove them from the list
  testCases:=each(test,testCases,
    isMarkedAsPassed(test%0,currentExeHash) and not(specific_tests)
    ? begin previouslyPassedTests+=1; void; end
    : test);
  local stopAtTime:=systime+1;
  randomSample AND size(testCases)>0 ? begin
    testCases:=testCases%sortPerm(size(testCases).random);
    stopAtTime:=systime+5/(24*60*60);
  end : void;
  local FMT_STRING:="%X"&(size(testCases)=0 ? 0 : max(length(testCases%%0)))&"% %###0.00%sec %X%";
  local first:=true;
  each(test,testCases, (systime>stopAtTime) OR (testsFailed<>'') ? void : begin
    begin
      first
      ? print("---------------------------------------------------------\n",
             "Starting test runs with executable ",exe,"\n",currentExeInfo,
             "\n---------------------------------------------------------")
      : void;
      first:=false;
      runTest@(exe|currentExeHash|test|FMT_STRING);
      void;
    end;
  end);
  first ? setErrorlevel(1) : print(testsFailed);
  testsFailed<>'' ? setErrorlevel(2) : void;

  size(testCases)>0 ? begin
    print(previouslyPassedTests,' Tests were already marked as passed.');
    storePassedTests;
    //displayUncoveredTests:--------------
    local coveredTests:=(expression(fileContents(TESTS_STORE))()%%0).unique.splitFileName%%'expanded';
    first:=true;
    each(script,
         (files(ROOT_DIRECTORY&'demos/*.mnh')|files(ROOT_DIRECTORY&'packages/*.mnh')).unique.splitFileName%%'expanded',
         script in coveredTests ? void : begin
           first ? begin
             first:=false;
             print('The following scripts are not covered by tests:');
           end : void;
           print('  ',script);
         end);
    //--------------:displayUncoveredTests
    first ? print('There are no scrips uncovered by tests') : void;
  end : void;

  testsFailed='';
end;
