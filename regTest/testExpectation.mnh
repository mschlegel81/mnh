USE guiScripts,test_config,'..\make_config.mnh',formattingUtils;
private plain datastore expectations:=[].toMap;
private datastore runTimes:=[].toMap;

private testRootLinux  :=myPath.extractFileDirectory.extractFileDirectory;
private testRootWindows:=testRootLinux.replace('/','\');
private testRootPlaceholder:='<#>';
private pathDependentScripts:=['diff','grep',EXAMPLES_LOG_NAME];

//@SuppressUnusedWarning
memoized runTimesAsFlatList->runTimes.each(e0,e0[1].each(e1,e1[1].each(e2,[e0[0],e1[0],e2[1]]),|),|);

private flavourDependentScripts:=
  ['accumulatorFactory',
   'continuedFractions',
   'dice7fromDice5',
   'cauchy',
   'jaro',
   'numInt',
   'opTest',
   'numDiff',
   'montyHall',
   'rk4',
   'root',
   'shannonEntropy',
   'thieleInterpolation',
   'vanDerCorput',
   'travellingSalesmanProblem',
   'wordCount',
   EXAMPLES_LOG_NAME].union(plotters.map(::extractFileNameOnly));
private isFlavourDependent(scriptName)->scriptName in flavourDependentScripts;

//@SuppressUnusedWarning
private plausibilizeExpectationsOnStartup:=
  expectations.each(entry,
    begin
      local script:=entry[0];
      local expect:=entry[1];
      isFlavourDependent(script)
      ? expect.isMap
        ? begin
            local changed:=false;
            expect:=expect.each(e,e[0] in BUILDS.getInner(1) ? e : begin changed:=true; void; end).toMap;
            changed
            ? expectations[script]:=expect
            : void;
          end
        : expectations[script]:=void
      : expect.isMap
        ? begin
            expect:=expect.each(e,e[1],head);
            expectations[script]:=expect;
          end
        : void;
    end);

private TEST_FAILURE_LOG:=myPath.extractFileDirectory&'/testFailures.log';
private myFlavour    :=mnhInfo['flavour'];
private myCodeVersion:=mnhInfo['codeVersion'];

private mutable timesOfThisRun:=[];

logSmokeTestRunTime(script:String,runTime:Numeric,doLog:Boolean)->begin
  doLog
  ? begin
      runTimes[script          ].isVoid ? runTimes[script          ]:=[].toMap : void;
      runTimes[script,myFlavour].isVoid ? runTimes[script,myFlavour]:=[]       : void;
      runTimes[script,myFlavour]|=[[myCodeVersion,runTime]];
    end
  : void;
  timesOfThisRun|=[[script,runTime]];
  true;
end;

//@SuppressUnusedWarning
isTestAlreadyPassed(script)->isTestAlreadyPassed(script,myFlavour,myCodeVersion);
private isTestAlreadyPassed(script,flavour,codeVersion)->codeVersion in (runTimes[script,flavour] orElse []).getInner(0);

private mutable failedTests:=[];
//@SuppressUnusedWarning
getFailedTests->failedTests;

synchronized checkExpectation(script:String,testRunOutput:StringList,runTime:Numeric,doLog:Boolean)->begin
  local resultOk:=checkExpectation(script,testRunOutput);
  resultOk
  ? logSmokeTestRunTime(script,runTime,doLog)
  : void;
  resultOk;
end;

//@SuppressUnusedWarning
private checkExpectation(script:String,testRunOutput:StringList)->begin
  local outputToCheck:=script in pathDependentScripts
                       ? testRunOutput.replace(testRootLinux  ,testRootPlaceholder)
                                      .replace(testRootWindows,testRootPlaceholder)
                       : testRunOutput;

  local expectation:=expectations[script,isFlavourDependent(script) ? myFlavour : void];
  expectation.isVoid
  ? isFlavourDependent(script)
    ? begin
        expectations[script].isVoid
        ? expectations[script]:=[].toMap
        : void;
        expectations[script,myFlavour]:=outputToCheck;
        print('Logged new test run expectation for ',script,'/',myFlavour);
        true;
      end
    : begin
        expectations[script]:=outputToCheck;
        print('Logged new test run expectation for ',script);
        true;
      end
  : expectation==outputToCheck
    ? true
    : begin
        TEST_FAILURE_LOG.appendFileLines(unifiedDiff('expected for '&script&'/'&myFlavour,'output',expectation,outputToCheck,2)|repeat('/',100));
        failedTests|=script;
        false;
      end;
end;

private average(X)->X.flatten.agg(+)/X.size;

private memoized averageRunTimes->runTimes.each(caseEntry,begin
  local case:=caseEntry[0];
  //Create time groups by flavour
  local times:=caseEntry[1]
               .each(flavEntry,flavEntry[1].getInner(1).each(t,[flavEntry[0],t]),|)
               .group(0,{[$x[0],$x[1]|$y[1]]}).toMap;
  //Add time groups by optimization group (optimized/debug)
  times.map({[$x[0].copy(1,1),$x[1]]})
       .group(0,{[$x[0],$x[1]|$y[1]]})
       .each(G,times[G[0]]:=G[1]);
  //Average Times
  times.each(t,times[t[0]]:=t[1].average);
  [case,times];
end).toMap;

//@SuppressUnusedWarning
showTestTimeInfo->timesOfThisRun.size=0 ? void : begin
  local thisRunTotalTime:=timesOfThisRun.getInner(1).agg(+);
  local myFlavourGroup:=copy(myFlavour,1,1);
  local timesByFlavour     :=
    averageRunTimes
    .getAll(timesOfThisRun.getInner(0))
    .map({[$x[myFlavour],$x[myFlavourGroup]]})
    .agg(+);
  print('Test time : ',thisRunTotalTime);
  printf('  compared to average (flavour): %6.2f%%',thisRunTotalTime/timesByFlavour[0]*100);
  printf('  compared to average (group  ): %6.2f%%',thisRunTotalTime/timesByFlavour[1]*100);
end;

private expectationNamesForFlavour(flavour)->EXAMPLES_LOG_NAME|
  testsToExecuteForFlavour(flavour)
    .filter({not(isSmokeTest($case)) and
             not(skipFile($case,copy(flavour,0,1)=='F'))})
    .extractFileNameOnly;

//@SuppressUnusedWarning
allTestsPassed(flavour:String,codeHash:String)->
  expectationNamesForFlavour(flavour).each(t,t.isTestAlreadyPassed(flavour,codeHash),AND);

//@SuppressUnusedWarning
timeForFullTest(flavour:String,codeHash:String)->begin
  local groupedTimes:=runTimes.getAll(expectationNamesForFlavour(flavour))
                              .map({($x[flavour] orElse []).filter({$z[0]==codeHash}).getInner(1)});
  groupedTimes.each(t,t.size>=1,AND)
  ? groupedTimes.each(t,t.agg(+)/t.size,+)
  : void;
end;

private allScripts->expectations.getInner(0);
private allFlavours->BUILDS.filter({not(buildBlindly($B))}).getInner(1);

matching(L:StringCollection,pattern)->
  pattern.matches('\*|\|')
  ? begin
      local reg:=pattern.replace('*','.*');
      L.filter({$s.matches(reg)});
    end
  : L.filter({$s=pattern});

//*Remove/reset expectation for the given script and flavour
main('remove',Script,Flavour)->
  allScripts.matching(Script).each(script,
    allFlavours.matching(Flavour).each(flavour,
      isVoid(expectations[script])
      ? print('No expectation logged for ',script)
      : isFlavourDependent(script)
        ? begin
            isVoid(expectations[script,flavour])
            ? print('No expectation logged for ',script,'/',flavour)
            : expectations[script,flavour]:=print('Expectation for ',script,'/',flavour,' reset');
          end
        : expectations[script]:=print('Expectation for ',script,' reset')));

//*Remove/reset expectation for the given script (and all flavours)
main('remove',Script)->
  allScripts.matching(Script).each(script,
    isVoid(expectations[script])
    ? print('No expectation logged for ',script)
    : expectations[script]:=print('Expectation for ',script,' reset'));

//*List information on all test expectations
main->begin
  local allFlavours:=BUILDS.filter({not(buildBlindly($B))}).getInner(1);
  local testsByFlavour:=allFlavours.each(flavour,
    [flavour,
     flavour.expectationNamesForFlavour
            .toSet])
    .toMap;
  local allTests:=testsByFlavour.getInner(1).flatten.unique;
  local flavoursByTest:=testsByFlavour.each(entry,entry[1].each(case,[case,entry[0]]).toMap,aggregator({mergeMaps($x,$y,::|)}));

  allTests
    .each(case,begin
       isFlavourDependent(case)
       ? [case,
          'flavour dependent',
          expectations[case].isVoid
          ? 'expectation missing'
          : begin
              local missingFor:=flavoursByTest[case].minus(expectations[case].getInner(0));
              missingFor.size=0
              ? 'complete'
              : 'missing for: '&join(missingFor,', ');
            end]
       : [case,
          '',
          expectations[case].isVoid
          ? 'expectation missing'
          : 'complete'];
     end).sort(2).formatTable(['Test','by flavour?','Completeness']).join("\n").print;
end;

USE statistics;
//*Limit to 50 timings per case and flavour
//*Drop all values outside of 3 sigma environment
main('cleanup')->begin
  local droppedExtremes:=0;
  local droppedTotal:=0;
  runTimes.each(caseEntry,begin
    local case:=caseEntry[0];
    caseEntry[1].each(flavEntry,begin
      local flavour:=flavEntry[0];
      local times:=flavEntry[1];
      local threshold:=times.getInner(1).mean+
                     3*times.getInner(1).standardVariation;
      droppedTotal+=times.size;
      droppedExtremes+=trueCount(times.getInner(1)>threshold);
      times:=times[times.getInner(1)<=threshold].head(50);
      droppedTotal-=times.size;
      runTimes[case,flavour]:=times;
    end);
  end);
  print('Dropped ',droppedExtremes,' extreme timing values');
  print('Dropped ',droppedTotal   ,' values in total');
end;
