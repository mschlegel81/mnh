startOfEvaluation:=time;

private memoized canPlot(exe)->exe.exec(['-cmd','-echo','-time','-el5',"print('plot.plot' in listBuiltin)"],false).head=='true';
canPlot:='plot.plot' in listBuiltin;

private mnhRoot:=myPath.split(['\','/']).leading(2).{[$x.join('/'),$x.join('\')]};

private codeHash(exe)->exec(exe,['-codeHash'],false).head;
private codeHash:=executor.codeHash;

private memoized isDebug(exe)->exe.exec(['-version'],false).head.matches('debug');

private memoized flavourString(exe)->exe.exec(['-version'],false).head.split(' ').trailing(2).reverseList.join('_')&(canPlot(exe) ? '' : '_light')&(isDebug(exe) ? '_debug' : '');
flavourString:=executor.flavourString;

private memoized logName(exe)->myPath.replace('.mnh','.'&flavourString(exe)&'.txt');
private logName:=executor.logName;

testAlreadyPassed(exe)->logName(exe).fileExists AND ((codeHash(exe)&' '&'o.k.') in logName(exe).fileLines);
testAlreadyPassed:=executor.testAlreadyPassed;

timeForTest(exe)->(logName(exe).fileExists ? begin
  local lines:=logName(exe).fileLines;
  local timeIdx:=indexOf(lines=(codeHash(exe)&' '&'o.k.'));
  timeIdx==[]
  ? void
  : lines[timeIdx[0]+1].replace('Total time: ','');
end : void);

linuxTestsPassed->
  [[myPath.replace('.mnh','.Linux_x86_64.txt')      ,'FOLinux'],
   [myPath.replace('.mnh','.Linux_x86_64_light.txt'),'LOLinux']]
  .each(log,log[0].fileExists AND (((log[1])&':'&(codeHash.split(':')[1]) &' '&'o.k.') in log[0].fileLines),AND);

validateCollectedOutput->begin
  local printOut:=collectedOutput.get(collectedOutput.getInner(0)='printline').getInner(2).split("\n").flatten.pEach(line,line.replace(mnhRoot,''));
  local expectedResultName:=myPath.replace('.mnh','.'&flavourString&'.expected');
  local lastResultName    :=myPath.replace('.mnh','.'&flavourString&'.last');
  local stateMessage:='';
  clearPrint;
  collectOutput;
  print("Test finished at ",formatTime('c',systime));
  fileExists(expectedResultName)
  ? begin
      expectedResultName.fileLines==printOut
      ? stateMessage:='o.k.'
      : begin
          lastResultName.writeFileLines(printOut);
          stateMessage:='NOT OK';
          print("Result is not okay!\nPlease compare "&lastResultName&"\n           and "&expectedResultName);
        end;
    end
  : begin
      print('No expected result found. Writing ',expectedResultName);
      stateMessage:='o.k.';
      expectedResultName.writeFileLines(printOut);
    end;
  printf('%s',exec(executor,['-version'],false)[0]| (codeHash&' '&stateMessage) |("Total time: "&(time-startOfEvaluation)));
  print('');
  printOut:=collectedOutput.get(collectedOutput.getInner(0)='printline').getInner(2).split("\n").flatten;
  logName.writeFileLines(printOut | head(logName.fileLines,80));
end;

testHistory->regex.replace(myPath,'\.mnh$','.*.txt').files.each(file,begin
  local lines:=file.fileLines;
  indexOf(lines.matches('^Total time: ')).each(i,
      lines[i-1].split(' ')[0].split(':').reverseList|
     [lines[i].replace('Total time: ',''),
     (lines[i-1].split(' ')[1] orElse '')=='o.k.']);
end,|);

