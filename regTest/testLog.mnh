USE mnhInfo;

datastore log;

startOfEvaluation:=time;

private mnhRoot:=myPath.split(['\','/']).leading(2).{[$x.join('/'),$x.join('\')]};

testAlreadyPassed(exe)->[flavour(exe),codeVersion(exe)] in (log orElse []).getInner([0,1]);
testAlreadyPassed:=executor.testAlreadyPassed;
linuxTestsPassed->['FOLinux',executor.codeVersion] in log.getInner([0,1])
              AND ['LOLinux',executor.codeVersion] in log.getInner([0,1]);

timeForTest(exe)->log[log.getInner(0)=flavour(exe) and log.getInner(1)=codeVersion(exe)][0,2];

validateCollectedOutput->begin
  local printOut:=collectedOutput.get(collectedOutput.getInner(0)='printline').getInner(2).split("\n").flatten.pEach(line,line.replace(mnhRoot,''));
  local expectedResultName:=myPath.changeFileExt('.'&flavour&'.expected');
  local lastResultName    :=myPath.changeFileExt('.'&flavour&'.last');
  local stateMessage:='';
  clearPrint;
  print("Test finished at ",formatTime('c',systime));
  fileExists(expectedResultName)
  ? begin
      expectedResultName.fileLines==printOut
      ? stateMessage:='o.k.'
      : begin
          lastResultName.writeFileLines(printOut);
          stateMessage:='NOT OK';
          print("Result is not okay!\nPlease compare "&lastResultName&"\n           and "&expectedResultName);
        end;
    end
  : begin
      print('No expected result found. Writing ',expectedResultName);
      stateMessage:='o.k.';
      expectedResultName.writeFileLines(printOut);
    end;
  printf('%s',exec(executor,['-version'],false)[0]| (codeHash&' '&stateMessage) |("Total time: "&(time-startOfEvaluation)));
  print('');
  log|=[[flavour,executor.codeVersion,time-startOfEvaluation]];
end;

testHistory->begin
  local hashes:=log.getInner(1);
  hashes:=hashes.each(h,h in hashes.head(index) ? void : h);
  log.group(1).each(g,[g[0,1],g.getInner([0,2]).sort]);
end;
