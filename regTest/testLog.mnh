USE mnhInfo;

datastore log;

startOfEvaluation:=time;

private mnhRoot:=myPath.split(['\','/']).leading(2).{[$x.join('/'),$x.join('\')]};

testAlreadyPassed(exe)->[flavour(exe),codeVersion(exe)] in (log orElse []).getInner([0,1]);
testAlreadyPassed->executor.testAlreadyPassed;

timeForTest(exe:string)->timeForTest(flavour(exe),codeVersion(exe));
timeForTest(flavour,codeVersion)->log[log.getInner(0)=flavour and log.getInner(1)=codeVersion][0,2];

validateCollectedOutput(doLog:boolean)->begin
  local printOut:=collectedOutput.get(collectedOutput.getInner(0)='printline').getInner(2).split("\n").flatten.pEach(line,line.replace(mnhRoot,''));
  local expectedResultName:=myPath.changeFileExt('.'&flavour&'.expected');
  local lastResultName    :=myPath.changeFileExt('.'&flavour&'.last');
  local stateMessage:='';
  clearPrint;
  print("Test finished at ",formatTime('c',systime));
  fileExists(expectedResultName)
  ? begin
      expectedResultName.fileLines==printOut
      ? stateMessage:='o.k.'
      : begin
          lastResultName.writeFileLines(printOut);
          stateMessage:='NOT OK';
          fail("Result is not okay!\nPlease compare "&lastResultName
                                 &"\n           and "&expectedResultName);
        end;
    end
  : begin
      print('No expected result found. Writing ',expectedResultName);
      stateMessage:='o.k.';
      expectedResultName.writeFileLines(printOut);
    end;
  printf('%s',executor.codeVersion | (codeHash&' '&stateMessage) |("Total time: "&(time-startOfEvaluation)));
  print('');
  stateMessage='o.k.' AND doLog
  ? log|=[[flavour,executor.codeVersion,time-startOfEvaluation]]
  : void;
end;

testHistory->begin
  local hashes:=log.getInner(1);
  hashes:=hashes.each(h,h in hashes.head(index) ? void : h);
  log.group(1).each(g,[g[0,1],g.getInner([0,2]).sort]);
end;
