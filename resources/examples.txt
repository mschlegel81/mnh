#I readDatastore
#S readDatastore(scriptPath:String,ruleName:String);
#C Tries to read the specified datastore; returns void if the datastore does not exist#
#S readDatastore(datastorePath:String);
#C Tries to read the specified datastore - returns a map with keys "id" and "content"

#I halt
#S halt;
#C Quietly stops the evaluation. No further errors are raised
#S halt(exitCode:Int);
#C Convenience method to halt with a defined exit code

#I printDirect
#S printDirect(...);
#C Prints out the given string without pretty printing or line breaks

#I COMPARATOR_EQ
#S COMPARATOR_EQ(x,y);
#C Wrapper function for =

arity({3});
#S arity(e:Expression);
#C Returns the arity (i.e. the number of accepted parameters of expression e)

#I mnh.arity
arity({sin($x)/$x});

#I mnh.runScript
runScript(['name'=>'hello.mnh',
           'source'=>["main->print('Hello world');"],
           'side effects'=>['alter package state','output']].toMap)
.filter({$message.head=='printline'})
.map(::trailing);
#S runScript(config:Map);//executes the given script config
#I expected keys:
#I   'name' (String, mandatory)
#I   'source' (StringList)
#I   'parameters' (StringList)
#I   'side effects' (StringCollection, see function listSideEffects for possible values)
#I   'connection level' 0: isolated, 1: print, 2: print and warnings, 3: print, warnings and errors
#I   'deterministic' (Boolean, true to enforce determinism of PRGNs)

#I mnh.arity
arity({sin($x)/$y});

#I mnh.arity
//For variadic functions only the non-optional parameters are counted:
arity({printf('%s%s',$a,...)});

toExpression("$x-$x^2+$x^3");
#S toExpression(S);
#C Returns an expression parsed from string or list S

toExpression("");

parameterNames({3});
#S parameterNames(e:expression);
#C Returns the IDs of named parameters of e

#I mnh.parameterNames
parameterNames({sin($x)/$x});

#I groupToList
groupToList([1,2,3,4,5,6],[1,2,3,1,2,3],Nan,::*);
#S groupToList(values:List,indexes:IntList,defaultValue,aggregator:Expression(2));
#C Groups values by indexes to a list, using defaultValue where no value is given and aggregating using the aggregator
#S groupToList(values:List,indexes:IntList,defaultValue,aggregator:Expression(2),initialSize>=0);
#C As above but with a predefined initial result list size

#I mnh.parameterNames
//For variadic functions only the non-optional parameters are counted:
parameterNames({printf("%s%s", $a, ...)});

ord(3);
#S ord(x);
#C Returns the ordinal value of x

ord(true);

ord(false);

ord("A");

ord("abc");

ord(2.1);

softCast("A");
#S softCast(X);
#C Returns a simplified version of X, trying to parse integers, real values and booleans

softCast('"B"');

softCast(3);

softCast([1, "2", "true", "'TEXT'", "1.5", "2,6"]);

toString('a');
#S toString(X);
#C Casts X to string

toString(234);

toString([1, 2.6, "a", true, {$x}]);

#I abs
abs(-0.92);

abs(3);

#I abs
abs({1+$x});

#I arccos
#S arccos(n);
#C Returns the arccosine of numeric or expression parameter n
arccos(-0.92);

//Out of function domain
arccos(3);

#I arccos
arccos({1+$x});

#I arcsin
#S arcsin(n);
#C Returns the arcsine of numeric or expression parameter n
arcsin(-0.92);

//Out of function domain
arcsin(3);

#I arcsin
arcsin({1+$x});

#I tan
#S tan(n);
#C Returns the tangent of numeric or expression parameter n
tan(-0.92);

tan(3);

#I tan
tan({1+$x});

#I pi
#S pi;
#C Returns pi

#I math.tan
tan(pi/2);

#I arctan
#S arctan(n);
#C Returns the arctangent of numeric or expression parameter n
arctan(-0.92);

arctan({$x});

#I argMax
#S argMax(L);
#C Returns the index of the greatest element out of list L (or the first index if ambiguous)
argMax(sin([0..10]));

argMax([1, 3, 3, 0, 2]);

#I argMin
#S argMin(L);
#C Returns the index of the smallest element out of list L (or the first index if ambiguous)
argMin(sin([0..10]));

argMin([1, 3, 3, 0, 2]);

#I ceil
#S ceil(x);
#C Returns the smallest integer >=x
#S ceil(x,k);
#C Does the same but with k digits precision
ceil(20/3);

#I ceil
ceil([0..3]/3);

#I ceil
ceil([0..3]/3, 2);

#I floor
#S floor(x);
#C Returns the largest integer <=x
#S floor(x, k);
#C Does the same but with k digits precision
floor(20/3);

#I floor
floor([0..3]/3);

#I floor
floor([0..3]/3, 2);

#I round
#S round(x);
#C Returns the value of x, rounded to the nearest integer
#S round(x, k);
#C Returns the value of x rounded to k-digits precision
round(20/3);

//Numbers with ambiguous rounding result are rounded towards even numbers
round([0.5, 1.5, 2.5, 3.5]);

#I round
round([0..3]/3, 2);

isInfinite(Nan);

#I isInfinite
#S isInfinite(n);
#C Returns true if n is a number representing an infinite value
isInfinite(+Inf);

#I isInfinite
isInfinite(-Inf);

#I isInfinite
isInfinite([-3.4344, Nan, +Inf]);

isNan(Nan);

#I isNan
#S isNan(n);
#C Returns true if n is a number representing the value Not-A-Number
isNan(+Inf);

#I isNan
isNan(-Inf);

#I isNan
isNan([-3.4344, Nan, +Inf]);

#I cos
#S cos(n);
#C Returns the cosine of numeric or expression parameter n
cos(-0.92);

cos(3);

#I cos
cos({1+$x});

#I exp
#S exp(n);
#C Returns the exponential of numeric or expression parameter n
exp(-0.92);

exp(3);

#I exp
exp({1+$x});

#I ln
#S ln(n);
#C Returns the natural logarithm of numeric or expression parameter n
ln(-0.92);

#I ln
ln({1+$x});

#I sin
#S sin(n);
#C Returns the sine of numeric or expression parameter n
sin(3);

#I sin
sin({1+$x});

#I sqr
#S sqr(n);
#C Returns the square of numeric or expression parameter n
sqr(-0.92);

sqr(3);

#I sqr
sqr({1+$x});

#I sqrt
#S sqrt(n);
#C Returns the square root of numeric or expression parameter n
sqrt(-0.92);

sqrt(3);

#I sqrt
sqrt({1+$x});

#S isqrt(n);
#C Returns [floor(sqrt(n)),isSquare(n)]
isqrt(121);

isqrt(255);

#I sign
#S sign(n);
#C Returns the sign of numeric or expression parameter n
sign(-0.92);

sign(3);

#I sign
sign({1+$x});

max(["a".."z"]);

#I max
#S max(L);
#C Returns the greatest element out of list L
#S max(x, y, ...);
#C Returns the greatest element out of the given parameters
max([0..9]/2);

max(true, false);

min(["a".."z"]);

#I min
#S min(L);
#C Returns the smallest element out of list L
#S min(x, y, ...);
#C Returns the smallest element out of the given parameters
min([0..9]/2);

min(true, false);

copy("abcde", 1, 3);
#S copy(S,start,length):
#C Returns the substring of S starting at index start and having specified length

copy("abcde", 2);

escape("a");
#S escape(S:String);
#C Returns an escaped representation of S

escape("\t");

#I group
#S group(list, grouping);
#C Re-groups list to a map by grouping (which is a sub-index or a list)
#S group(list, grouping, aggregator:Expression(2));
#C Groups by grouping using aggregator on a per group basis
//Group a list of numbers by divisibility by 3
group([1..10],[1..10] mod 3=0);

fail;
#S fail;
#C Raises an exception without a message
#S fail(...);
#C Raises an exception with the given message

fail("Told you this wouldn't work!");

hash(1);
#S hash(x);
#C Returns the builtin hash for the given literal

hash([1..3]);

hash("a");

#I listBuiltin
listBuiltin.filter({$s.matches('^mnh\.')}).sort.trailing(10);
#S listBuiltin;
#C Returns a set of all builtin functions, only qualified IDs

#S abs(n);
#C Returns the absolute value of numeric or expression parameter n
abs(3);

#I abs
abs(-3);

#I abs
abs([-2..2]/2); 

chars('This is a test.');
#S chars(S);
#C Returns the characters in S as a list
#S chars;
#C Returns all possible single-byte characters in natural ordering

#I chars
chars.get(100);

clean('+21/232/2116-11',['0'..'9'],' ');
#S clean(s,whiteList:StringCollection,instead:String);
#C Replaces all characters in s which are not in whitelist by instead.
#S clean(s,whiteList:StringCollection,instead:String,joinPlaceholders:boolean);
#C As above but joining placeholders

join(['a','b','c']);
#S join(L:List);
#C Returns a string-concatenation of all elements in L
#S join(L:List,joiner:String);
#C Returns a string-concatenation of all elements, with joiner between.

join([1..5],' ');

length('Test öäü');
#S length(S:String);
#C Returns the number of characters in string S

byteLength('Test öäü');
#S byteLength(S:String);
#C Returns the number of bytes in string S

length(['Text','AbC']);

lower('Test');
#S lower(S:String);
#C Returns an lowercase representation of S

lower(['Text','AbC']);

upper('Test');
#S upper(S:String);
#C Returns an uppercase representation of S

upper(['Text','AbC']);

#I plot
t:=[0..1000]*2*pi/1000;
plot(t,sin(t));
plot.renderToFile('plotDemo1.png',600,300);
    
abs({$x});

chars('Test');

pos('o','Hello World');
#S pos(subString,searchInString);
#C Returns the index of the first occurence of subString in searchInString or Infinity if there is none

pos(',',['Hello','Test','1,2,3']);

pos(['a','b'],'cdb');

repeat('-',10);
#S repeat(s:String,k:Int);
#C Returns a string containing s repeated k times

//Simple test for correct bracketing:
replace('[[][]][]][][','[]','');
#S replace(source:String,lookFor,replaceBy);
#C Recursively replaces all occurences of lookFor in source by replaceBy
#C lookFor and replaceBy may be of type string or stringList

//Iteration will not take place if it is infinite:
replace('aba','b','bb');

replaceOne('[[][]][]][][','[]','');
#S replaceOne(source:String,lookFor,replaceBy);
#C Replaces the first occurences of lookFor in source by replaceBy
#C lookFor and replaceBy may be of type string or stringList

replaceOne('1:.-.; 2:.-.; 3:.-.','.',['a'..'e']);

split('1,2,3;4,5,6',',');
#S split(S:String, splitter:String);
#C Returns a list of strings obtained by splitting S at the specified splitters without the splitters
#S split(S:String, splitter:String, retainSplitters:boolean);

split('1,2,3;4,5,6',';');

split('1,2,3;4,5,6',[';',',']);

tokenSplit('f(x)->x+1; //Stupid, but just an example...','mnh');
#S tokenSplit(S:string);
#S tokenSplit(S:string,language:string);
#C Returns a list of strings from S for a given language
#C Languages: <code>MNH, Pascal, Java</code>

trim(" \tA B C\t ");
#S trim(S:String);
#C Returns string S without leading or trailing spaces

trimLeft(" \tA B C\t ");
#S trimLeft(S:String);
#C Returns string S without leading spaces

trimRight(" \tA B C\t ");
#S trimRight(S:String);
#C Returns string S without trailing spaces

unbrace('3');
#S unbrace(S:String);
#C Returns an unbraced representation of S

unbrace('(3)');

unbrace('(3]');

unbrace('"3"');

#I elementFrequency
#S elementFrequency(L);
#C Returns a map e=>count containing distinct elements e of L and their respective counts.
#C The result can be interpreted as a multiset.
chars('Testtext').elementFrequency;

#I elementFrequency
//elementFrequency can be used for aggregating
chars('Testtext').agg(elementFrequency);

#S flatten(L,...);
#C Returns all parameters as a flat list.
flatten([1,[2,[3,4],[5]],6]);

#S head(L);
#C Returns the first element of list L or [] if L is empty
head(['A'..'Z']);

#S head(L,k);
#C Returns the first min(k,size(L)) elements of L or [] if L is empty
head(['A'..'Z'],3);

#I head
['A'..'Z'].toSet.head(3);

#S tail(L);
#C Returns list L without the first element
tail(['A'..'Z']);

#S tail(L,k);
#C Returns L without the first k elements
tail(['A'..'Z'],3);

#I tail
rangeGenerator(1,10).tail(3);

#S leading(L);
#C Returns L without the last element or [] if L is empty
leading(['A'..'Z']);

#S leading(L,k);
#C Returns L without the last k elements or [] if L is empty
leading(['A'..'Z'],3);

#I leading
rangeGenerator(1,10).leading(3);

#S trailing(L);
#C Returns the last element of L
trailing(['A'..'Z']);

#S trailing(L,k);
#C Returns the last k elements of L
trailing(['A'..'Z'],3);

#I trailing
['A'..'Z'].toSet.trailing(3);

#I trailing
rangeGenerator(1,10).trailing(3);

#I minus
#S minus(A,B);
#C Returns the asymmetric set difference of A and B. All parameters must be collections.
//Odd squares
minus([1..10]²,2*[0..50])

#I chunkMap
rangeGenerator(1,20).chunkMap(5,(x)->format('%2s',x)).toList;

#I flatMap
[1,[2,3],[4,5,6]].flatMap((x)->x³).toList;

#I sort
#S sort(L);
#C Returns list L sorted ascending (using fallbacks for uncomparable types)
#S sort(L,innerIndex:Int);
#C Returns L sorted by given inner index
sort(intRandom(10,5));

#I sort
#S sort(L,leqExpression:Expression(2));
#C Returns L sorted using the custom binary expression, interpreted as "is lesser or equal"#
sort(['01','10','100','1','010'],(x,y)->softCast(x)<=softCast(y));

#I sort
#S sort(L,mapExpression:Expression(1));
#C Returns L sorted using the custom unary expression, behaves as L.get(L.map(mapExpression))#
sort(['01','10','100','1','010'],::length);

#I sortPerm
#S sortPerm(L);
#C Returns indexes I so that L[I]==sort(L)
//A random permutation:
sortPerm(random(10));

sortPerm(['a'..'c'..'a']);

#I intersect
#S intersect(A,...);
#C Returns an intersection of all given parameters. All parameters must be collections.
intersect([0..1000]^2,[0..1000]^3);

#I union
#S union(A, ...);
#C Returns a union of all given parameters. All parameters must be collections.
union(1/[1..5],2/[2..6]);

deleteFile('plotDemo1.png');

get(['a'..'f'],3);
#H See <a href="types.html#lists">List types</a> for further information

get(['a'..'f'],[3,1,2]);

#I get
get([0..4],[2..6] mod 3 = 0);
#S get(L,accessor);
#C Returns elements of list, set or map L by accessor
#C This is the functional way of writing L[accessor]


get([['A',1],['B',2],['C',0]],'B');

#S getInner(L:List, k:Int);
#C Returns the k-th elements of each entry in nested list L
#H See <a href="types.html#lists">List types</a> for further information
getInner([[1,2,3],[4,5,6],[7,8,9]],1);

getInner([[1,2,3],[4,5,6],[7,8,9]],[1,0]);

getInner([[1,2,3],[4,5,6],[7,8,9]],[true,false,true]);

#I indexOf
#S indexOf(B:BooleanList);
#C Returns the indexes for which B is true.
indexOf([1..6]^2 mod 3=0);

#S reverseList(L:List);
#C Returns L reversed
reverseList([1..5]);

#S size(L);
#C Returns the number of elements in set, list or map L
size([0.5,0.1,0.2]);

toMap([['A',1], ['B',2], ['C',0], ['B',4]]);
#S toMap(X:Collection);
#C Casts X to map or throws an error if not possible

#I trueCount
#S trueCount(B:BooleanList);
#C Returns the number of true values in B
trueCount(10<[0..10]^2<50);

unique([3,1,2,1,4,1,5]);
#S unique(L:List);
#C Returns list L without duplicates.

#I compress
#S compress(S:String);
#C Returns a compressed version of S
#S compress(S:String,k:Int);
#C As above but with a specified algorithm:
#C   1: deflate
#C   2: huffman with relaxed default model
#C   3: huffman with strict default model
#C   4: huffman with numbers model
#C   5: huffman with Wikipedia.de model
#C   6: huffman with MNH code model
#C   255: don't compress
#C   other: try out algorithms and return the shortest representation
#C The first character of the result indicates the algorithm used

#I decompress
#S decompress(S:String);
#C Returns an uncompressed version of S

//compress/decompress uses a hybridization of different compression algorithms
//It is possible that the compressed string equals the original string.
compress('Test');
compress('Test').decompress;

compress('Testtext');
compress('Testtext').decompress;

relativeFileName('~/folder/','~/other/example.txt');
#S relativeFileName(reference,file);
#C Returns the path of file relative to reference#relativeFileName(file);
#C Returns the path of file relative to the current working directory

primes(20);
#S primes(pMax:Int);
#C Returns prime numbers up to pMax


subSets([1,2,1]);
#S subSets(S);
#C Returns all distinct subsets of S
#S subSets(S, k:Int);
#C Returns all distinct subsets of S having k elements

diff('encode','decode');
#S diff(A,B);
#C Shows diff statistics and edit script for strings A and B or string lists A and B
#S diff(A,B,convertModifies:boolean);
#C As above but optionally convert modifies to adds and deletes

diffStats('encode','decode');
#S diffStats(A,B);
#C Shows diff statistics for strings A and B or string lists A and B

//String: %s, Decimal format: %d  (parameters are optional)
format('%s is a string, %3.3d is a number','X',7);

//Floating point format: %f
format('%6.3f',3);

//Scientific format: %e
format('%6.3e',3);

//General number format: %g
format('%6.3g',3);

//Hexadecimal: %x (parameters are optional)
format('%6.6x',1234);
#S format(formatString:String,...);
#C Returns a formatted version of the given 0..n parameters
#H See <a href="formatStrings.html">Format Strings</a>

formatTime('mm.dd.yyyy',43210);
formatTime(12424.245);
#S formatTime(formatString:String, t);
#C Returns time t (numeric list or scalar) formatted using format string
#H <a href="formatStrings.html">Format Strings</a>

isAscii('xyz');

#I isAscii
isAscii('xyz'&chars[180]);

isAscii('Läuft');
#S isAscii(S:String);
#C Returns true if S is ASCII encoded and false otherwise

isUtf8('xyz');
#S isUtf8(S:String);
#C Returns true if S is UTF8 encoded and false otherwise

#I isUtf8
isUtf8('xyz'&chars[180]);

isUtf8('Schräg');

parseTime('yyyy-mm-dd hh:nn','2000-01-01 03:43');
#S parseTime(formatString:String,input:String);
#C Parses time from a given date format and input
#H See <a href="formatStrings.html">Format Strings</a>

reverseString('Test');
#S reverseString(S:String);
#C reverseString(S:StringList);
#C Returns returns S reversed (character wise not bytewise)

#I regex.matches
#S matches(searchString,regex);
#C returns true if string/-list searchString matches string/-list regex
#C If lists are given they must have equal sizes.
regex.matches('This is a test','[T|t]est');

#I regex.matchComposite
#S matchComposite(searchString,regex);
#C returns a (list of) triplets: [match,position,length] for string/-list regex and searchString
#C If lists are given they must have equal sizes.
regex.matchComposite('This is a test','[T|t]est');

#I regex.replace
#S replace(searchString,regex,replaceString);
#C replaces all matching occurences of string/-list regex in string/-list searchString by string/-list replaceString
#C If lists are given they must have equal sizes.
regex.replace('A Test is a test','[T|t]est','rose');

#I regex.split
#S split(searchString,regex);
#C splits the string/-list searchString using string/-list regex
#C If lists are given they must have equal sizes.
regex.split('A Test is a test','[e| ]');

toBoolean(0);
#S toBoolean(X);
#C Casts X to boolean or throws an error if not possible

toBoolean(1.0);

toBoolean('true');

toBoolean(3);

toInt('32');
#S toInt(X);
#C Casts X to int or throws an error if not possible

toInt(3.0);

toInt(3.1);

toInt(false);

toReal('3.212');
#S toReal(X);
#C Casts X to real or throws an error if not possible

toReal(true);

toReal(3);

getOptions;

executor;
#S executor;
#C returns the path to the currently executing instance of MNH

#I clearPrint
#S clearPrint;
#C Clears the output and returns void.

//Print with line breaks but without pretty printing
print("1\n2.0\n03.45");
#S print(...);
#C Prints out the given parameters and returns void
#C if tabs and line breaks are part of the output, a default pretty-printing is used

//Tab triggers pretty printing - numbers are aligned at decimal dot or comma
print("1\n2.0\n03,45\t");

//Non-numbers are left aligned
print("1\tone\t|\n2.0\ttwo\t|\n03.45\tthree\t|");

//Use \v instead of \t for a tab of zero width
print("1\vone\v|\n2.0\vtwo\v|\n03.45\vthree\v|");

//Simple format: the number of placeholders must match the number of arguments
printf("%x is %d in hexadecimal form",123,123);

//You can adress placeholders by their zero based index
printf("%{$0}x is %{$0}d in hexadecimal form",123);

//Placeholders can be complex expressions
printf("sin(%{$0}s)=%{sin($0)}4.4g",1);
#S printf(formatString:String,...);
#C Prints a formatted version of the given 0..n parameters and returns void
#H See <a href="formatStrings.html">Format Strings</a>

permutations([1,1,2]);
#S permutations(L:List);
#C Returns a list of all permutations of S

permutations([1..3]);

#I serialize
#S serialize(x);
#C Returns a string representing x.
#S serialize(x,deflate:Boolean,reuse:Boolean);
#C Custom serialization.

#I deserialize
#S deserialize(s:string);
#C Returns the literal represented by s which was created using serialize(x)

#I fileLines
#S fileLines(filename:String);
#C Returns the contents of the specified file as a list of strings
#C Information on the line breaks is lost

#I writeFile
#S writeFile(filename:String, content:String);
#C Writes the specified content to the specified file and returns true

#I writeFileLines
#S writeFileLines(filename:String, content:StringList);
#C Writes the specified content to the specified file and returns true. If the file exists, the routine uses the previously used line breaks.
#S writeFileLines(filename:String, content:StringList, lineEnding:String);
#C As above with specified line ending

#I appendFileLines
#S appendFileLines(filename:String, content:StringList);
#C Appends the specified content to the specified file and returns true. If the file exists, the routine uses the previously used line breaks.
#S appendFileLines(filename:String, content:StringList, lineEnding:String);
#C As above with specified line ending (will be used only if a new file is created)

#I serialize deserialize
//Test serialization
input:=[[1..10],random,'test',random(9)];
serialized:=input.serialize;
print(input.toString.byteLength,' > ',serialized.byteLength);
input==serialized.deserialize;

factorize(18447422338071909869);
#S factorize(i:Int);
#C Returns a list of all prime factors of i


formatTabs("\v-2\n3\t4.3");
#S formatTabs(S:String);
#C Applies tab formatting as on print

typeOf(3);
#S typeOf(x); 
#C Returns a description of x''s type

typeOf([1..5,7.5]);

#I typeOf
typeOf({$x^2+$y});

#S transpose(L,filler);
#C Returns list L transposed. If sub lists of L have different lengths, filler is used.
#S transpose(L);
#C Returns list L transposed. If sub lists of L have different lengths, it fails.
x:=transpose([1,[1,2,3],[1,2]],0);
x;
x.transpose(0);

resetRandom(12157);
#S resetRandom(seed:Int);
#C Resets internal PRNG with the given seed

//Reset random with default seed 0
resetRandom;

intRandom(7);
#S intRandom(k>1);
#C Returns an integer random value in range [0,k-1]
#S intRandom(k>1,n>0);
#C Returns a list of n integer random values in range [0,k-1]

intRandom(7,10);

random;
#S random;
#C Returns a random value in range [0,1]
#S random(n);
#C Returns a list of n random values in range [0,1]

random(3);

log('This should be logged...');
#S log(...);
#C Logs a message and returns void

note('Note that this is a note');
#S note(...);
#C Raises a note of out the given parameters and returns void

warn('Warning: I intend to say something important here');
#S warn(...);
#C Raises a warning of out the given parameters and returns void

isScalar(1);
#S isScalar(x); 
#C Returns true if x is a scalar

isBoolean(false);
#S isBoolean(x); 
#C Returns true if x is a boolean

isBoolean(1);

isInt(false);

isInt(1);
#S isInt(x); 
#C Returns true if x is a int

isInt(1.0);

isReal(false);

isReal(1);

isReal(1.0);
#S isReal(x); 
#C Returns true if x is a real


isNumeric(false);
#S isNumeric(x); 
#C Returns true if x is a numeric

isNumeric(1);

isNumeric(1.0);

isList([]);
#S isList(x); 
#C Returns true if x is a list. Specify an additional int parameter to additionally check the size.

isList([],0);

isList([],1);

isList(['x'],1);

isString('Test');
#S isString(x); 
#C Returns true if x is a string

isString(true);

#I isExpression
#S isExpression(x); 
#C Returns true if x is a expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isExpression(::sin);

#I isExpression
isExpression(::sin,1);

#I isExpression
isExpression(::sin,2);

digits(123);
#S digits(i>=0);
#C Returns the digits of i (base 10)
#S digits(i>=0, base>1);
#C Returns the digits of i for a custom base

//Digits to base 3
digits(123,3);

arctan2(1,1);
#S arctan2(x, y);
#C Calculates arctan(x/y) and returns an angle in the correct quadrant

charSet('abcba');
#S charSet(S);
#C Returns the characters in S as a set (ordered list without duplicates)

#I bytes
#S bytes(S);
#C Returns the bytes in S as a list of strings
bytes('ö').ord;

base64encode('Test');
#S base64encode(S:String);
#C Converts a string to a base64 encoded string.

base64decode('VGVzdA==');
#S base64decode(S:String);
#C Converts a base64 encoded string to a string.

base92encode('bla bla bla '); //Encode 4 chars to 5 chars
#S base92encode(S:String);
#C Converts a string to a base92 encoded string.

base92decode('PgsC.?d@t^' );
#S base92decode(S:String);
#C Converts a base92 encoded string to a string.

listSideEffects;
#S listSideEffects;
#C Returns a list of all side effects, e.g. as parameters for interpret

changeFileExt('file.extension','.newExtension');
#S changeFileExt(filename,newExtension);
#C Returns the path of file with the new extension

changeFileExt('file.2.extension','.newExtension');

httpError;
#S httpError;
#C Returns http-representation of error 404.
#S httpError(code:Int);
#C Returns http-representation of given error code.

#I startHttpServer
#S startHttpServer(ipAndPort:String, requestToResponseFunc:Expression(1), timeoutInSeconds:Numeric);
#C Starts a new microserver-instance and returns the cleaned up ip and port.
#C The server is shut down automatically if no requests were recieved within timeoutInSeconds.

isBooleanList([true,false]);
#S isBooleanList(x); 
#C Returns true if x is a booleanList. Specify an additional int parameter to additionally check the size.

isBooleanList(true);

isIntList([1..3]);
#S isIntList(x); 
#C Returns true if x is a intList. Specify an additional int parameter to additionally check the size.

isIntList([1, 2.0]);

isRealList([1,2,3]);
#S isRealList(x); 
#C Returns true if x is a realList. Specify an additional int parameter to additionally check the size.
    
isRealList([1.0,2.0,3.0,Nan]);

isStringList(['a'..'z']);
#S isStringList(x); 
#C Returns true if x is a stringList. Specify an additional int parameter to additionally check the size.

isNumericList([1,2,3]);
#S isNumericList(x); 
#C Returns true if x is a numericList. Specify an additional int parameter to additionally check the size.

isNumericList([1.0,2,3,Inf]);

isVoid();
#S isVoid(x); 
#C Returns true if x is void (or no arguments were given)

isVoid(void);

isVoid(3);

escapePascal('Test');
#S escapePascal(S:String);
#C Returns an escaped representation of S for use in Pascal source code

escapeJava('Test');
#S escapeJava(S:String);
#C Returns an escaped representation of S for use in Java source code

extractFileNameOnly('/home/user/file.ext');
#S extractFileNameOnly(F);
#C Returns the expanded file names (without path and extension) of file(s) given by string or stringList F

extractFileDirectory('/home/user/file.ext');

extractFileName('/home/user/file.ext');
#S extractFileName(F);
#C Returns the expanded file names (without path) of file(s) given by string or stringList F

extractFileExt('/home/user/file.ext');
#S extractFileExt(F);
#C Returns the extension(s) of file(s) given by string or stringList F

extractPath('/index.html?x=0&y=3%2Ax');
#S extractPath(request:String);
#C Returns the path part of an http request as a string

extractParameters('/index.html?x=0&y=3%2Ax');
#S extractParameters(request:String);
#C Returns the parameters of an http request as a keyValueList

extractRawParameters('/index.html?x=0&y=3%2Ax');
#S extractRawParameters(request:String);
#C Returns the parameter part of an http request as a string

#I encodeRequest
encodeRequest('127.0.0.1:3126','rest',[['user','anonymous'],['request','3*&7']].toMap);
#S encodeRequest(address:String,path:String,parameters:String);
#S encodeRequest(address:String,path:String,parameters:keyValueList);
#C Returns an http request from the given components

#I httpGet
#S httpGet(URL:String);
#S httpGet(URL:String,body:String,header:Map);
#C Retrieves the contents of the given URL and returns them as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpPut
#S httpPut(URL:String);
#S httpPut(URL:String,body:String,header:Map);
#C Performs an http-PUT on the given URL and returns the response as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpPost
#S httpPost(URL:String);
#S httpPost(URL:String,body:String,header:Map);
#C Performs an http-POST on the given URL and returns the response as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpDelete
#S httpDelete(URL:String);
#S httpDelete(URL:String,body:String,header:Map);
#C Performs an http-DELETE on the given URL and returns the response ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I openUrl
#S openUrl(URL:String);
#C Opens the URL in the default browser

#I isServerRunning
#S isServerRunning(ipAndPort:String);
#C Returns true if the server is running - only servers in the current instance are checked!

#S cross(A,...);
#C Returns the cross product of the arguments (each of which must be a list, set or map)
cross(['1'..'3'],['A'..'C']);

[1,2,1].toSet;

[1.2,3.0].isRealCollection;
#S isRealCollection(x); 
#C Returns true if x is a realCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isRealCollection
[1.2,3.0].toSet.isRealCollection;

[1.2,3].isRealCollection;

[1.2,3.0].isRealCollection(2);

[1.2,3.0].isRealCollection(3);

[true].isBooleanCollection;
#S isBooleanCollection(x); 
#C Returns true if x is a booleanCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isBooleanCollection
[true,false,true].toSet.isBooleanCollection(2);

#I typecast.isBooleanSet
#S isBooleanSet(x); 
#C Returns true if x is a booleanSet. Specify an additional int parameter to additionally check the size.
[true,false,true].toSet.isBooleanSet;

[1,2,3].isIntCollection;
#S isIntCollection(x); 
#C Returns true if x is a intCollection. Specify an additional int parameter to additionally check the size.

[].isIntCollection;

[1.2,3].isNumericCollection;
#S isNumericCollection(x); 
#C Returns true if x is a numericCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isStringSet
#S isStringSet(x); 
#C Returns true if x is a stringSet. Specify an additional int parameter to additionally check the size.
['a','b'].toSet.isStringSet;

['a','b'].isStringCollection;
#S isStringCollection(x); 
#C Returns true if x is a stringCollection. Specify an additional int parameter to additionally check the size.

[1,2,3].isIntSet;
#S isIntSet(x); 
#C Returns true if x is a intSet. Specify an additional int parameter to additionally check the size.

#I typecast.isIntSet
[1,2,3].toSet.isIntSet;

#I typecast.isMap
#S isMap(x); 
#C Returns true if x is a map. Specify an additional int parameter to additionally check the size.
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap;

#I typecast.isMap
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap(2);

#I typecast.isMap
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap(3);

[1,'a',false].isSet;
#S isSet(x); 
#C Returns true if x is a set. Specify an additional int parameter to additionally check the size.

[1,'a',false].isCollection;
#S isCollection(x); 
#C Returns true if x is a collection. Specify an additional int parameter to additionally check the size.

#I strings.utf8ToAnsi
#S utf8ToAnsi(S:String);
#C Converts a UTF8 encoded string to an ANSI encoded string.
utf8ToAnsi('öµ').bytes.ord;

#I strings.ansiToUtf8
#S ansiToUtf8(S:String);
#C Converts an ANSI encoded string to a UTF8 encoded string.
chars[214].ansiToUtf8;

#I typecast.isRealSet
#S isRealSet(x); 
#C Returns true if x is a realSet. Specify an additional int parameter to additionally check the size.
[1.2,3.4].toSet.isRealSet;

toList(3);

#I typecast.toList
#S toList(X);
#C Casts X to list or wraps a scalar in a list
toList([2,3,6].toSet);

#I typecast.isNumericSet
#S isNumericSet(x); 
#C Returns true if x is a numericSet. Specify an additional int parameter to additionally check the size.
[1.2,3.4].toSet.isNumericSet;

#I lists.getAll
#S getAll(L,accessors);
#C Returns elements of list, set or map L by collection of accessors
#S getAll(L,accessors:List,fallback:List);
#C Returns elements of list, set or map L by collection of accessors.
#C If no such element is found, the respective fallback entry is used.
#C fallback must have the same size as accessors
//Mainly intended for bulk map access
[[1,'one'],[3,'three'],[5,'five']].toMap.getAll([1,5,6],['-','-','-']);

#I lists.getAll
HEX:=[0..15].map((i)->format('%x',i)=>i).toMap;
parseHex(s:String)->HEX.getAll(s.chars.upper).composeDigits(16);
parseHex('DeadBeef');

#I lists.getAll
[1,3,5].getAll([0,2])==[1,3,5].get([0,2]);

#I filter
[1..20].filter({$x mod 2<>0<>$x mod 3});

#I filter
//Filtering a generator/iterator results in a new generator/iterator
rangeGenerator(1,20).filter({$x mod 2<>0<>$x mod 3});

#I lists.map
['a'..'f'].map(::upper);

#I lists.pMap
['a'..'f'].pMap(::upper);

#I head
//head can be used to access the first elements of a generator/iterator
primeGenerator.head(10);

#I head
//head is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(head);

#I trailing
//trailing is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(trailing);

#I toSet
#S toSet(X);
#C Casts X to set or wraps a scalar in a set
//toSet is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(toSet);

#I max
//max is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(max);

#I min
//min is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(min);

#I OPERATOR_STRCONCAT
[-1,1,-1,1,-2,2].agg(&); //& is a valid aggregator marker

#I OPERATOR_MULT
[-1,1,-1,1,-2,2].agg(*); //multiplication can be used within agg

#I OPERATOR_PLUS
[-1,1,-1,1,-2,2].agg(+); //+ is a valid aggregator marker

#I permutationIterator
permutationIterator([3,1,2]).map(::print).toList;

#I lists.map
//The result of <generator>.map(<f>) is a new generator
rangeGenerator(1,100).map({$x^2});

#I lists.mergeMaps
#S mergeMaps(A:Map, B:Map, M:Expression(2));
#C Returns a map, obtained by merging maps A and B.
#C On duplicate keys, the values are merged using M.
//Merge maps; resolve conflicts via ::+
mergeMaps([['A',1], ['B',2]].toMap,
          [['A',7], ['C',3]].toMap,::+);
            
#I system.try
#S try(E:Expression(0));
#C Evaluates E and returns the result if successful or void if failed.
//Try without fallback (returns void)
try({deserialize('x')});
#S try(E:Expression, parameters:List);
#C Evaluates E with the given parameters - the parameter list length must match the arity of E
#S try(E:Expression(0), except(1):Expression);
#C Evaluates E and returns the result if successful. Otherwise <except> is executed with the errors as first paramter ($0).
#S try(E:Expression(0), except:Expression(0));
#C Evaluates E and returns the result if successful. Otherwise <except> is executed without paramters.
#S try(E:Expression(0),except);
#C Evaluates E and returns the result if successful. Otherwise <except> (any type except expression) is returned.
#I system.try
//Try with fallback: print error messages, if any
try({deserialize('x')},::print);

#I system.try
//Try with fallback: return default value
try({deserialize('x')},0);

#I system.try
//Try with fallback: convert error to warning
try({deserialize('x')},{warn($x.head.trailing)});

interpret("3+4");
#S interpret(E);
#C Interprets a String, StringList or Expression(0) E, forbidding any side effects
#S interpret(E, sideEffectWhitelist:StringCollection);
#C As above, but restricting the allowed side effects.

shiftRight(7,1);

#I shiftRight
#S shiftRight(x:Int,bitsToShift:Int);
#C Shifts integer x right by the given number of bits 
#C If bitsToShift<0 a shift-left is performed
shiftRight(5,-2);

#I typecast.toBuiltin
#S toBuiltin(X);
#C Returns X without custom type info
type FiniteRealList(L:List)->L.each(x,!x.isNan,!x.isInfinite,AND);
x:=[1,5,0.4,1/7].toFiniteRealList;
x;
x.typeOf;
x.toBuiltin;
x.toBuiltin.typeOf;

#I interpret
interpret({print("Hello world")},[]); //interpret with no side effects allowed

//Compose binary digits
composeDigits([1,0,1],2);
#S composeDigits(digits:IntList);
#C Returns a number constructed from digits (base 10)
#S composeDigits(digits:IntList, base:Int);
#C Returns a number constructed from digits with given base
#S composeDigits(digits:IntList, base:Int, shift:Int);
#C Returns a number constructed from digits with given base and shift

//Compose in decimal
composeDigits([1,0,2]);

//Compose in decimal, shifted by 2
composeDigits([1,0,2],10,2);

sandBoxExecute("f(x)->3*x+1; f(f(f(1)))",['alter package state']);
#S sandBoxExecute(source, sideEffectWhitelist:StringCollection);
#C Executes the source (String or StringList) and returns created messages.
#C Optionally you can specify allowed side effects.

#I system.async
#S async(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S async(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Asynchronous tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression returns void until the task is finished.
#C If you want to access local variables, use localAsync instead
begin
  local x:=async({print('start') orElse sleep(0.1) orElse 'end'});
  print('1: ',x().isVoid); //still running, x() should display void
  sleep(0.2);
  print('2: ',x());
end;

#I localAsync
#S localAsync(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S localAsync(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Asynchronous tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression returns void until the task is finished.
#C If you want a task that runs until the end of the script, use async instead

#I system.future
#S future(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S future(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Future tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression blocks until the task is finished.
begin
  local x:=future({print('start') orElse sleep(0.1) orElse 'end'});
  print('1: ',x().isVoid); //x() should block until finished
  sleep(0.2);
  print('2: ',x());
end;

#I peekFuture
#S peekFuture(F:Future);
#C peeks (nonblocking) the future F and returns true if its evaluation is finished, false otherwise

validateRegex('(3+.*');
#S validateRegex(regex:String);
#C Returns true iff regex is valid, false otherwise
#S validateRegex(regex:String,feedback:expression(1));
#C Returns void iff regex is valid, invokes feedback with error message otherwise

validateRegex('\(3+.*');

#I pFilter
[1..100].pFilter({$x mod 2=$x mod 3=$x mod 5});

pi;

#I isStatefulExpression
#S isStatefulExpression(x); 
#C Returns true if x is a stateful expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isStatefulExpression(::sin);

#I isStatefulExpression
isStatefulExpression(future(::sin,[3]));

#I isStatelessExpression
#S isStatelessExpression(x); 
#C Returns true if x is a stateless expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isStatelessExpression(::sin);

#I isStatelessExpression
isStatelessExpression(future(::sin,[3]));

#I isIteratable
isIteratable(future(::sin,[3]));

#I isIteratable
isIteratable(primeGenerator);

#I isIteratable
#S isIteratable(x); 
#C Returns true if x is an iteratable expression, a collection or a map.
isIteratable([1..10]);

#I isIteratableExpression
#S isIteratableExpression(x); 
#C Returns true if x is an iteratable expression.
isIteratableExpression(primeGenerator);

#I isIteratableExpression
isIteratableExpression([1..10]);

#I isIteratable
begin
  resetRandom;
  local gen:={begin local last:=0; save; last+=random; end};
  print('gen.isIteratable= ',gen.isIteratable,'; ',gen.head(3));
  gen:=gen.toIteratableExpression;
  print('gen.isIteratable= ',gen.isIteratable,'; ',gen.head(3));
end;

#I toGenerator
#S toGenerator(e:Expression(0));
#C Alias for toIteratableExpression

#I toIteratableExpression
#S toIteratableExpression(e:Expression(0));
#C Marks the expression as IteratableExpression if possible or throws an error
toIteratableExpression(::sqr);

#I toIteratableExpression
toIteratableExpression({begin local i:=1; save; i+=i-1; end});

euklideanNorm([1,2]);
#S euklideanNorm(v:NumericList);
#C returns the Euklidean norm of vector v

#I assert
assert(1=1.0);

#I assert
#S assert(condition:Boolean);
#C Raises an exception if condition is false
#S assert(condition:Boolean,...);
#C Raises an exception with the given message if condition is false
assert('bla'.isInt,'Invalid integer given');

md5('Test input. Could be anything really.');
#S md5(S:String);
#C Returns the MD5 digest as hexadecimal string for given input S

sha256('Test input. Could be anything really.');
#S sha256(S:String);
#C Returns SHA256 digest as hexadecimal string for given input S

hammingWeight(17213);
#S hammingWeight(x:Int);
#C Returns the hamming weight (i.e. number of true bits) in x

gcd(1231512,143543);
#S gcd(x:Int, ...);
#C Returns the greatest common divider of all arguments (only integers accepted)

#I powMod
#S powMod(x>=0, y>=0, z>=0);
#C Returns x^y mod z
//Example given by rosettacode.org
powMod(2988348162058574136915891421498819466320163312926952423791023078876139,2351399303373464486466122544523690094744975233415544072992656881240319,10^40);

#I randomGenerator
randomGenerator(123).head(10);

#I intRandomGenerator
intRandomGenerator(123,5).head(10);

#I isaacRandomGenerator
isaacRandomGenerator(123,5).head(10);

modularInverse(3,32);
#S modularInverse(x>0, m>0);
#C Returns the modular inverse of x with respect to modul m or NaN if no modular inverse exists

byteToChar(100);
#S byteToChar(b in [0..255]);
#C Returns the corresponding character as a string of one byte length

byteToChar([10,12,97,45]);

systemSpecificFilename('..\test/filename.txt');
#S systemSpecificFilename(name:String);
#C Returns the path with system specific directory separators#systemSpecificFilename(name:StringCollection);

#I setFileDate
#S setFileDate(filename:String, time:Numeric);
#C Sets the time of a given file and returns true on success

#I stringIterator
stringIterator(['a','b','c'],1,3).head(10);

#I vanDerCorputGenerator
vanDerCorputGenerator(2).head(10);

#I primeGenerator
primeGenerator.head(1000).trailing(5);

#I rangeGenerator
rangeGenerator(0,5).head(10);

#I rangeGenerator
rangeGenerator(100,-100).head(10);

divMod(10,7);
#S divMod(x:Int,y:Int);
#C Returns a pair [x div y, x mod y]

'abba'.hasPrefix('ab');
#S hasPrefix(s,prefix);
#C Returns true if s starts with prefix


isPrime(47531677974672740279381824573269878221106369761817);
#S isPrime(i:Int);
#C Returns true if i is a prime, false otherwise.
#C result is guaranteed to be correct for i<3.317E23

#I mnh.COMPARATOR_LISTEQ
3==3.0; //not equal, because types differ

#I mnh.COMPARATOR_LISTEQ
[1,2,3]==[3,1,3]; //== always returns a scalar boolean

#I COMPARATOR_EQ
3=3.0;

#I COMPARATOR_EQ
{$x}=3; //Used with expressions the result will be a new expression

#I COMPARATOR_EQ
[1,2,3]=[3,1,3]; //= compares element by element

#I COMPARATOR_LEQ
3<=3.0;

#I COMPARATOR_LEQ
[1,2,3]<=[3,1,3];

#I COMPARATOR_GEQ
3>=3.0;

#I COMPARATOR_GEQ
[1,2,3]>=[3,1,3];

#I COMPARATOR_LSS
3<3.0;

#I COMPARATOR_LSS
[1,2,3]<[3,1,3];

#I COMPARATOR_GRT
3>3.0;

#I COMPARATOR_GRT
[1,2,3]>[3,1,3];

#I COMPARATOR_NEQ
3!=3.0;

#I COMPARATOR_NEQ
[1,2,3]!=[3,1,3];

#I OPERATOR_LAZYAND
true AND false;

#I OPERATOR_LAZYAND
true AND 3; //Lazy boolean operators only examine the left hand side

#I OPERATOR_LAZYAND
false AND 3;  //Lazy boolean operators only examine the left hand side

#I OPERATOR_AND
true and false;

#I OPERATOR_AND
[true,false,true,false] and [true,true,false,false];

#I OPERATOR_AND
7 and 252; //and can be applied on integers

#I OPERATOR_LAZYOR
true OR false;

#I OPERATOR_LAZYOR
true OR 3; //Lazy boolean operators only examine the left hand side

#I OPERATOR_LAZYOR
false OR 3;  //Lazy boolean operators only examine the left hand side

#I OPERATOR_OR
true or false;

#I OPERATOR_OR
[true,false,true,false] or [true,true,false,false];

#I OPERATOR_OR
7 or 252; //or can be applied on integers

#I OPERATOR_XOR
true xor false;

#I OPERATOR_XOR
[true,false,true,false] xor [true,true,false,false];

#I OPERATOR_XOR
7 xor 252; //xor can be applied on integers

#I OPERATOR_UNARY_PLUS
+'a'; //the unary plus is a dummy and will be dropped

#I OPERATOR_NEGATE_ARITHMETIC
-3;

#I OPERATOR_NEGATE_ARITHMETIC
-[1,2.0,Inf,Nan];

#I OPERATOR_NEGATE_LOGICAL
!true;

#I OPERATOR_IN
3 in [1..5];

#I OPERATOR_IN
3.0 in [1..5]; //3.0 is not contained in [1..5], because the types of 3 (contained in list) and 3.0 differ

#I OPERATOR_NOT_IN
3 not in [1..5];

#I OPERATOR_NOT_IN
3.0 not in [1..5]; //3.0 is not contained in [1..5], because the types of 3 (contained in list) and 3.0 differ

#I OPERATOR_CONCAT
1|2;

#I OPERATOR_CONCAT
[1]|[2];

#I OPERATOR_CONCAT
[1]|2;

#I OPERATOR_CONCAT
[1]|[[2]];

#I OPERATOR_CONCATALT
[1]||2;

#I OPERATOR_CONCATALT
[1]||[2];

#I OPERATOR_DIVINT
10 div 3;

#I OPERATOR_DIVREAL
10 / 3;

#I OPERATOR_DIVREAL
10 / 5; //The result of a division of two integers may be an integer

#I OPERATOR_DIVREAL
10.0 / 5; //If either operand is a real number, the quotient will be a real number

#I OPERATOR_ORELSE
void orElse 42; //orElse returns the right-hand-side if the left-hand-side is void

#I OPERATOR_ORELSE
3 orElse fail; //The right-hand side will never be evaluated for a given (non-void) left-hand-side

#I OPERATOR_MINUS
3-pi;

#I OPERATOR_MOD
32459378562983 mod 2342832;

#I OPERATOR_MULT
2*3;

#I OPERATOR_MULT
2.0*3; //If either factor is a real number the product will be a real number

#I OPERATOR_PLUS
4+5;

#I OPERATOR_PLUS
'a'+'b'; //You can "add" strings

#I OPERATOR_POT
5^7;

#I OPERATOR_POT
-3.5^3; //Potentiation with a negative base is defined for integer exponents

#I OPERATOR_STRCONCAT
3 & 4; //You can concatenate operands of any type

#S isSubsetOf(A,B);
#C Returns true if A is a subset of (or equal to) B
isSubsetOf([1,2,3],[1,2,3]);

isSubsetOf(1,[1,2,3]);

isSubsetOf([1],[1,2,3]);

isSubsetOf([1,4],[1,2,3]);

#I vectorIfThenElse
#S vectorIfThenElse(condition:BooleanList, Then, Else);
#C Returns the elementwise "if-then-else" result
x:=1/[0..3];
vectorIfThenElse(x.isInfinite,0,x);

//==END REG TEST==

driveInfo;
#S driveInfo;
#C Returns info on the computer''''s drives/volumes (Windows only).

getCPULoadPercentage;
#S getCPULoadPercentage;
#C Returns the CPU load in percent (Windows only)

#I getTaskInfo
#C Returns info on running tasks (Windows only)
getTaskInfo.filter((task)->task['PID']=mnhInfo['PID']);

wrapTextInHttp('Test');
#S wrapTextInHttp(s:String);
#C Wraps s in an http-response (type: "text/html", code: 200)
#S wrapTextInHttp(s:String,type:String);
#C Wraps s in an http-response of given type with code 200.
#S wrapTextInHttp(s:String,code:Int,header:Map);
#C Wraps s in a custom http-response

#I sleep
#S sleep(seconds:Numeric);
#C Sleeps for the given number of seconds before returning void
t0:=scriptTime;
sleep(0.1);
scriptTime-t0;

#I sleepUntil
#S sleepUntil(wallClockSeconds:Numeric);
#C Sleeps until the wallclock reaches the given value

#I scriptTime
#S scriptTime;
#C Returns an internal time for time difference measurement.
t0:=scriptTime;
sleep(0.01);
scriptTime-t0;

#I time
#S time(E:expression);
#C Evaluates E (without parameters) and returns a nested List with evaluation details.
#S time(E:expression,par:list);
#C Evaluates E@par and returns a nested List with evaluation details.
time({sin(random(1000)).agg(+)});

#I systime
formatTime('hh:nn dd.mm.yyyy',systime);
#S systime;
#C Returns the current time as a real number

#I callMemoryCleaner
#S callMemoryCleaner;
#C Calls the memory cleaner

#I assertGuiStarted
#S assertGuiStarted;
#C Enforces GUI initialization

#I isGuiStarted
#S isGuiStarted;
#C Returns true if the GUI is started

#I showConsole
#S showConsole; 
#C shows the console

#I hideConsole
#S hideConsole; 
#C hides the console

#I readXmlFile
#S readXmlFile(filename:String);
#C Reads contents of an XML file and returns the contents as a list

#I readXml
#S readXml(input:String);
#C Parses input as XML and returns the contents as a list

#I parseJson
#S parseJson(value:String);
#C Reads contents of a JSON string and returns an MNH representation.
#S parseJson(value:String,insteadOfNull);
#C As above but representing null values with given marker

#I formatJson
#S formatJson(x);
#C Formats x as a JSON (as far as compatible)

#I linearInterpolator
#S linearInterpolator(L:List);
#C returns an linear interpolator, which returns values out of L by their index

#I newSplineInterpolator
#S newSplineInterpolator(L:List);
#C returns an C-Spline interpolator, which returns values out of L by their index

#I newBSpline
#S newBSpline(L:List);
#C returns an Bezier approximator

#I newFourierSeries
#S newFourierSeries(L:List);
#C returns an Fourier Series with coefficients L=[[c0,s0],[c1,s1]...]

#I calculateFourierCoefficients
#S calculateFourierCoefficients(L:List,maxWaveNumber>=0);
#C Calculates fourier coefficients for nonequidistant points in L given as [[t0,y0],[t1,y1],...]

#I newLocalInterpolator
#S newLocalInterpolator(L:List);
#C returns an local non-convex smooth interpolator

#I rangeGenerator
#S rangeGenerator(i0:Int,i1:Int);
#C returns a generator generating the range [i0..i1]
#S rangeGenerator(start:Int);
#C returns an unbounded increasing generator

#I permutationIterator
#S permutationIterator(i:Int);
#C returns a generator generating the permutations of [1..i]
#S permutationIterator(c:collection);
#C returns a generator generating permutationf of c

#I map
#S map(L,f:Expression(1));
#C Returns a list with f(x) for each x in L
#C L may be a generator
#S map(L,f:Expression(0));
#C Returns a list by applying f. The input L is ignored (apart from its size)
#S flatMap(L,f:Expression(1));
#C flattens L and applies f
#S flatMap(L);
#C Note that the mapping function (if present) is applied AFTER flattening!
#C Always returns an iteratable expression

#I chunkMap
#S chunkMap(L,chunkSize>0,f:Expression(1));
#C joins L in chunks of the specified size and applies f
#S chunkMap(L,chunkSize>0);
#C Note that the mapping function (if present) is applied AFTER chunking!
#C Always returns an iteratable expression

#I pMap
#S pMap(L,f:Expression(1));
#C Returns a list with f(x) for each x in L
#C L may be a generator
#S pMap(L,f:Expression(0));
#C Returns a list by applying f. The input L is ignored (apart from its size)

#I filter
#S filter(L,acceptor:expression(1));
#C Returns compound literal or generator L with all elements x for which acceptor(x) returns true

#I pFilter
#S pFilter(L,acceptor:expression(1));
#C Returns compound literal or generator L with all elements x for which acceptor(x) returns true
#C As filter but processing in parallel

#I fileLineIterator
#S fileLineIterator(filename:String);
#C returns an iterator over all lines in f
#S fileLineIterator(filename:String,timeoutInSeconds:Numeric);
#C The iterator "follows" the file until it is unchanged for timeoutInSeconds

#I byteStreamIterator
#S byteStreamIterator(filename:String,chunkSize>0);
#C returns an iterator over all lines in f
#S byteStreamIterator(...,timeoutInSeconds:Numeric);
#C The iterator "follows" the file until it is unchanged for timeoutInSeconds

#I primeGenerator
#S primeGenerator;
#C returns a generator generating all prime numbers
#C Note that this is an infinite generator!

#I stringIterator
#S stringIterator(charSet:StringCollection,minLength>=0,maxLength>=minLength);
#C returns a generator generating all strings using the given chars

#I randomGenerator
#S randomGenerator(seed:Int);
#C returns a XOS generator for real valued random numbers in range [0,1)
#S intRandomGenerator(seed:Int,range>0);
#C returns a XOS generator generating pseudo random integers in range [0,range)
#C The range of the returned generator can be changed by calling it with an integer argument.

#I isaacRandomGenerator
#S isaacRandomGenerator(seed:Int,range>0);
#C returns an ISAAC generator generating pseudo random integers in range [0,range)
#H See <a href="www.burtleburtle.net/bob/rand/isaacafa.html">www.burtleburtle.net/bob/rand/isaacafa.html</a>
#C The range of the returned generator can be changed by calling it with an integer argument.

#I vanDerCorputGenerator
#S vanDerCorputGenerator(base>=2);
#C returns a Van der Corput generator for the given base

#I ask
#S ask(q:string);
#C Asks the user question q and returns the user input
#S ask(q:string,options:stringList);
#C Asks the user question q, giving the passed options and returns the chosen option
#S ask(...,visible:Boolean);
#C Optionally disables question feedback (console ask only)

#I showVarible
#S showVarible(L);
#C Shows L in a tree view.
#S showVariable(L,caption:string);
#C Shows L in a tree view with given caption

#I showTable
#S showTable(L:list);
#C Shows L in a table.
#S showTable(L:list,caption:string);
#C Shows L in a table with given caption.
#S showTable(L:list,caption:string,firstRowIsHeader:boolean);
#C Shows L in a table with given caption.
#S showTable(L:list,caption:string,fixedRows:Int,fixedColumns:Int);
#C Shows L with customized fixed rows and columns

#I showDialog
#S showDialog(title:String,contents);
#C Shows a custom dialog defined by the given contents (Map or List)
#C returns void when the form is closed

#I editors
#S editors(...);
#C Lists all editors

#I editorContent
#S editorContent(name:string);
#C Returns the content of the given editor as a string or void if no such editor was found.

#I plotClosed
#S plotClosed;
#C Returns true if the plot has been closed by user interaction

#I clearAnimation
#S clearAnimation;
#C Clears the animated plot
#S clearAnimation(true);
#C Clears the animated plot and switches to volatile mode

#I addAnimationFrame
#S addAnimationFrame;
#C Adds the current plot to the animation and returns ['sleep'=>...,'frameCount'=>...].toMap

#I display
#S display;
#C Displays the plot as soon as possible and waits for execution

#I postDisplay
#S postDisplay;
#C Displays the plot as soon as possible and returns immediately

#I plotImageSize
#S plotImageSize;
#C Returns the plot image size or [-1,-1] if not initialized

#I changeDirectory
#S changeDirectory(folder:String);
#C Sets the working directory

#I setExitCode
#S setExitCode(code:Int);
#C Sets the exit code of the executable.
#C Might be overridden by an evaluation error.

#I beep
#S beep;
#C Makes a beep

getOptions;
#S getOptions;
#C returns plot options as a key-value-list.

#I setOptions
#S setOptions(set:keyValueList);
#C Sets options via a key value list of the same form as returned by plot.getOptions
#S setOptions(key:string,value);
#C Sets a single plot option

#I resetOptions
#S resetOptions;
#C Sets the default plot options

#I renderToFile
#S renderToFile(filename<>'',width>=1,height>=1);
#C Renders the current plot to a file.
#S renderToFile(filename<>'',width>=1,height>=1,background:true);
#C Renders the current plot to a file in a background thread.

#I renderToString
#S renderToString(width,height);
#C Renders the current plot to a string.

#I removePlot
#S removePlot;
#C Removes the last row from the plot
#S removePlot(n>=1);
#C Removed the last n rows from the plot

#I drawText
#S drawText(x,y,text);
#C Draws custom text
#S drawText(x, y, text, size:Numeric, anchor in ["TL","T","TR","CL","C","CR","BL","B","BR"], font:String, textCol:IntList(3), backgroundCol:IntList(3));
#C Draws text with custom options. Custom parameters are optional

#I drawTextAbsolute
#S drawTextAbsolute(x,y,text);
#C Draws custom text at absolute position
#S drawTextAbsolute(x,y,text,size:Numeric,anchor in ["TL","T","TR","CL","C","CR","BL","B","BR"],font:String,textCol:IntList(3),backgroundCol:IntList(3));
#C Draws text with custom options. Custom parameters are optional

#I fileInfo
#S fileInfo(filenameOrPattern:String);
#C Retuns file info as a key-value-list#fileInfo(filenameOrPattern:StringList);
fileInfo(executor);

#I execAsync
#S execAsync(programPath:String,parameters ...);
#C Starts the specified program and returns the process id

#I execPipeless
#S execPipeless(programPath:String,parameters ...);
#C Executes the specified program, waiting for exit and returns the exit code

#I deleteFile
#S deleteFile(filename:String);
#C Deletes the given file, returning true on success and false otherwise

#I deleteDir 
#S deleteDir(directoryname:String);
#C Deletes the given directory, returning true on success and false otherwise

#I copyFile 
#S copyFile(source:String,dest:String);
#C Copies a file from source to dest, returning true on success and false otherwise

#I moveFile
#S moveFile(source:String,dest:String);
#C Moves a file from source to dest, returning true on success and false otherwise

#I getEnv
#S getEnv;
#C Returns the current environment variables as a nested list.
getEnv.toList.head;

#I fileStats
#S fileStats(filename:String);
#C Retuns a triplet [lineCount,wordCount,byteCount,hash].#fileStats(filename:StringList);
fileStats(executor);

#I exec
#S exec(programPath:String);
#C Executes the specified program and returns the text output including stdErr output and the exitcode as a nested list: [[output,...],exitCode]
#S exec(programPath:String,parameters:flatList);
#C Executes the specified program with given command line parameters#
#S exec(programPath:String,includeStdErr:boolean);
#C Executes the specified program and returns the text output optionally including stdErr output#
#S exec(programPath:String,parameters:flatList,parameters:flatList);
#C Executes the specified program with given command line parameters and returns the text output optionally including stdErr output
ExecutionResult:=executor.exec(['-h']);
print('Execution returned with code ',
      ExecutionResult[1],"\n",
      ExecutionResult[0]
        .tail(3)
        .head(7)
        .join("\n")
        .clean([#10,' ',')','/','\','_','|'],''));

#I teeExec
#S teeExec(...);
#C Behaves as exec but additionally prints out to stdout
#C You can add an additional expression to use instead of printing to stdout

#I inspect
#S inspect;
#C Returs information on the current package
#S inspect(idOrPath:String);
#C Returns information on an imported package or a specified MNH source file
#S inspect(path:String,source:StringList);
#C Returns information of a package with given path and source
inspect('sudoku').{
  print('Package ID is: ',$L['id']) |
  print('Path         : ',$L['path']) |
  print('Uses         : ',$L['uses']) |
  $L['declares']
  .each(rule,rule[1,'type']&" rule:\t"&rule[0]&"\t"&rule[1,'location'])
  .join("\n")
  .print};

#I inspectAll
#S inspectAll;
#C Returs information on all currently loaded packages

#I writeAllDataStores
#S writeAllDataStores;
#C Writes back all modified datastores (including stores in imported packages) and returns true if any store was updated.
#S writeAllDatastores(deflate:Boolean,reuse:Boolean);
#C Write binary datastores in a certain format, priorizing speed or size

#I writeDataStores
#S writeDataStores;
#C Writes back all modified datastores of the current package (i.e. excluding stores in imported packages) and returns true if any store was updated.
#S writeDatastores(deflate:Boolean,reuse:Boolean);
#C Write binary datastores in a certain format, priorizing speed or size

#I helpOnMain
#S helpOnMain;
#C Returns help text for the current package''s main method.

#I anyFormShowing
#S anyFormShowing();
#C returns true if any form is showing

#I formatHtmlPage
#S formatHtmlPage(lines:StringList,filename:String);
#C formats naive html

files('*.mnh')
#S files(searchPattern:String);
#C Returns a list of files matching the given search pattern

#I allFiles
#S allFiles(root);
#C Returns a list of all files below root (string or stringList)
#S allFiles(root,pattern);
#C Returns a list of all files matching pattern(s) (string or stringList)
#S allFiles(root,pattern,recurse=false);
#C As above but without recursing subfolders

folders('*');
#S folders(searchPattern:String);
#C Returns a list of folders matching the given search pattern

allFolders('.');
#S allFolders(rootFolder:String);
#C Returns a list of all folders below and including a given root directory

fileExists('testLog.mnh');
#S fileExists(filename:String);
#C Returns true if the specified file exists and false otherwise

folderExists('folderName');
#S folderExists(foldername:String);
#C Returns true if the specified folder exists and false otherwise

#I fileContents
#S fileContents(filename:String);
#C Returns the contents of the specified file as one string

mnhInfo;
#S mnhInfo;
#C Returns a key-value list with info on the currently executing instance of MNH

myPath;
#S myPath;
#C returns the path to the current package

expandedFileName('/home/user/file.ext');
#S expandedFileName(F);
#C Returns the expanded file name of file(s) given by string or stringList F


ln(3);

#I plot
#S plot(list,options);
#C plots flat numeric list or xy-list
#S plot(xList,yList,options);
#C plots flat numeric list or xy-list
#S plot(f:expression(1),t0,t1>t0,samples>=2,options);
#C plots f versus t in [t0,t1]
#C options are optional and given in the form of a string, the individual option items being delimited by spaces
#C valid options are:
#C Style/size modifier: any real number
#C Styles:
#C   line; l;
#C   bspline; b;
#C   cspline; c;
#C   stepLeft;
#C   stepRight;
#C   fill; f;
#C   fillSolid; fs;
#C   bar;
#C   box;
#C   ellipse; e;
#C   tube;
#C   dot; .;
#C   plus; +;
#C   cross; x;
#C   impulse; i;
#C   polygon; p;
#C Colors:
#C   black;
#C   red;
#C   blue;
#C   green;
#C   purple;
#C   orange;
#C   RGB$,$,$; //With three real numbers in range [0,1]
#C   HSV$,$,$; //With three real numbers in range [0,1]
#C   HUE$; //With one real number
#C   GREY$; //With one real number in range [0,1]
#C Transparency Index:
#C   TI$;// with an integer $

#I addPlot
#S addPlot(list, options);
#C adds plot of flat numeric list or xy-list
#S addPlot(xList, yList, options);
#C adds plot of flat numeric list or xy-list
#S addPlot(f:expression(1), t0, t1>t0, samples>=2, options);
#C adds plot of f versus t in [t0,t1]

#I plotRasterImage
#S plotRasterImage(colors:List;width>=1);
#C Plots a raster image given by a 1D-List of colors
#S plotRasterImage(colors:List;width>=1,scale:Numeric,offsetX:Numeric,offsetY:Numeric);
#C Plots a raster image with custom scaling

DFT([1..10..1]);
#S DFT(x:List);
#C Returns the Discrete Fourier Transform of x

iDFT([[10..0],[0..10]].transpose);
#S iDFT(x:List);
#C Returns the inverse Discrete Fourier Transform of x

FFT([1..10..1]);
#S FFT(x:List);
#C Returns the Fast Fourier Transform of x

iFFT([[10..0],[0..10]].transpose);
#S iFFT(x:List);
#C Returns the inverse Fast Fourier Transform of x


#I math.calculateFourierCoefficients
([0..99]/100*2*pi).map((x)->sin(x)+cos(2*x)).calculateFourierCoefficients(8); //Straight forward DFT

#I math.calculateFourierCoefficients
(random(100).sort*2*pi).map((t)->[t,sin(t)+cos(2*t)]).calculateFourierCoefficients(8); //Nonequidistant Fourier transform
//Use the function's output to feed math.newFourierSeries

#I math.integrate
#S integrate(f:Expression(1),x0,x1,pointCount>1);
#C returns the numeric integral of f over interval [x0,x1]
integrate((x)->sin(x)²,0,2,1000);

bitXor(5,213,10);
#S bitXor(x:Int,y:Int,relevantBits in [1..32]);
#C Returns x xor y for the given number of relevant bits         

#I assertUniqueInstance
#S assertUniqueInstance;
#C Returns with an error if there already is an instance of this script running.

#I startIpcServer
#S startIpcServer(id:String, serve:Expression(1));
#C Creates an IPC server
#C An IPC server can receive [I]nter [P]rocess [C]ommunication from other processes.
#C While the server is running, it will receive requests sent via sendIpcRequest, pass the parameters to serve and respond with the result returned by serve.

#I sendIpcRequest
#S sendIpcRequest(serverId:String,request);
#C Delegates a given request to an IPC server

#I isIpcServerRunning
#S isIpcServerRunning(serverId:String);
#C Returns true if the given IPC server is running and false otherwise
#S isIpcServerRunning;
#C Returns true if this script is already running and called assertUniqueInstance

#I randomIfs
#S randomIfs;
#C returns a random IFS to be fed to executeWorkflow

#I expandImageGeneration
#S expandImageGeneration(s:String);
#C Returns the generation algorithm with all fields

#I newQueue
#S newQueue;
#C Returns a new queue; The queue can be filled with "put" and otherwise behaves as an iteratable.

#I put
#S put(Q:Queue, valueToAdd, ...);
#C Adds one one or more values to the queue

#I closeQueue
#S closeQueue(Q:Queue);
#C Closes the queue

#I newFileOutputStream
#S newFileOutputStream(filename:String, append:Boolean, separator:String);
#C Creates a new file output stream which can be called with bytes, strings, booleans and reals to be written to the file.
#C Parameter append can be omitted. It defaults to false.
#C Parameter separator can be omitted. It defaults to an empty string.