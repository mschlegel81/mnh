S:=newStack;
S.push('A');
S.push('B');
S.top;
S.size;
S.pop;
S.pop;
S.pop;

Q:=newQueue;
Q.put(1);
Q.put(2);
Q.put(3);
Q.size;
Q()(); //First call resolves Q, second call calls the queue object
Q.closeQueue; //You must call this before iterating!
Q.agg(|);

#I newStack
#S newStack()
#C Returns a new stack, which is an iterable expression. Iterating means calling stack.pop until the stack is empty.
#C Operations defined on stacks: push, pop, top and size

#I push
#S push(S:Stack,value)
#C Pushes value to stack S

#I top
#S top(S:Stack)
#C Returns the top element of S, or void if the stack is empty

#I pop
#S pop(S:Stack)
#C Returns the top element of S after removing it from the stack. If the stack is empty, void is returned.

#I map2list
#S map2list(m:Map, defaultValue)
#C Converts a map with nonnegative integers as keys to a list, using the keys as list indexes and the default value as fallback.
[2=>'A',4=>'B'].toMap.map2list('-');

#I tt_if tt_then tt_else
x:=3;
if (x and 1)=0 then 'even' else 'odd';

#I tt_if tt_then
if false then 'o.k.'; //If the else-branch is missing it returns void

#I tt_if tt_then tt_else
f(a,b,c)->if a then b else c; //Internally, if-then-else is mapped to inline-if
::f;

#I tt_while
begin
  L:=[5..1];
  while L.size<10 do L|=0;
  L;
end;

#I tt_while
begin
  x:=0;
  while (x+=pi)<10;
  x;
end;

#I tt_repeat tt_until
begin
  x:=10;
  repeat print(x+=1) until x>0;
end;

#I tt_repeat tt_until
begin
  output:=[];
  x:=10;
  repeat output|=x; x-=1; until x<=0;
  output;
end;

#I tt_for
for x in ['A'..'C'] do print(x);

#I tt_for
for x in [1..4] do 0|x do x|0;

#I tt_for
for i in [1..10000] do parallel 1/i² aggregator(+);"

#I tt_each
cross([1..3],[1..3]).each(x, x-0.5, x+0.5); //useful for plotting with style "ellipse"

#I tt_each
[1..10].each(v,cos(v),+); //If the last argument is an aggregation marker, aggregation is performed

#I tt_each tt_aggregatorConstructor
random(3).each(y,sqr(y),aggregator((x)->print(x))); //You can use unary custom aggregators using the aggregator constructors

#I tt_each tt_aggregatorConstructor
random(100).each(t,sin(t),aggregator((x,y)->max(x,y)/y)); //You can use binary custom aggregators using the aggregator constructors

#I tt_save
counter->begin
  c:=0;
save;
  c+=1;
end;
counter();
counter();
counter();

#I OPERATOR_STRCONCAT
#S OPERATOR_STRCONCAT(a,b);
#S a & b
#C Returns a string concatenation of a and b; vectorized for nested lists/sets

#I readDatastore
#S readDatastore(scriptPath:String,ruleName:String);
#C Tries to read the specified datastore; returns void if the datastore does not exist#
#S readDatastore(datastorePath:String);
#C Tries to read the specified datastore - returns a map with keys "id" and "content"

#I halt
#S halt;
#C Quietly stops the evaluation. No further errors are raised
#S halt(exitCode:Int);
#C Convenience method to halt with a defined exit code

#I printDirect
#S printDirect(...);
#C Prints out the given string without pretty printing or line breaks

#I COMPARATOR_EQ
#S COMPARATOR_EQ(x,y);
#S x = y
#C Wrapper function for =; vectorized for nested lists/sets
3=3.0;

Nan = Nan //Nan is not equal to itself by definition

{$x}=3; //Used with expressions the result will be a new expression

[1,2,3]=[3,1,3]; //= compares element by element

arity({3});
#S arity(e:Expression);
#C Returns the arity (i.e. the number of accepted parameters of expression e)

#I mnh.arity
arity({sin($x)/$x});

[1..2].isIntList;
#S isIntList(x);
#C Returns true iff x is an intList
#S isIntList(x,listSize>=0);
#C Returns true iff x is an intList with listSize elements

extractFileDirectory('folder/subFolder/file.extension')
#S extractFileDirectory(s)
#C Returns the directory for String s; vectorized for nested lists/sets

#I mnh.runScript
runScript(['name'=>'hello.mnh',
           'source'=>["main->print('Hello world');"],
           'side effects'=>['alter package state','output']].toMap)
.filter({$message.head=='printline'})
.map(::trailing);
#S runScript(config:Map);
#C executes the given script config
#C expected keys:
#C   'name' (String, mandatory)
#C   'source' (StringList)
#C   'parameters' (StringList)
#C   'side effects' (StringCollection, see function listSideEffects for possible values)
#C   'connection level' 0: isolated, 1: print, 2: print and warnings, 3: print, warnings and errors
#C   'deterministic' (Boolean, true to enforce determinism of PRGNs)

#I mnh.arity
arity({sin($x)/$y});

#I mnh.arity
//For variadic functions only the non-optional parameters are counted:
arity({printf('%s%s',$a,...)});

toExpression("$x-$x^2+$x^3");
#S toExpression(S);
#C Returns an expression parsed from string or list S

toExpression("");

parameterNames({3});
#S parameterNames(e:expression);
#C Returns the IDs of named parameters of e

#I mnh.parameterNames
parameterNames({sin($x)/$x});

#I groupToList
groupToList([1,2,3,4,5,6],[1,2,3,1,2,3],Nan,::*);
#S groupToList(values:List,indexes:IntList,defaultValue,aggregator:Expression(2));
#C Groups values by indexes to a list, using defaultValue where no value is given and aggregating using the aggregator
#S groupToList(values:List,indexes:IntList,defaultValue,aggregator:Expression(2),initialSize>=0);
#C As above but with a predefined initial result list size

#I mnh.parameterNames
//For variadic functions only the non-optional parameters are counted:
parameterNames({printf("%s%s", $a, ...)});

ord(3);
#S ord(x);
#C Returns the ordinal value of x

ord(true);

ord(false);

ord("A");

ord("abc");

ord(2.1);

softCast("A");
#S softCast(X);
#C Returns a simplified version of X, trying to parse integers, real values and booleans

softCast('"B"');

softCast(3);

softCast([1, "2", "true", "'TEXT'", "1.5", "2,6"]);

toString('a');
#S toString(X);
#C Casts X to string

toString(234);

toString([1, 2.6, "a", true, {$x}]);

#I abs
#S abs(x)
#C Returns the absolute value of x; vectorized for nested lists/sets
abs(-0.92);

abs(3);

#I abs
abs({1+$x});

#I arccos
#S arccos(n);
#C Returns the arccosine of numeric or expression parameter n
arccos(-0.92);

//Out of function domain
arccos(3);

#I arccos
arccos({1+$x});

#I arcsin
#S arcsin(n);
#C Returns the arcsine of numeric or expression parameter n
arcsin(-0.92);

//Out of function domain
arcsin(3);

#I arcsin
arcsin({1+$x});

#I tan
#S tan(n);
#C Returns the tangent of numeric or expression parameter n
tan(-0.92);

tan(3);

#I tan
tan({1+$x});

#I pi
#S pi;
#C Returns pi

#I math.tan
tan(pi/2);

#I arctan
#S arctan(n);
#C Returns the arctangent of numeric or expression parameter n
arctan(-0.92);

arctan({$x});

#I argMax
#S argMax(L);
#C Returns the index of the greatest element out of list L (or the first index if ambiguous)
argMax(sin([0..10]));

argMax([1, 3, 3, 0, 2]);

#I argMin
#S argMin(L);
#C Returns the index of the smallest element out of list L (or the first index if ambiguous)
argMin(sin([0..10]));

argMin([1, 3, 3, 0, 2]);

#I ceil
#S ceil(x);
#C Returns the smallest integer >=x
#S ceil(x,k);
#C Does the same but with k digits precision
ceil(20/3);

#I ceil
ceil([0..3]/3);

#I ceil
ceil([0..3]/3, 2);

#I floor
#S floor(x);
#C Returns the largest integer <=x
#S floor(x, k);
#C Does the same but with k digits precision
floor(20/3);

#I floor
floor([0..3]/3);

#I floor
floor([0..3]/3, 2);

#I round
#S round(x);
#C Returns the value of x, rounded to the nearest integer
#S round(x, k);
#C Returns the value of x rounded to k-digits precision
round(20/3);

//Numbers with ambiguous rounding result are rounded towards even numbers
round([0.5, 1.5, 2.5, 3.5]);

#I round
round([0..3]/3, 2);

isInfinite(Nan);

#I isInfinite
#S isInfinite(n);
#C Returns true if n is a number representing an infinite value
isInfinite(+Inf);

#I isInfinite
isInfinite(-Inf);

#I isInfinite
isInfinite([-3.4344, Nan, +Inf]);

isNan(Nan);

#I isNan
#S isNan(n);
#C Returns true if n is a number representing the value Not-A-Number
isNan(+Inf);

#I isNan
isNan(-Inf);

#I isNan
isNan([-3.4344, Nan, +Inf]);

#I cos
#S cos(n);
#C Returns the cosine of numeric or expression parameter n
cos(-0.92);

cos(3);

#I cos
cos({1+$x});

#I exp
#S exp(n);
#C Returns the exponential of numeric or expression parameter n
exp(-0.92);

exp(3);

#I exp
exp({1+$x});

#I ln
#S ln(n);
#C Returns the natural logarithm of numeric or expression parameter n
ln(-0.92);

#I ln
ln({1+$x});

#I sin
#S sin(n);
#C Returns the sine of numeric or expression parameter n
sin(3);

#I sin
sin({1+$x});

#I sqr
#S sqr(n);
#C Returns the square of numeric or expression parameter n
sqr(-0.92);

sqr(3);

#I sqr
sqr({1+$x});

#I sqrt
#S sqrt(n);
#C Returns the square root of numeric or expression parameter n
sqrt(-0.92);

sqrt(3);

#I sqrt
sqrt({1+$x});

#I isqrt
#S isqrt(n:Int);
#C Returns [round(sqrt(n)), isSquare(n)]
#S isqrt(n:Int,rounding in [-1,0,1]);
#C Returns the integer square root with custom rounding. -1: down, 0: even, 1: up
isqrt(121);

isqrt(255,1);

#I sign
#S sign(n);
#C Returns the sign of numeric or expression parameter n
sign(-0.92);

sign(3);

#I sign
sign({1+$x});

max(["a".."z"]);

#I max
#S max(L);
#C Returns the greatest element out of list L
#S max(x, y, ...);
#C Returns the greatest element out of the given parameters
max([0..9]/2);

max(true, false);

min(["a".."z"]);

#I min
#S min(L);
#C Returns the smallest element out of list L
#S min(x, y, ...);
#C Returns the smallest element out of the given parameters
min([0..9]/2);

min(true, false);

copy("abcde", 1, 3);
#S copy(S,start,length):
#C Returns the substring of S starting at index start and having specified length

copy("abcde", 2);

escape("a");
#S escape(S:String);
#C Returns an escaped representation of S

escape("\t");

#I group
#S group(list, grouping);
#C Re-groups list to a map by grouping (which is a sub-index or a list)
#S group(list, grouping, aggregator:Expression(2));
#C Groups by grouping using aggregator on a per group basis
//Group a list of numbers by divisibility by 3
group([1..10],[1..10] mod 3=0);

fail;
#S fail;
#C Raises an exception without a message
#S fail(...);
#C Raises an exception with the given message

fail("Told you this wouldn't work!");

hash(1);
#S hash(x);
#C Returns the builtin hash for the given literal

hash([1..3]);

hash("a");

#I listBuiltin
listBuiltin.filter({$s.matches('^mnh\.')}).sort.trailing(10);
#S listBuiltin;
#C Returns a set of all builtin functions, only qualified IDs

#S abs(n);
#C Returns the absolute value of numeric or expression parameter n
abs(3);

#I abs
abs(-3);

#I abs
abs([-2..2]/2); 

chars('This is a test.');
#S chars(S);
#C Returns the characters in S as a list
#S chars;
#C Returns all possible single-byte characters in natural ordering

#I chars
chars.get(100);

clean('+21/232/2116-11',['0'..'9'],' ');
#S clean(s,whiteList:StringCollection,instead:String);
#C Replaces all characters in s which are not in whitelist by instead.
#S clean(s,whiteList:StringCollection,instead:String,joinPlaceholders:boolean);
#C As above but joining placeholders

join(['a','b','c']);
#S join(L:List);
#C Returns a string-concatenation of all elements in L
#S join(L:List,joiner:String);
#C Returns a string-concatenation of all elements, with joiner between.

join([1..5],' ');

length('Test öäü');
#S length(S:String);
#C Returns the number of characters in string S

byteLength('Test öäü');
#S byteLength(S:String);
#C Returns the number of bytes in string S

length(['Text','AbC']);

lower('Test');
#S lower(S:String);
#C Returns an lowercase representation of S

lower(['Text','AbC']);

upper('Test');
#S upper(S:String);
#C Returns an uppercase representation of S

upper(['Text','AbC']);

#I plot
t:=[0..1000]*2*pi/1000;
plot(t,sin(t));
plot.renderToFile('plotDemo1.png',600,300);
    
abs({$x});

chars('Test');

pos('o','Hello World');
#S pos(subString,searchInString);
#C Returns the index of the first occurence of subString in searchInString or Infinity if there is none

pos(',',['Hello','Test','1,2,3']);

pos(['a','b'],'cdb');

repeatString('-',10);
#S repeatString(s:String,k:Int);
#C Returns a string containing s repeated k times

//Simple test for correct bracketing:
replace('[[][]][]][][','[]','');
#S replace(source:String,lookFor,replaceBy);
#C Recursively replaces all occurences of lookFor in source by replaceBy
#C lookFor and replaceBy may be of type string or stringList

//Iteration will not take place if it is infinite:
replace('aba','b','bb');

replaceOne('[[][]][]][][','[]','');
#S replaceOne(source:String,lookFor,replaceBy);
#C Replaces the first occurences of lookFor in source by replaceBy
#C lookFor and replaceBy may be of type string or stringList

replaceOne('1:.-.; 2:.-.; 3:.-.','.',['a'..'e']);

split('1,2,3;4,5,6',',');
#S split(S:String, splitter:String);
#C Returns a list of strings obtained by splitting S at the specified splitters without the splitters
#S split(S:String, splitter:String, retainSplitters:boolean);

split('1,2,3;4,5,6',';');

split('1,2,3;4,5,6',[';',',']);

tokenSplit('f(x)->x+1; //Stupid, but just an example...','mnh');
#S tokenSplit(S:string);
#S tokenSplit(S:string,language:string);
#C Returns a list of strings from S for a given language
#C Languages: <code>MNH, Pascal, Java</code>

trim(" \tA B C\t ");
#S trim(S:String);
#C Returns string S without leading or trailing spaces

trimLeft(" \tA B C\t ");
#S trimLeft(S:String);
#C Returns string S without leading spaces

trimRight(" \tA B C\t ");
#S trimRight(S:String);
#C Returns string S without trailing spaces

unbrace('3');
#S unbrace(S:String);
#C Returns an unbraced representation of S

unbrace('(3)');

unbrace('(3]');

unbrace('"3"');

#I elementFrequency
#S elementFrequency(L);
#C Returns a map e=>count containing distinct elements e of L and their respective counts.
#C The result can be interpreted as a multiset.
chars('Testtext').elementFrequency;

#I elementFrequency
//elementFrequency can be used for aggregating
chars('Testtext').agg(elementFrequency);

#I flatten
#S flatten(L,...);
#C Returns all parameters as a flat list.
flatten([1,[2,[3,4],[5]],6]);

#I head
#S head(L);
#C Returns the first element of list L or [] if L is empty
head(['A'..'Z']);

#S head(L,k);
#C Returns the first min(k,size(L)) elements of L or [] if L is empty
head(['A'..'Z'],3);

#I head
['A'..'Z'].toSet.head(3);

#I tail
#S tail(L);
#C Returns list L without the first element
tail(['A'..'Z']);

#S tail(L,k);
#C Returns L without the first k elements
tail(['A'..'Z'],3);

#I tail
rangeGenerator(1,10).tail(3);

#I leading
#S leading(L);
#C Returns L without the last element or [] if L is empty
leading(['A'..'Z']);

#S leading(L,k);
#C Returns L without the last k elements or [] if L is empty
leading(['A'..'Z'],3);

#I leading
rangeGenerator(1,10).leading(3);

#I trailing
#S trailing(L);
#C Returns the last element of L
trailing(['A'..'Z']);

#S trailing(L,k);
#C Returns the last k elements of L
trailing(['A'..'Z'],3);

#I trailing
['A'..'Z'].toSet.trailing(3);

#I trailing
rangeGenerator(1,10).trailing(3);

#I minus
#S minus(A,B);
#C Returns the asymmetric set difference of A and B. All parameters must be collections.
//Odd squares
minus([1..10]²,2*[0..50])

#I chunkMap
rangeGenerator(1,20).chunkMap(5,(x)->format('%2s',x)).toList;

#I flatMap
#S flatMap(L,f:Expression(1));
#C flattens L and applies f
#S flatMap(L);
#C Note that the mapping function (if present) is applied AFTER flattening!
#C Always returns an iterable expression
[1,[2,3],[4,5,6]].flatMap((x)->x³).toList;

#I sort
#S sort(L);
#C Returns list L sorted ascending (using fallbacks for uncomparable types)
#S sort(L,innerIndex:Int);
#C Returns L sorted by given inner index
sort(intRandom(10,5));

#I sort
#S sort(L,leqExpression:Expression(2));
#C Returns L sorted using the custom binary expression, interpreted as "is lesser or equal"#
sort(['01','10','100','1','010'],(x,y)->softCast(x)<=softCast(y));

#I sort
#S sort(L,mapExpression:Expression(1));
#C Returns L sorted using the custom unary expression, behaves as L.get(L.map(mapExpression))#
sort(['01','10','100','1','010'],::length);

#I sortPerm
#S sortPerm(L);
#C Returns indexes I so that L[I]==sort(L)
//A random permutation:
sortPerm(random(10));

sortPerm(['a'..'c'..'a']);

#I intersect
#S intersect(A,...);
#C Returns an intersection of all given parameters. All parameters must be collections.
intersect([0..1000]^2,[0..1000]^3);

#I union
#S union(A, ...);
#C Returns a union of all given parameters. All parameters must be collections.
union(1/[1..5],2/[2..6]);

deleteFile('plotDemo1.png');

get(['a'..'f'],3);
#H See <a href="types.html#lists">List types</a> for further information

get(['a'..'f'],[3,1,2]);

#I get
get([0..4],[2..6] mod 3 = 0);
#S get(L,accessor);
#C Returns elements of list, set or map L by accessor
#C This is the functional way of writing L[accessor]


get([['A',1],['B',2],['C',0]],'B');

#I getInner
#S getInner(L:List, k:Int);
#C Returns the k-th elements of each entry in nested list L
#H See <a href="types.html#lists">List types</a> for further information
getInner([[1,2,3],[4,5,6],[7,8,9]],1);

getInner([[1,2,3],[4,5,6],[7,8,9]],[1,0]);

getInner([[1,2,3],[4,5,6],[7,8,9]],[true,false,true]);

#I indexOf
#S indexOf(B:BooleanList);
#C Returns the indexes for which B is true.
indexOf([1..6]^2 mod 3=0);

#I reverseList
#S reverseList(L:List);
#C Returns L reversed
reverseList([1..5]);

#I size
#S size(L);
#C Returns the number of elements in set, list or map L
size([0.5,0.1,0.2]);

toMap([['A',1], ['B',2], ['C',0], ['B',4]]);
#S toMap(X:Collection);
#C Casts X to map or throws an error if not possible

#I trueCount
#S trueCount(B:BooleanList);
#C Returns the number of true values in B
trueCount(10<[0..10]^2<50);

unique([3,1,2,1,4,1,5]);
#S unique(L:List);
#C Returns list L without duplicates.

#I compress
#S compress(S:String);
#C Tries out compression algorithms and returns the shortest representation - this may be the input string.
#S compress(S:String,algorithm in [0..2]);
#C Returns the string compressed with the given method:
#C   0: No compression
#C   1: Deflate
#C   2: Hardcoded Digram-Huffman

#I decompress
#S decompress(S:String);
#C Returns an uncompressed version of S

//It is possible that the compressed string equals the original string.
compress('Test');
compress('Test').decompress;

compress('This text is long enough to give deflate a little edge. So deflate will be used.');
compress('This text is long enough to give deflate a little edge. So deflate will be used.').decompress;

relativeFileName('~/folder/','~/other/example.txt');
#S relativeFileName(reference,file);
#C Returns the path of file relative to reference#relativeFileName(file);
#C Returns the path of file relative to the current working directory

primes(20);
#S primes(pMax:Int);
#C Returns prime numbers up to pMax


subSets([1,2,1]);
#S subSets(S);
#C Returns all distinct subsets of S
#S subSets(S, k:Int);
#C Returns all distinct subsets of S having k elements

diff('encode','decode');
#S diff(A,B);
#C Shows diff statistics and edit script for strings A and B or string lists A and B
#S diff(A,B,convertModifies:boolean);
#C As above but optionally convert modifies to adds and deletes

diffStats('encode','decode');
#S diffStats(A,B);
#C Shows diff statistics for strings A and B or string lists A and B

//String: %s, Decimal format: %d  (parameters are optional)
format('%s is a string, %3.3d is a number','X',7);

//Floating point format: %f
format('%6.3f',3);

//Scientific format: %e
format('%6.3e',3);

//General number format: %g
format('%6.3g',3);

//Hexadecimal: %x (parameters are optional)
format('%6.6x',1234);
#S format(formatString:String,...);
#C Returns a formatted version of the given 0..n parameters
#H See <a href="formatStrings.html">Format Strings</a>

formatTime('mm.dd.yyyy',43210);
formatTime(12424.245);
#S formatTime(formatString:String, t);
#C Returns time t (numeric list or scalar) formatted using format string
#H <a href="formatStrings.html">Format Strings</a>

isAscii('xyz');

#I isAscii
isAscii('xyz'&chars[180]);

isAscii('Läuft');
#S isAscii(S:String);
#C Returns true if S is ASCII encoded and false otherwise

isUtf8('xyz');
#S isUtf8(S:String);
#C Returns true if S is UTF8 encoded and false otherwise

#I isUtf8
isUtf8('xyz'&chars[180]);

isUtf8('Schräg');

parseTime('yyyy-mm-dd hh:nn','2000-01-01 03:43');
#S parseTime(formatString:String,input:String);
#C Parses time from a given date format and input
#H See <a href="formatStrings.html">Format Strings</a>

reverseString('Test');
#S reverseString(S:String);
#C reverseString(S:StringList);
#C Returns returns S reversed (character wise not bytewise)

#I regex.matches
#S matches(searchString,regex);
#C returns true if string/-list searchString matches string/-list regex
#C If lists are given they must have equal sizes.
regex.matches('This is a test','[T|t]est');

#I regex.matchComposite
#S matchComposite(searchString,regex);
#C returns a (list of) triplets: [match,position,length] for string/-list regex and searchString
#C If lists are given they must have equal sizes.
regex.matchComposite('This is a test','[T|t]est');

#I regex.replace
#S replace(searchString,regex,replaceString);
#C replaces all matching occurences of string/-list regex in string/-list searchString by string/-list replaceString
#C If lists are given they must have equal sizes.
regex.replace('A Test is a test','[T|t]est','rose');

#I regex.split
#S split(searchString,regex);
#C splits the string/-list searchString using string/-list regex
#C If lists are given they must have equal sizes.
regex.split('A Test is a test','[e| ]');

toBoolean(0);
#S toBoolean(X);
#C Casts X to boolean or throws an error if not possible

toBoolean(1.0);

toBoolean('true');

toBoolean(3);

toInt('32');
#S toInt(X);
#C Casts X to int or throws an error if not possible

toInt(3.0);

toInt(3.1);

toInt(false);

toReal('3.212');
#S toReal(X);
#C Casts X to real or throws an error if not possible

toReal(true);

toReal(3);

getOptions;

executor;
#S executor;
#C returns the path to the currently executing instance of MNH

#I clearPrint
#S clearPrint;
#C Clears the output and returns void.

//Print with line breaks but without pretty printing
print("1\n2.0\n03.45");
#S print(...);
#C Prints out the given parameters and returns void
#C if tabs and line breaks are part of the output, a default pretty-printing is used

//Tab triggers pretty printing - numbers are aligned at decimal dot or comma
print("1\n2.0\n03,45\t");

//Non-numbers are left aligned
print("1\tone\t|\n2.0\ttwo\t|\n03.45\tthree\t|");

//Use \v instead of \t for a tab of zero width
print("1\vone\v|\n2.0\vtwo\v|\n03.45\vthree\v|");

//Simple format: the number of placeholders must match the number of arguments
printf("%x is %d in hexadecimal form",123,123);

//You can adress placeholders by their zero based index
printf("%{$0}x is %{$0}d in hexadecimal form",123);

#I printf
//Placeholders can be complex expressions
printf("sin(%{$0}s)=%{sin($0)}4.4g",1);
#S printf(formatString:String,...);
#C Prints a formatted version of the given 0..n parameters and returns void
#H See <a href="formatStrings.html">Format Strings</a>

permutations([1,1,2]);
#S permutations(L:List);
#C Returns a list of all permutations of S

permutations([1..3]);

#I serialize
#S serialize(x);
#C Returns a string representing x.
#S serialize(x,deflate:Boolean,reuse:Boolean);
#C Custom serialization.

#I deserialize
#S deserialize(s:string);
#C Returns the literal represented by s which was created using serialize(x)

#I fileLines
#S fileLines(filename:String);
#C Returns the contents of the specified file as a list of strings
#C Information on the line breaks is lost

#I writeFile
#S writeFile(filename:String, content:String);
#C Writes the specified content to the specified file and returns true

#I writeFileLines
#S writeFileLines(filename:String, content:StringList);
#C Writes the specified content to the specified file and returns true. If the file exists, the routine uses the previously used line breaks.
#S writeFileLines(filename:String, content:StringList, lineEnding:String);
#C As above with specified line ending

#I appendFileLines
#S appendFileLines(filename:String, content:StringList);
#C Appends the specified content to the specified file and returns true. If the file exists, the routine uses the previously used line breaks.
#S appendFileLines(filename:String, content:StringList, lineEnding:String);
#C As above with specified line ending (will be used only if a new file is created)

#I serialize deserialize
//Test serialization
input:=[[1..10],random,'test',random(9)];
serialized:=input.serialize;
print(input.toString.byteLength,' > ',serialized.byteLength);
input==serialized.deserialize;

factorize(18447422338071909869);
#S factorize(i:Int);
#C Returns a list of all prime factors of i


formatTabs("\v-2\n3\t4.3");
#S formatTabs(S:String);
#C Applies tab formatting as on print

typeOf(3);
#S typeOf(x); 
#C Returns a description of x''s type

typeOf([1..5,7.5]);

#I typeOf
typeOf({$x^2+$y});

#I transpose
#S transpose(L,filler);
#C Returns list L transposed. If sub lists of L have different lengths, filler is used.
#S transpose(L);
#C Returns list L transposed. If sub lists of L have different lengths, it fails.
x:=transpose([1,[1,2,3],[1,2]],0);
x;
x.transpose(0);

resetRandom(12157);
#S resetRandom(seed:Int);
#C Resets internal PRNG with the given seed

//Reset random with default seed 0
resetRandom;

intRandom(7);
#S intRandom(k>1);
#C Returns an integer random value in range [0,k-1]
#S intRandom(k>1,n>0);
#C Returns a list of n integer random values in range [0,k-1]

intRandom(7,10);

random;
#S random;
#C Returns a random value in range [0,1]
#S random(n);
#C Returns a list of n random values in range [0,1]

random(3);

log('This should be logged...');
#S log(...);
#C Logs a message and returns void

note('Note that this is a note');
#S note(...);
#C Raises a note of out the given parameters and returns void

warn('Warning: I intend to say something important here');
#S warn(...);
#C Raises a warning of out the given parameters and returns void

isScalar(1);
#S isScalar(x); 
#C Returns true if x is a scalar

isBoolean(false);
#S isBoolean(x); 
#C Returns true if x is a boolean

isBoolean(1);

isInt(false);

isInt(1);
#S isInt(x); 
#C Returns true if x is a int

isInt(1.0);

isReal(false);

isReal(1);

isReal(1.0);
#S isReal(x); 
#C Returns true if x is a real


isNumeric(false);
#S isNumeric(x); 
#C Returns true if x is a numeric

isNumeric(1);

isNumeric(1.0);

isList([]);
#S isList(x); 
#C Returns true if x is a list. Specify an additional int parameter to additionally check the size.

isList([],0);

isList([],1);

isList(['x'],1);

isString('Test');
#S isString(x); 
#C Returns true if x is a string

isString(true);

#I isExpression
#S isExpression(x); 
#C Returns true if x is a expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isExpression(::sin);

#I isExpression
isExpression(::sin,1);

#I isExpression
isExpression(::sin,2);

digits(123);
#S digits(i>=0);
#C Returns the digits of i (base 10)
#S digits(i>=0, base>1);
#C Returns the digits of i for a custom base

//Digits to base 3
digits(123,3);

arctan2(1,1);
#S arctan2(x, y);
#C Calculates arctan(x/y) and returns an angle in the correct quadrant

charSet('abcba');
#S charSet(S);
#C Returns the characters in S as a set (ordered list without duplicates)

#I bytes
#S bytes(S);
#C Returns the bytes in S as a list of strings
bytes('ö').ord;

base64encode('Test');
#S base64encode(S:String);
#C Converts a string to a base64 encoded string.

base64decode('VGVzdA==');
#S base64decode(S:String);
#C Converts a base64 encoded string to a string.

base92encode('bla bla bla '); //Encode 4 chars to 5 chars
#S base92encode(S:String);
#C Converts a string to a base92 encoded string.

base92decode('PgsC.?d@t^' );
#S base92decode(S:String);
#C Converts a base92 encoded string to a string.

listSideEffects;
#S listSideEffects;
#C Returns a list of all side effects, e.g. as parameters for interpret

changeFileExt('file.extension','.newExtension');
#S changeFileExt(filename,newExtension);
#C Returns the path of file with the new extension

changeFileExt('file.2.extension','.newExtension');

httpError;
#S httpError;
#C Returns http-representation of error 404.
#S httpError(code:Int);
#C Returns http-representation of given error code.

#I startHttpServer
#S startHttpServer(ipAndPort:String, requestToResponseFunc:Expression(1), timeoutInSeconds:Numeric);
#C Starts a new microserver-instance and returns the cleaned up ip and port.
#C The server is shut down automatically if no requests were recieved within timeoutInSeconds.

isBooleanList([true,false]);
#S isBooleanList(x); 
#C Returns true if x is a booleanList. Specify an additional int parameter to additionally check the size.

isBooleanList(true);

isIntList([1..3]);
#S isIntList(x); 
#C Returns true if x is a intList. Specify an additional int parameter to additionally check the size.

isIntList([1, 2.0]);

isRealList([1,2,3]);
#S isRealList(x); 
#C Returns true if x is a realList. Specify an additional int parameter to additionally check the size.
    
isRealList([1.0,2.0,3.0,Nan]);

isStringList(['a'..'z']);
#S isStringList(x); 
#C Returns true if x is a stringList. Specify an additional int parameter to additionally check the size.

isNumericList([1,2,3]);
#S isNumericList(x); 
#C Returns true if x is a numericList. Specify an additional int parameter to additionally check the size.

isNumericList([1.0,2,3,Inf]);

isVoid();
#S isVoid(x); 
#C Returns true if x is void (or no arguments were given)

isVoid(void);

isVoid(3);

escapePascal('Test');
#S escapePascal(S:String);
#C Returns an escaped representation of S for use in Pascal source code

escapeJava('Test');
#S escapeJava(S:String);
#C Returns an escaped representation of S for use in Java source code

extractFileNameOnly('/home/user/file.ext');
#S extractFileNameOnly(F);
#C Returns the expanded file names (without path and extension) of file(s) given by string or stringList F

extractFileDirectory('/home/user/file.ext');

extractFileName('/home/user/file.ext');
#S extractFileName(F);
#C Returns the expanded file names (without path) of file(s) given by string or stringList F

extractFileExt('/home/user/file.ext');
#S extractFileExt(F);
#C Returns the extension(s) of file(s) given by string or stringList F

extractPath('/index.html?x=0&y=3%2Ax');
#S extractPath(request:String);
#C Returns the path part of an http request as a string

extractParameters('/index.html?x=0&y=3%2Ax');
#S extractParameters(request:String);
#C Returns the parameters of an http request as a keyValueList

extractRawParameters('/index.html?x=0&y=3%2Ax');
#S extractRawParameters(request:String);
#C Returns the parameter part of an http request as a string

#I encodeRequest
encodeRequest('127.0.0.1:3126','rest',[['user','anonymous'],['request','3*&7']].toMap);
#S encodeRequest(address:String,path:String,parameters:String);
#S encodeRequest(address:String,path:String,parameters:keyValueList);
#C Returns an http request from the given components

#I httpGet
#S httpGet(URL:String);
#S httpGet(URL:String,body:String,header:Map);
#C Retrieves the contents of the given URL and returns them as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpPut
#S httpPut(URL:String);
#S httpPut(URL:String,body:String,header:Map);
#C Performs an http-PUT on the given URL and returns the response as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpPost
#S httpPost(URL:String);
#S httpPost(URL:String,body:String,header:Map);
#C Performs an http-POST on the given URL and returns the response as a map ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I httpDelete
#S httpDelete(URL:String);
#S httpDelete(URL:String,body:String,header:Map);
#C Performs an http-DELETE on the given URL and returns the response ["body"=>...,"code"=>...,"status"=>...,"header"=>...]

#I openUrl
#S openUrl(URL:String);
#C Opens the URL in the default browser

#I isServerRunning
#S isServerRunning(ipAndPort:String);
#C Returns true if the server is running - only servers in the current instance are checked!

#I cross
#S cross(A,...);
#C Returns the cross product of the arguments (each of which must be a list, set or map)
cross(['1'..'3'],['A'..'C']);

[1,2,1].toSet;

[1.2,3.0].isRealCollection;
#S isRealCollection(x); 
#C Returns true if x is a realCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isRealCollection
[1.2,3.0].toSet.isRealCollection;

[1.2,3].isRealCollection;

[1.2,3.0].isRealCollection(2);

[1.2,3.0].isRealCollection(3);

[true].isBooleanCollection;
#S isBooleanCollection(x); 
#C Returns true if x is a booleanCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isBooleanCollection
[true,false,true].toSet.isBooleanCollection(2);

#I typecast.isBooleanSet
#S isBooleanSet(x); 
#C Returns true if x is a booleanSet. Specify an additional int parameter to additionally check the size.
[true,false,true].toSet.isBooleanSet;

[1,2,3].isIntCollection;
#S isIntCollection(x); 
#C Returns true if x is a intCollection. Specify an additional int parameter to additionally check the size.

[].isIntCollection;

[1.2,3].isNumericCollection;
#S isNumericCollection(x); 
#C Returns true if x is a numericCollection. Specify an additional int parameter to additionally check the size.

#I typecast.isStringSet
#S isStringSet(x); 
#C Returns true if x is a stringSet. Specify an additional int parameter to additionally check the size.
['a','b'].toSet.isStringSet;

['a','b'].isStringCollection;
#S isStringCollection(x); 
#C Returns true if x is a stringCollection. Specify an additional int parameter to additionally check the size.

[1,2,3].isIntSet;
#S isIntSet(x); 
#C Returns true if x is a intSet. Specify an additional int parameter to additionally check the size.

#I typecast.isIntSet
[1,2,3].toSet.isIntSet;

#I typecast.isMap
#S isMap(x); 
#C Returns true if x is a map. Specify an additional int parameter to additionally check the size.
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap;

#I typecast.isMap
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap(2);

#I typecast.isMap
[[1,'1'],[2,'2'],[1,'3']].toMap.isMap(3);

[1,'a',false].isSet;
#S isSet(x); 
#C Returns true if x is a set. Specify an additional int parameter to additionally check the size.

[1,'a',false].isCollection;
#S isCollection(x); 
#C Returns true if x is a collection. Specify an additional int parameter to additionally check the size.

#I strings.utf8ToAnsi
#S utf8ToAnsi(S:String);
#C Converts a UTF8 encoded string to an ANSI encoded string.
utf8ToAnsi('öµ').bytes.ord;

#I strings.ansiToUtf8
#S ansiToUtf8(S:String);
#C Converts an ANSI encoded string to a UTF8 encoded string.
chars[214].ansiToUtf8;

#I typecast.isRealSet
#S isRealSet(x); 
#C Returns true if x is a realSet. Specify an additional int parameter to additionally check the size.
[1.2,3.4].toSet.isRealSet;

toList(3);

#I typecast.toList
#S toList(X);
#C Casts X to list or wraps a scalar in a list
toList([2,3,6].toSet);

#I typecast.isNumericSet
#S isNumericSet(x); 
#C Returns true if x is a numericSet. Specify an additional int parameter to additionally check the size.
[1.2,3.4].toSet.isNumericSet;

#I lists.getAll
#S getAll(L,accessors);
#C Returns elements of list, set or map L by collection of accessors
#S getAll(L,accessors:List,fallback:List);
#C Returns elements of list, set or map L by collection of accessors.
#C If no such element is found, the respective fallback entry is used.
#C fallback must have the same size as accessors
//Mainly intended for bulk map access
[[1,'one'],[3,'three'],[5,'five']].toMap.getAll([1,5,6],['-','-','-']);

#I lists.getAll
HEX:=[0..15].map((i)->format('%x',i)=>i).toMap;
parseHex(s:String)->HEX.getAll(s.chars.upper).composeDigits(16);
parseHex('DeadBeef');

#I lists.getAll
[1,3,5].getAll([0,2])==[1,3,5].get([0,2]);

#I filter
[1..20].filter({$x mod 2<>0<>$x mod 3});

#I filter
//Filtering a generator/iterator results in a new generator/iterator
rangeGenerator(1,20).filter({$x mod 2<>0<>$x mod 3});

#I lists.pMap
['a'..'f'].pMap(::upper);

#I head
//head can be used to access the first elements of a generator/iterator
primeGenerator.head(10);

#I head
//head is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(head);

#I trailing
//trailing is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(trailing);

#I toSet
#S toSet(X);
#C Casts X to set or wraps a scalar in a set
//toSet is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(toSet);

#I max
//max is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(max);

#I min
//min is a valid aggregator marker
[-1,1,-1,1,-2,2].agg(min);

#I OPERATOR_STRCONCAT
[-1,1,-1,1,-2,2].agg(&); //& is a valid aggregator marker

#I OPERATOR_MULT
[-1,1,-1,1,-2,2].agg(*); //multiplication can be used within agg

#I OPERATOR_PLUS
[-1,1,-1,1,-2,2].agg(+); //+ is a valid aggregator marker

#I permutationIterator
permutationIterator([3,1,2]).map(::print).toList;

#I lists.map
#S map(L,f:Expression(1));
#C Returns a list with f(x) for each x in L
#C L may be a generator
#S map(L,f:Expression(0));
#C Returns a list by applying f. The input L is ignored (apart from its size)
['a'..'f'].map(::upper);
#I lists.map
//The result of <generator>.map(<f>) is a new generator
rangeGenerator(1,100).map({$x^2});
#I lists.map
//You can use functions with more parameters if the input matches:
zip([1..10],[10..1]*2).map((x,y)->x+y).toList;

#I lists.mergeMaps
#S mergeMaps(A:Map, B:Map, M:Expression(2));
#C Returns a map, obtained by merging maps A and B.
#C On duplicate keys, the values are merged using M.
//Merge maps; resolve conflicts via ::+
mergeMaps([['A',1], ['B',2]].toMap,
          [['A',7], ['C',3]].toMap,::+);
            
#I system.try
#S try(E:Expression(0));
#C Evaluates E and returns the result if successful or void if failed.
//Try without fallback (returns void)
try({deserialize('x')});
#S try(E:Expression, parameters:List);
#C Evaluates E with the given parameters - the parameter list length must match the arity of E
#S try(E:Expression(0), except(1):Expression);
#C Evaluates E and returns the result if successful. Otherwise <except> is executed with the errors as first paramter ($0).
#S try(E:Expression(0), except:Expression(0));
#C Evaluates E and returns the result if successful. Otherwise <except> is executed without paramters.
#S try(E:Expression(0),except);
#C Evaluates E and returns the result if successful. Otherwise <except> (any type except expression) is returned.
#I system.try
//Try with fallback: print error messages, if any
try({deserialize('x')},::print);

#I system.try
//Try with fallback: return default value
try({deserialize('x')},0);

#I system.try
//Try with fallback: convert error to warning
try({deserialize('x')},{warn($x.head.trailing)});

interpret("3+4");
#S interpret(E);
#C Interprets a String, StringList or Expression(0) E, forbidding any side effects
#S interpret(E, sideEffectWhitelist:StringCollection);
#C As above, but restricting the allowed side effects.

shiftRight(7,1);

#I shiftRight
#S shiftRight(x:Int,bitsToShift:Int);
#C Shifts integer x right by the given number of bits 
#C If bitsToShift<0 a shift-left is performed
shiftRight(5,-2);

#I typecast.toBuiltin
#S toBuiltin(X);
#C Returns X without custom type info
type FiniteRealList(L:List)->L.each(x,!x.isNan,!x.isInfinite,AND);
x:=[1,5,0.4,1/7].toFiniteRealList;
x;
x.typeOf;
x.toBuiltin;
x.toBuiltin.typeOf;

#I interpret
interpret({print("Hello world")},[]); //interpret with no side effects allowed

//Compose binary digits
composeDigits([1,0,1],2);
#S composeDigits(digits:IntList);
#C Returns a number constructed from digits (base 10)
#S composeDigits(digits:IntList, base:Int);
#C Returns a number constructed from digits with given base
#S composeDigits(digits:IntList, base:Int, shift:Int);
#C Returns a number constructed from digits with given base and shift

//Compose in decimal
composeDigits([1,0,2]);

//Compose in decimal, shifted by 2
composeDigits([1,0,2],10,2);

sandBoxExecute("f(x)->3*x+1; f(f(f(1)))",['alter package state']);
#S sandBoxExecute(source, sideEffectWhitelist:StringCollection);
#C Executes the source (String or StringList) and returns created messages.
#C Optionally you can specify allowed side effects.

#I system.async
#S async(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S async(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Asynchronous tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression returns void until the task is finished.
#C If you want to access local variables, use localAsync instead
begin
  x:=async({print('start') orElse sleep(0.1) orElse 'end'});
  print('1: ',x().isVoid); //still running, x() should display void
  sleep(0.2);
  print('2: ',x());
end;

#I localAsync
#S localAsync(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S localAsync(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Asynchronous tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression returns void until the task is finished.
#C If you want a task that runs until the end of the script, use async instead

#I system.future
#S future(E:expression);
#C Calls E asynchronously (without parameters) and returns an expression to access the result.
#S future(E:expression,par:list);
#C Calls E@par and asynchronously and returns an expression to access the result.
#C Future tasks are killed at the end of (synchonous) evaluation.
#C The resulting expression blocks until the task is finished.
begin
  x:=future({print('start') orElse sleep(0.1) orElse 'end'});
  print('1: ',x().isVoid); //x() should block until finished
  sleep(0.2);
  print('2: ',x());
end;

#I peekFuture
#S peekFuture(F:Future);
#C peeks (nonblocking) the future F and returns true if its evaluation is finished, false otherwise

validateRegex('(3+.*');
#S validateRegex(regex:String);
#C Returns true iff regex is valid, false otherwise
#S validateRegex(regex:String,feedback:expression(1));
#C Returns void iff regex is valid, invokes feedback with error message otherwise

validateRegex('\(3+.*');

#I pFilter
[1..100].pFilter({$x mod 2=$x mod 3=$x mod 5});

pi;

#I isStatefulExpression
#S isStatefulExpression(x); 
#C Returns true if x is a stateful expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isStatefulExpression(::sin);

#I isStatefulExpression
isStatefulExpression(future(::sin,[3]));

#I isStatelessExpression
#S isStatelessExpression(x); 
#C Returns true if x is a stateless expression. Specify an additional int parameter k to additionally check if the expression can be applied to k parameters.
isStatelessExpression(::sin);

#I isStatelessExpression
isStatelessExpression(future(::sin,[3]));

#I isIterable
isIterable(future(::sin,[3]));

#I isIterable
isIterable(primeGenerator);

#I isIterable
#S isIterable(x);
#C Returns true if x is an iterable expression, a collection or a map.
isIterable([1..10]);

#I isIterableExpression
#S isIterableExpression(x);
#C Returns true if x is an iterable expression.
isIterableExpression(primeGenerator);

#I isIterableExpression
isIterableExpression([1..10]);

#I isIterable
begin
  resetRandom;
  gen:={begin last:=0; save; last+=random; end};
  print('gen.isIterable= ',gen.isIterable,'; ',gen.head(3));
  gen:=gen.toIterableExpression;
  print('gen.isIterable= ',gen.isIterable,'; ',gen.head(3));
end;

#I toGenerator
#S toGenerator(e:Expression(0));
#C Alias for toIterableExpression

#I toIterableExpression
#S toIterableExpression(e:Expression(0));
#C Marks the expression as IterableExpression if possible or throws an error
toIterableExpression(::sqr);

#I toIterableExpression
toIterableExpression({begin i:=2; save; i+=i-1; end});

euklideanNorm([1,2]);
#S euklideanNorm(v:NumericList);
#C returns the Euklidean norm of vector v

#I assert
assert(1=1.0);

#I assert
#S assert(condition:Boolean);
#C Raises an exception if condition is false
#S assert(condition:Boolean,...);
#C Raises an exception with the given message if condition is false
assert('bla'.isInt,'Invalid integer given');

md5('Test input. Could be anything really.');
#S md5(S:String);
#C Returns the MD5 digest as hexadecimal string for given input S

sha256('Test input. Could be anything really.');
#S sha256(S:String);
#C Returns SHA256 digest as hexadecimal string for given input S

hammingWeight(17213);
#S hammingWeight(x:Int);
#C Returns the hamming weight (i.e. number of true bits) in x

gcd(1231512,143543);
#S gcd(x:Int, ...);
#C Returns the greatest common divider of all arguments (only integers accepted)

#I powMod
#S powMod(x>=0, y>=0, z>=0);
#C Returns x^y mod z
//Example given by rosettacode.org
powMod(2988348162058574136915891421498819466320163312926952423791023078876139,2351399303373464486466122544523690094744975233415544072992656881240319,10^40);

#I randomGenerator
randomGenerator(123).head(10);

#I intRandomGenerator
intRandomGenerator(123,5).head(10);

#I isaacRandomGenerator
isaacRandomGenerator(123,5).head(10);

modularInverse(3,32);
#S modularInverse(x>0, m>0);
#C Returns the modular inverse of x with respect to modul m or NaN if no modular inverse exists

byteToChar(100);
#S byteToChar(b in [0..255]);
#C Returns the corresponding character as a string of one byte length

byteToChar([10,12,97,45]);

systemSpecificFilename('..\test/filename.txt');
#S systemSpecificFilename(name:String);
#C Returns the path with system specific directory separators#systemSpecificFilename(name:StringCollection);

#I setFileDate
#S setFileDate(filename:String, time:Numeric);
#C Sets the time of a given file and returns true on success

#I stringIterator
stringIterator(['a','b','c'],1,3).head(10);

#I vanDerCorputGenerator
#S vanDerCorputGenerator(base>=2);
#C returns a Van der Corput generator for the given base
vanDerCorputGenerator(2).head(10);

#I primeGenerator
primeGenerator.head(1000).trailing(5);

#I rangeGenerator
rangeGenerator(0,5).head(10);

#I rangeGenerator
rangeGenerator(100,-100).head(10);

divMod(10,7);
#S divMod(x:Int,y:Int);
#C Returns a pair [x div y, x mod y]

'abba'.hasPrefix('ab');
#S hasPrefix(s,prefix);
#C Returns true if s starts with prefix

isPrime(47531677974672740279381824573269878221106369761817);
#S isPrime(i:Int);
#C Returns true if i is a prime, false otherwise.
#C result is guaranteed to be correct for i<3.317E23

#I mnh.COMPARATOR_LISTEQ
#S COMPARATOR_LISTEQ(a,b)
#S a == b
#C Returns true if a and b are identical
3==3.0; //not equal, because types differ

#I mnh.COMPARATOR_LISTEQ
[1,2,3]==[3,1,3]; //== always returns a scalar boolean

#I COMPARATOR_LEQ
#S COMPARATOR_LEQ(a,b)
#S a <= b
#C Returns true if a is lesser or equal to b; vectorized for nested lists/sets
3<=3.0;

#I COMPARATOR_LEQ
[1,2,3]<=[3,1,3];

#I COMPARATOR_GEQ
#S COMPARATOR_GEQ(a,b)
#S a >= b
#C Returns true if a is greater than or equal to b; vectorized for nested lists/sets
3>=3.0;

#I COMPARATOR_GEQ
[1,2,3]>=[3,1,3];

#I COMPARATOR_LSS
3<3.0;

#I COMPARATOR_LSS
#S COMPARATOR_LSS(a,b)
#S a < b
#C Returns true if a is lesser than b; vectorized for nested lists/sets
[1,2,3]<[3,1,3];

#I COMPARATOR_GRT
#S COMPARATOR_GRT(a,b)
#S a > b
#C Returns true if a is greater than b; vectorized for nested lists/sets
3>3.0;

#I COMPARATOR_GRT
[1,2,3]>[3,1,3];

#I COMPARATOR_NEQ
#S COMPARATOR_NEQ(a,b)
#S a <> b
#S a != b
#C Returns true if a is not equal to b; vectorized for nested lists/sets
3!=3.0;

#I COMPARATOR_NEQ
[1,2,3]!=[3,1,3];

#I OPERATOR_LAZYAND
true AND false;

#I OPERATOR_LAZYAND
true AND 3; //Lazy boolean operators only examine the left hand side

#I OPERATOR_LAZYAND
#S OPERATOR_LAZYAND(a,b)
#S a AND b
#C Returns a (very) lazy and
false AND 3;  //Lazy boolean operators only examine the left hand side

#I OPERATOR_AND
#S OPERATOR_AND(a,b)
#S a and b
#C Returns a and b; vectorized for nested lists/sets
true and false;

#I OPERATOR_AND
[true,false,true,false] and [true,true,false,false];

#I OPERATOR_AND
7 and 252; //and can be applied on integers

#I OPERATOR_LAZYOR
#S OPERATOR_LAZYOR(a,b)
#S a OR b
#C Returns a (very) lazy or
true OR false;

#I OPERATOR_LAZYOR
true OR 3; //Lazy boolean operators only examine the left hand side

#I OPERATOR_LAZYOR
false OR 3;  //Lazy boolean operators only examine the left hand side

#I OPERATOR_OR
#S OPERATOR_OR(a,b)
#S a or b
#C Returns the conjunction of a and b; vectorized for nested lists/sets
true or false;

#I OPERATOR_OR
[true,false,true,false] or [true,true,false,false];

#I OPERATOR_OR
7 or 252; //or can be applied on integers

#I OPERATOR_XOR
#S OPERATOR_XOR(a,b)
#S a xor b
#C Returns the exclusive conjunction of a and b; vectorized for nested lists/sets
true xor false;

#I OPERATOR_XOR
[true,false,true,false] xor [true,true,false,false];

#I OPERATOR_XOR
7 xor 252; //xor can be applied on integers

#I OPERATOR_UNARY_PLUS
#S OPERATOR_UNARY_PLUS(x)
#S +x
#C This is a dummy function.
+'a'; //the unary plus is a dummy and will be dropped

#I OPERATOR_NEGATE_ARITHMETIC
#S OPERATOR_NEGATE_ARITHMETIC(x)
#S -x
#C Returns the arithmetic negation of x; vectorized for nested lists/sets
-3;

#I OPERATOR_NEGATE_ARITHMETIC
-[1,2.0,Inf,Nan];

#I OPERATOR_NEGATE_LOGICAL
#S OPERATOR_NEGATE_LOGICAL(x)
#S !x
#S not x
#C Returns the logical negation of x; vectorized for nestes lists/sets
!true;

#I OPERATOR_IN
#S OPERATOR_IN(a,b)
#S a in b
#C Returns true if a is contained in (compound) b
3 in [1..5];

#I OPERATOR_IN
3.0 in [1..5]; //3.0 is not contained in [1..5], because the types of 3 (contained in list) and 3.0 differ

#I OPERATOR_NOT_IN
#S OPERATOR_NOT_IN(a,b)
#S a not in b
#C Returns true if a is not contained in b
3 not in [1..5];

#I OPERATOR_NOT_IN
3.0 not in [1..5]; //3.0 is not contained in [1..5], because the types of 3 (contained in list) and 3.0 differ

#I OPERATOR_CONCAT
#S OPERATOR_CONCAT(a,b)
#S a | b
#C Returns a concatenation of a and b, potentially destroying the structure of b.
#C For compound b the following is not generally true: b in (a || b)
1|2;

#I OPERATOR_CONCAT
[1]|[2];

#I OPERATOR_CONCAT
[1]|2;

#I OPERATOR_CONCAT
[1]|[[2]];

#I OPERATOR_CONCATALT
#S OPERATOR_CONCATALT(a,b)
#S a || b
#C Returns a concatenation of a and b, preserving the structure of b.
#C The following is always true: b in (a || b)
[1]||2;

#I OPERATOR_CONCATALT
[1]||[2];

#I OPERATOR_DIVINT
#S OPERATOR_DIVINT(a:Int,b:Int)
#S a div b
#C Returns the integer part of a/b or Nan if b is 0; vectorized for nested lists/sets
10 div 3;

#I OPERATOR_DIVREAL
#S OPERATOR_DIVREAL(a,b)
#S a / b
#C Returns a divided by b or Inf if b = 0 and a != 0; Returns Nan if a = b = 0; vectorized for nested lists/sets
10 / 3;

#I OPERATOR_DIVREAL
10 / 5; //The result of a division of two integers may be an integer

#I OPERATOR_DIVREAL
10.0 / 5; //If either operand is a real number, the quotient will be a real number

#I OPERATOR_ORELSE
#S OPERATOR_ORELSE(a,b)
#S a orElse b
#C Returns a if a is not void, else b
void orElse 42; //orElse returns the right-hand-side if the left-hand-side is void

#I OPERATOR_ORELSE
3 orElse fail; //The right-hand side will never be evaluated for a given (non-void) left-hand-side

#I OPERATOR_MINUS
#S OPERATOR_MINUS(a,b)
#S a - b
#C Returns a minus b; vectorized for nested lists/sets
3-pi;

#I OPERATOR_MOD
#S OPERATOR_MOD(a:Int,b:Int);
#S a mod b;
#C Returns the (symmetric) modulus of a and b or Nan if b is 0.
#C a mod b -> b==0 ? Nan : sign(a) * sign(b) * (abs(a) mod abs(b))
32459378562983 mod 2342832;

7 mod 3;

#I OPERATOR_MOD
-7 mod 3;

#I OPERATOR_MOD
7 mod -3;

#I OPERATOR_MOD
-7 mod -3;

#I OPERATOR_MULT
#S OPERATOR_MULT(a,b)
#S a * b
#C Returns a multiplied with b; vectorized for nested lists/sets
2*3;

#I OPERATOR_MULT
2.0*3; //If either factor is a real number the product will be a real number

#I OPERATOR_PLUS
#S OPERATOR_PLUS(a,b)
#S a + b
#C Returns a plus b; vectorized for nested lists/sets
4+5;

#I OPERATOR_PLUS
'a'+'b'; //You can "add" strings

#I OPERATOR_POT
#S OPERATOR_POT(a,b)
#S a ^ b
#S a ** b
#C Returns a raised to the b-th power; vectorized for nested lists/sets
5^7;

#I OPERATOR_POT
-3.5^3; //Potentiation with a negative base is defined for integer exponents

#I OPERATOR_STRCONCAT
3 & 4; //You can concatenate operands of any type

isSubsetOf([1,2,3],[1,2,3]);
#S isSubsetOf(A,B);
#C Returns true if A is a subset of (or equal to) B

isSubsetOf(1,[1,2,3]);

isSubsetOf([1],[1,2,3]);

isSubsetOf([1,4],[1,2,3]);

#I vectorIfThenElse
#S vectorIfThenElse(condition:BooleanList, Then, Else);
#C Returns the elementwise "if-then-else" result
x:=1/[0..3];
vectorIfThenElse(x.isInfinite,0,x);

#I zip
#S zip(a,b,...);
#C Returns an iterator over [a,b,...].transposed if any parameter is an iterable expression or [a,b,...].transposed if all parameters are compound literals.
zip(rangeGenerator(0),primeGenerator).head(10);

#I kMeans
#S kMeans(inputList:List, k>=2);
#C Returns a map assigning a class index to each entry of the input list. The centers are initialized by random class assignments.
#S kMeans(inputList:List, centers:List);
#C Returns a map assigning a class index to each entry of the input list. The centers are initialized by the second argument.
#C Note that all entries of inputList (and of centers if present) must be NumericList of the same size.
#S kMeans(inputList:List, k_or_centers, max_steps:Int, min_members_per_class:Int); 
#C Fine tuned kMeans. If not present, max_steps defaults to 100 and min_members_per_class defaults to 1.
#C Setting max_steps to 0 indicates, that only a nearest neighbor classification for the given input and centers is performed.
kMeans([1..100].map((i)->random(3)),3);
kMeans([1..100].map((i)->random(3)),[[0,0,1],[0,1,0],[1,0,0]]);

#I kMeans
#S kMeans(inputList:List, k>=2);
#C Returns a map assigning a class index to each entry of the input list. The centers are initialized by random class assignments.
#S kMeans(inputList:List, centers:List);
#C Returns a map assigning a class index to each entry of the input list. The centers are initialized by the second argument.
#C Note that all entries of inputList (and of centers if present) must be NumericList of the same size.
kMeans([1..100].map((i)->random(3)),3);
kMeans([1..100].map((i)->random(3)),[[0,0,1],[0,1,0],[1,0,0]]);

//==END REG TEST==

driveInfo;
#S driveInfo;
#C Returns info on the computer''''s drives/volumes (Windows only).

getCPULoadPercentage;
#S getCPULoadPercentage;
#C Returns the CPU load in percent (Windows only)

#I getTaskInfo
#S getTaskInfo;
#C Returns info on running tasks (Windows only)
getTaskInfo.filter((task)->task['PID']=mnhInfo['PID']);

wrapTextInHttp('Test');
#S wrapTextInHttp(s:String);
#C Wraps s in an http-response (type: "text/html", code: 200)
#S wrapTextInHttp(s:String,type:String);
#C Wraps s in an http-response of given type with code 200.
#S wrapTextInHttp(s:String,code:Int,header:Map);
#C Wraps s in a custom http-response

#I sleep
#S sleep(seconds:Numeric);
#C Sleeps for the given number of seconds before returning void
t0:=scriptTime;
sleep(0.1);
scriptTime-t0;

#I sleepUntil
#S sleepUntil(wallClockSeconds:Numeric);
#C Sleeps until the wallclock reaches the given value

#I scriptTime
#S scriptTime;
#C Returns an internal time for time difference measurement.
t0:=scriptTime;
sleep(0.01);
scriptTime-t0;

#I time
#S time(E:expression);
#C Evaluates E (without parameters) and returns a nested List with evaluation details.
#S time(E:expression,par:list);
#C Evaluates E@par and returns a nested List with evaluation details.
time({sin(random(1000)).agg(+)});

#I systime
formatTime('hh:nn dd.mm.yyyy',systime);
#S systime;
#C Returns the current time as a real number

#I callMemoryCleaner
#S callMemoryCleaner;
#C Calls the memory cleaner

#I assertGuiStarted
#S assertGuiStarted;
#C Enforces GUI initialization

#I isGuiStarted
#S isGuiStarted;
#C Returns true if the GUI is started

#I showConsole
#S showConsole; 
#C shows the console

#I hideConsole
#S hideConsole; 
#C hides the console

#I readXmlFile
#S readXmlFile(filename:String);
#C Reads contents of an XML file and returns the contents as a list

#I readXml
#S readXml(input:String);
#C Parses input as XML and returns the contents as a list

#I parseJson
#S parseJson(value:String);
#C Reads contents of a JSON string and returns an MNH representation.
#S parseJson(value:String,insteadOfNull);
#C As above but representing null values with given marker

parseJson('{A:[1,2,3], B:"x", C:1, nested:{x:0.123,y:4.321}}')

#I formatJson
#S formatJson(x);
#C Formats x as a JSON (as far as compatible)

#I newLinearInterpolator
#S newLinearInterpolator(L:List);
#C returns an linear interpolator, which returns values out of L by their index

#I newSplineInterpolator
#S newSplineInterpolator(L:List);
#C returns an C-Spline interpolator, which returns values out of L by their index

#I newBSpline
#S newBSpline(L:List);
#C returns an Bezier approximator

#I newFourierSeries
#S newFourierSeries(L:List);
#C returns an Fourier Series with coefficients L=[[c0,s0],[c1,s1]...]

#I calculateFourierCoefficients
#S calculateFourierCoefficients(L:List,maxWaveNumber>=0);
#C Calculates fourier coefficients for nonequidistant points in L given as [[t0,y0],[t1,y1],...]

#I newLocalInterpolator
#S newLocalInterpolator(L:List);
#C returns an local non-convex smooth interpolator

newLocalInterpolator([1,2,1,0,3]);


#I rangeGenerator
#S rangeGenerator(i0:Int,i1:Int);
#C returns a generator generating the range [i0..i1]
#S rangeGenerator(start:Int);
#C returns an unbounded increasing generator

#I permutationIterator
#S permutationIterator(i:Int);
#C returns a generator generating the permutations of [1..i]
#S permutationIterator(c:collection);
#C returns a generator generating permutationf of c

#I chunkMap
#S chunkMap(L,chunkSize>0,f:Expression(1));
#C joins L in chunks of the specified size and applies f
#S chunkMap(L,chunkSize>0);
#C Note that the mapping function (if present) is applied AFTER chunking!
#C Always returns an iterable expression

#I pMap
#S pMap(L,f:Expression(1));
#C Returns a list with f(x) for each x in L
#C L may be a generator
#S pMap(L,f:Expression(0));
#C Returns a list by applying f. The input L is ignored (apart from its size)

#I filter
#S filter(L,acceptor:expression(1));
#C Returns compound literal or generator L with all elements x for which acceptor(x) returns true

#I pFilter
#S pFilter(L,acceptor:expression(1));
#C Returns compound literal or generator L with all elements x for which acceptor(x) returns true
#C As filter but processing in parallel

#I fileLineIterator
#S fileLineIterator(filename:String);
#C returns an iterator over all lines in f
#S fileLineIterator(filename:String,timeoutInSeconds:Numeric);
#C The iterator "follows" the file until it is unchanged for timeoutInSeconds

#I byteStreamIterator
#S byteStreamIterator(filename:String,chunkSize>0);
#C returns an iterator over all lines in f
#S byteStreamIterator(...,timeoutInSeconds:Numeric);
#C The iterator "follows" the file until it is unchanged for timeoutInSeconds

#I primeGenerator
#S primeGenerator;
#C returns a generator generating all prime numbers
#C Note that this is an infinite generator!

#I stringIterator
#S stringIterator(charSet:StringCollection,minLength>=0,maxLength>=minLength);
#C returns a generator generating all strings using the given chars

#I randomGenerator
#S randomGenerator(seed:Int);
#C returns a XOS generator for real valued random numbers in range [0,1)

#I intRandomGenerator
#S intRandomGenerator(seed:Int,range>0);
#C returns a XOS generator generating pseudo random integers in range [0,range)
#C The range of the returned generator can be changed by calling it with an integer argument.

#I isaacRandomGenerator
#S isaacRandomGenerator(seed:Int,range>0);
#C returns an ISAAC generator generating pseudo random integers in range [0,range)
#H See <a href="www.burtleburtle.net/bob/rand/isaacafa.html">www.burtleburtle.net/bob/rand/isaacafa.html</a>
#C The range of the returned generator can be changed by calling it with an integer argument.

#I ask
#S ask(q:string);
#C Asks the user question q and returns the user input
#S ask(q:string,options:stringList);
#C Asks the user question q, giving the passed options and returns the chosen option
#S ask(...,visible:Boolean);
#C Optionally disables question feedback (console ask only)

#I showVarible
#S showVarible(L);
#C Shows L in a tree view.
#S showVariable(L,caption:string);
#C Shows L in a tree view with given caption

#I showTable
#S showTable(L:list);
#C Shows L in a table.
#S showTable(L:list,caption:string);
#C Shows L in a table with given caption.
#S showTable(L:list,caption:string,firstRowIsHeader:boolean);
#C Shows L in a table with given caption.
#S showTable(L:list,caption:string,fixedRows:Int,fixedColumns:Int);
#C Shows L with customized fixed rows and columns

#I showDialog
#S showDialog(title:String,contents);
#C Shows a custom dialog defined by the given contents (Map or List)
#C returns void when the form is closed

#I editors
#S editors(...);
#C Lists all editors

#I editorContent
#S editorContent(name:string);
#C Returns the content of the given editor as a string or void if no such editor was found.

#I plotClosed
#S plotClosed;
#C Returns true if the plot has been closed by user interaction

#I clearAnimation
#S clearAnimation;
#C Clears the animated plot
#S clearAnimation(true);
#C Clears the animated plot and switches to volatile mode

#I addAnimationFrame
#S addAnimationFrame;
#C Adds the current plot to the animation and returns ['sleep'=>...,'frameCount'=>...].toMap

#I display
#S display;
#C Displays the plot as soon as possible and waits for execution

#I postDisplay
#S postDisplay;
#C Displays the plot as soon as possible and returns immediately

#I plotImageSize
#S plotImageSize;
#C Returns the plot image size or [-1,-1] if not initialized

#I changeDirectory
#S changeDirectory(folder:String);
#C Sets the working directory

#I setExitCode
#S setExitCode(code:Int);
#C Sets the exit code of the executable.
#C Might be overridden by an evaluation error.

#I beep
#S beep;
#C Makes a beep

getOptions;
#S getOptions;
#C returns plot options as a key-value-list.

#I setOptions
#S setOptions(set:keyValueList);
#C Sets options via a key value list of the same form as returned by plot.getOptions
#S setOptions(key:string,value);
#C Sets a single plot option

#I resetOptions
#S resetOptions;
#C Sets the default plot options

#I renderToFile
#S renderToFile(filename<>'',width>=1,height>=1);
#C Renders the current plot to a file.
#S renderToFile(filename<>'',width>=1,height>=1,background:true);
#C Renders the current plot to a file in a background thread.

#I renderToString
#S renderToString(width,height);
#C Renders the current plot to a string.

#I removePlot
#S removePlot;
#C Removes the last row from the plot
#S removePlot(n>=1);
#C Removed the last n rows from the plot

#I drawText
#S drawText(x,y,text);
#C Draws custom text
#S drawText(x, y, text, size:Numeric, anchor in ["TL","T","TR","CL","C","CR","BL","B","BR"], font:String, textCol:IntList(3), backgroundCol:IntList(3));
#C Draws text with custom options. Custom parameters are optional

#I drawTextAbsolute
#S drawTextAbsolute(x,y,text);
#C Draws custom text at absolute position
#S drawTextAbsolute(x,y,text,size:Numeric,anchor in ["TL","T","TR","CL","C","CR","BL","B","BR"],font:String,textCol:IntList(3),backgroundCol:IntList(3));
#C Draws text with custom options. Custom parameters are optional

#I fileInfo
#S fileInfo(filenameOrPattern:String);
#C Retuns file info as a key-value-list#fileInfo(filenameOrPattern:StringList);
fileInfo(executor);

#I execAsync
#S execAsync(programPath:String,...);
#C Starts the specified program and returns the process id
#C Optional parameters are interpreted by type:
#C   List: command line parameters
#C   Int : Priority (-1 for low, 0 (default) for normal, 1 for high)
execAsync(executor,['-h'],-1);

#I execPipeless
#S execPipeless(programPath:String,...);
#C Executes the specified program, waiting for exit and returns the exit code
#C Optional parameters are interpreted by type:
#C   List: command line parameters
#C   Int : Priority (-1 for low, 0 (default) for normal, 1 for high)
execPipeless(executor,['-h'],-1);

#I deleteFile
#S deleteFile(filename:String);
#C Deletes the given file, returning true on success and false otherwise

#I deleteDir 
#S deleteDir(directoryname:String);
#C Deletes the given directory, returning true on success and false otherwise

#I copyFile 
#S copyFile(source:String,dest:String);
#C Copies a file from source to dest, returning true on success and false otherwise

#I moveFile
#S moveFile(source:String,dest:String);
#C Moves a file from source to dest, returning true on success and false otherwise

#I getEnv
#S getEnv;
#C Returns the current environment variables as a nested list.
getEnv.toList.head;

#I fileStats
#S fileStats(filename:String);
#C Retuns a triplet [lineCount,wordCount,byteCount,hash].
#S fileStats(filename:StringList);
fileStats(executor);

#I exec
#S exec(programPath:String,...);
#C Executes the specified program and returns the text output including stdErr output and the exitcode as a nested list: [[output,...],exitCode]
#C Optional parameters are interpreted by type:
#C   List: command line parameters
#C   Int : Priority (-1 for low, 0 for normal, 1 for high)
#C   Boolean: include stdErr (default: False)
ExecutionResult:=executor.exec(['-h']);
print('Execution returned with code ',
      ExecutionResult[1],"\n",
      ExecutionResult[0]
        .tail(3)
        .head(7)
        .join("\n")
        .clean([#10,' ',')','/','\','_','|'],''));

#I teeExec
#S teeExec(...);
#C Behaves as exec but additionally prints out to stdout
#C You can add an additional expression to use instead of printing to stdout
teeExec('cmd',['/C','echo','Hello!'],(x)->print(x));

#I inspect
#S inspect;
#C Returs information on the current package
#S inspect(idOrPath:String);
#C Returns information on an imported package or a specified MNH source file
#S inspect(path:String,source:StringList);
#C Returns information of a package with given path and source
inspect('sudoku').{
  print('Package ID is: ',$L['id']) |
  print('Path         : ',$L['path']) |
  print('Uses         : ',$L['uses']) |
  $L['declares']
  .each(rule,rule[1,'type']&" rule:\t"&rule[0]&"\t"&rule[1,'location'])
  .join("\n")
  .print};

#I inspectAll
#S inspectAll;
#C Returs information on all currently loaded packages

#I writeAllDataStores
#S writeAllDataStores;
#C Writes back all modified datastores (including stores in imported packages) and returns true if any store was updated.
#S writeAllDatastores(deflate:Boolean,reuse:Boolean);
#C Write binary datastores in a certain format, priorizing speed or size

#I writeDataStores
#S writeDataStores;
#C Writes back all modified datastores of the current package (i.e. excluding stores in imported packages) and returns true if any store was updated.
#S writeDatastores(deflate:Boolean,reuse:Boolean);
#C Write binary datastores in a certain format, priorizing speed or size

#I helpOnMain
#S helpOnMain;
#C Returns help text for the current package''s main method.

#I anyFormShowing
#S anyFormShowing();
#C returns true if any form is showing

#I formatHtmlPage
#S formatHtmlPage(lines:StringList,filename:String);
#C formats naive html

files('*.mnh')
#S files(searchPattern:String);
#C Returns a list of files matching the given search pattern



folders('*');
#S folders(searchPattern:String);
#C Returns a list of folders matching the given search pattern


fileExists('testLog.mnh');
#S fileExists(filename:String);
#C Returns true if the specified file exists and false otherwise

folderExists('folderName');
#S folderExists(foldername:String);
#C Returns true if the specified folder exists and false otherwise

#I fileContents
#S fileContents(filename:String);
#C Returns the contents of the specified file as one string

mnhInfo;
#S mnhInfo;
#C Returns a key-value list with info on the currently executing instance of MNH

myPath;
#S myPath;
#C returns the path to the current package

expandedFileName('/home/user/file.ext');
#S expandedFileName(F);
#C Returns the expanded file name of file(s) given by string or stringList F

ln(3);

#I plot
#S plot(list,options);
#C plots flat numeric list or xy-list
#S plot(xList,yList,options);
#C plots flat numeric list or xy-list
#S plot(f:expression(1),t0,t1>t0,samples>=2,options);
#C plots f versus t in [t0,t1]
#C options are optional and given in the form of a string, the individual option items being delimited by spaces
#C valid options are:
#C Style/size modifier: any real number
#C Styles:
#C   line; l;
#C   bspline; b;
#C   cspline; c;
#C   stepLeft;
#C   stepRight;
#C   fill; f;
#C   fillSolid; fs;
#C   bar;
#C   box;
#C   ellipse; e;
#C   tube;
#C   dot; .;
#C   plus; +;
#C   cross; x;
#C   impulse; i;
#C   polygon; p;
#C Colors:
#C   black;
#C   red;
#C   blue;
#C   green;
#C   purple;
#C   orange;
#C   RGB$,$,$; //With three real numbers in range [0,1]
#C   HSV$,$,$; //With three real numbers in range [0,1]
#C   HUE$; //With one real number
#C   GREY$; //With one real number in range [0,1]
#C Transparency Index:
#C   TI$;// with an integer $

#I addPlot
#S addPlot(list, options);
#C adds plot of flat numeric list or xy-list
#S addPlot(xList, yList, options);
#C adds plot of flat numeric list or xy-list
#S addPlot(f:expression(1), t0, t1>t0, samples>=2, options);
#C adds plot of f versus t in [t0,t1]

#I plotRasterImage
#S plotRasterImage(colors:List;width>=1);
#C Plots a raster image given by a 1D-List of colors
#S plotRasterImage(colors:List;width>=1,scale:Numeric,offsetX:Numeric,offsetY:Numeric);
#C Plots a raster image with custom scaling

#I DFT
#S DFT(x:List);
#C Returns the Discrete Fourier Transform of x
DFT([1..10..1]);

#I iDFT
#S iDFT(x:List);
#C Returns the inverse Discrete Fourier Transform of x
iDFT([[10..0],[0..10]].transpose);

FFT([1..10..1]);
#S FFT(x:List);
#C Returns the Fast Fourier Transform of x

#I iFFT
#S iFFT(x:List);
#C Returns the inverse Fast Fourier Transform of x
iFFT([[10..0],[0..10]].transpose);


#I math.calculateFourierCoefficients
([0..99]/100*2*pi).map((x)->sin(x)+cos(2*x)).calculateFourierCoefficients(8); //Straight forward DFT

#I math.calculateFourierCoefficients
(random(100).sort*2*pi).map((t)->[t,sin(t)+cos(2*t)]).calculateFourierCoefficients(8); //Nonequidistant Fourier transform
//Use the function's output to feed math.newFourierSeries

#I math.integrate
#S integrate(f:Expression(1),x0,x1,subIntervalCount>1);
#C returns the numeric integral of f over interval [x0,x1]
#S integrate(f:Expression(1),x0,x1,subIntervalCount>1,errorTolerance>=0.0);
#C As above, but with an early abort if the error tolerance is satisfied
integrate((x)->sin(x)²,0,2,1000,1E-2);

bitXor(5,213,10);
#S bitXor(x:Int,y:Int,relevantBits in [1..32]);
#C Returns x xor y for the given number of relevant bits         

#I assertUniqueInstance
#S assertUniqueInstance;
#C Returns with an error if there already is an instance of this script running.

#I startIpcServer
#S startIpcServer(id:String, serve:Expression(1));
#C Creates an IPC server
#C An IPC server can receive [I]nter [P]rocess [C]ommunication from other processes.
#C While the server is running, it will receive requests sent via sendIpcRequest, pass the parameters to serve and respond with the result returned by serve.

#I sendIpcRequest
#S sendIpcRequest(serverId:String,request);
#C Delegates a given request to an IPC server

#I isIpcServerRunning
#S isIpcServerRunning(serverId:String);
#C Returns true if the given IPC server is running and false otherwise
#S isIpcServerRunning;
#C Returns true if this script is already running and called assertUniqueInstance

#I validateWorkflow
#S validateWorkflow(wf:list);
#C Validates the workflow returning a boolean flag indicating validity

#I executeWorkflow
#C Executes the workflow with the given options.
#C Use "-" as source or target to read/write the current image.
#C Use "+" as target to directly obtain the raw data of the execution (as via imageRawData).
#S executeWorkflow(wf:list,xRes>0,yRes>0,target:string);
#S executeWorkflow(wf:list,source:string,target:string);
#S executeWorkflow(wf:list,xRes>0,yRes>0,sizeLimitInBytes>0,target:string);
#S executeWorkflow(wf:list,source:string,sizeLimitInBytes>0,target:string);
#C Give an additional expression(1) parameter for progress output

#I imageRawData
#S imageRawData
#C Returns the current image (if there is one) as a list [pixels,width,height]
#C Pixels in turn is a list of colors, RealList(3) each.

#I executeTodo
#S executeTodo(filename:String);
#C Executes the imig-todo defined in the given file and deletes the file after calculation. Returns true if successful.
#S executeTodo(filename:String: outputMethod:Expression(1));

#I loadImage
#S loadImage(filename:string);
#C Loads image from the given file

#I saveImage
#S saveImage(filename:string);
#C Saves the current image to the given file. Supported types: JPG, PNG, BMP, VRAW
#S saveImage(filename:string,sizeLimit:int);
#C Saves the current image to the given file limiting the output size (limit=0 for automatic limiting). JPG only.

#I closeImage
#S closeImage;
#C Closes the current image, freeing associated memory

#I getScreenSize
#S getScreenSize;
#C Returns the current screen size

#I imageDisplaySize
#S imageDisplaySize;
#C Returns the current image display size

#I imageDisplayClosedByUser
#S imageDisplayClosedByUser;
#C Returns true if the image display was closed by the user

#I imageSize
#S imageSize;
#C Returns the size as [width,height] of the current image.
#S imageSize(filename:String);
#C Returns the size of the given file

#I resizeImage
#S resizeImage(xRes>0,yRes>0);
#C Resizes the current image
#S resizeImage(xRes>0,yRes>0,style in ["exact","fill","rotFill","fit","fitExpand","rotFit"]);
#C Resizes the current image with non-default scaling options

#I displayImage
#S displayImage;
#C Displays the current image.

#I imageJpgRawData
#S imageJpgRawData;
#C Returns the image raw data in JPG representation.

#I listManipulations
#S listManipulations;
#C Returns a list of all possible image manipulation steps.

#I calculateThumbnail
#S calculateThumbnail(file:string,maxXRes:int,maxYRes:int);
#C Returns a JPG thumbnail data for given input file

#I renderPlotToCurrentImage
#S renderPlotToCurrentImage(width,height);
#C Renders the current plot to the current image

#I renderToRawData
#S renderToRawData(width,height);
#C Returns the current plot as a list [pixels,width,height]
#C Pixels in turn is a list of colors, RealList(3) each.

#I randomIfs
#S randomIfs;
#C returns a random IFS to be fed to executeWorkflow

#I expandImageGeneration
#S expandImageGeneration(s:String);
#C Returns the generation algorithm with all fields

#I newQueue
#S newQueue;
#C Returns a new queue; The queue can be filled with "put" and otherwise behaves as an iterable.

#I put
#S put(Q:Queue, valueToAdd, ...);
#C Adds one one or more values to the queue

#I closeQueue
#S closeQueue(Q:Queue);
#C Closes the queue

#I newFileOutputStream
#S newFileOutputStream(filename:String, append:Boolean, separator:String);
#C Creates a new file output stream which can be called with bytes, strings, booleans and reals to be written to the file.
#C Parameter append can be omitted. It defaults to false.
#C Parameter separator can be omitted. It defaults to an empty string.

#I ftpConnect
#S ftpConnect(host:String);
#C Connect to FTP server with default port 21 and default credentials
#C The result of the function is required for all further FTP operations.
#C The result of the function is a function that returns true if the connection was successful.
#S ftpConnect(host:String, port:Int);
#C Connect to FTP server with default credentials
#S ftpConnect(host:String, port:Int, user:String, pass:String);
#C Connect to FTP server with default credentials

#I getListing
#S getListing(FTP_connection, path:String);
#C Returns an FTP directory listing as a list of maps [filename=>String, directory=>Boolean, size=>Int, time=>Real];

#I ftpDownload
#S ftpDownload(FTP_connection, remoteSource:String, localTarget:String);
#C Executes an FTP download and returns true on success.

#I ftpUpload
#S ftpUpload(FTP_connection, localSource:String, remoteTarget:String);
#C Executes an FTP upload and returns true on success.

#I ftpMakeDir
#S ftpMakeDir(FTP_connection, path:String);
#C Creates an FTP directory and returns true on success.

#I ftpDeleteDir
#S ftpDeleteDir(FTP_connection, path:String);
#C Deletes an FTP directory and returns true on success.

#I ftpDeleteFile
#S ftpDeleteFile(FTP_connection, path:String);
#C Deletes an FTP file and returns true on success.

#I setTimeout
#S setTimeout(FTP_connection, timeout_in_milliseconds: Int);
#C Sets the timeout for FTP operations.

#I setLogging
#S setLogging(FTP_connection, enable:Boolean);
#C Enables or disables logging (level: Note) for FTP operations.
#C Initially logging is enabled.

#I convolve1D
#S convolve1D(F:NumericList,G:NumericList,allowGrowth:Boolean)
#C Returns the discrete convolution of F and G.
#C If allowGrowth is false (or omitted), G is taken to be a symmetric kernel; the output wil have the same size as F.

#I freeConsole
#S freeConsole
#C Detaches the interpreter from the console.
#C Intended for GUI and/or headless scripts.

#I allFiles
#S allFiles(root);
#C Returns a list of all files below root (string or stringList)
#S allFiles(root,pattern);
#C Returns a list of all files matching pattern(s) (string or stringList)
#S allFiles(root,pattern,recurse=false);
#C As above but without recursing subfolders
allFiles('\','*.*',false);

#I allFolders
#S allFolders(rootFolder:String);
#C Returns a list of all folders below and including a given root directory
allFolders('.');

#I showVariable
#S showVariable(V);
#C Shows V in a tree-view.
